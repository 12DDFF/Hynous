<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hynous Brain Sections</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0a0a0a;
      color: #fafafa;
      font-family: Inter, system-ui, sans-serif;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* ---- Shared button styles (verbatim from graph.html) ---- */
    .btn {
      background: #141414;
      border: 1px solid #262626;
      color: #a3a3a3;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 0.8rem;
      font-family: Inter, system-ui, sans-serif;
      cursor: pointer;
      transition: all 0.15s;
      white-space: nowrap;
    }
    .btn:hover { background: #1a1a1a; color: #fafafa; border-color: #404040; }
    .btn.active { background: #1e1b4b; border-color: #6366f1; color: #a5b4fc; }
    .btn svg { display: block; }

    /* ---- Settings panel (verbatim from graph.html) ---- */
    .settings-panel {
      position: fixed;
      top: 56px;
      left: 16px;
      background: #111111;
      border: 1px solid #1e1e1e;
      border-radius: 10px;
      padding: 0;
      z-index: 20;
      width: 240px;
      display: none;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    }
    .settings-panel.open { display: block; }
    .settings-header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 12px 14px 8px; border-bottom: 1px solid #1a1a1a;
    }
    .settings-header span {
      font-size: 0.7rem; font-weight: 600; text-transform: uppercase;
      letter-spacing: 0.06em; color: #525252;
    }
    .settings-reset {
      font-size: 0.65rem; color: #525252; cursor: pointer;
      background: none; border: none; font-family: Inter, system-ui, sans-serif;
      transition: color 0.15s; padding: 2px 6px; border-radius: 4px;
    }
    .settings-reset:hover { color: #a5b4fc; background: #1a1a2e; }
    .settings-body { padding: 6px 0; }
    .setting-row { padding: 6px 14px; }
    .setting-label-row {
      display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px;
    }
    .setting-label { font-size: 0.75rem; color: #8a8a8a; font-weight: 400; }
    .setting-value {
      font-size: 0.7rem; color: #525252;
      font-family: 'SF Mono', 'Fira Code', monospace; min-width: 32px; text-align: right;
    }
    input[type="range"] {
      -webkit-appearance: none; appearance: none;
      width: 100%; height: 3px; background: #262626;
      border-radius: 2px; outline: none; cursor: pointer;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none; appearance: none;
      width: 12px; height: 12px; border-radius: 50%;
      background: #a5b4fc; border: none; cursor: pointer;
      transition: transform 0.1s, box-shadow 0.15s;
      box-shadow: 0 0 0 0 rgba(165,180,252,0);
    }
    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.15); box-shadow: 0 0 0 4px rgba(165,180,252,0.15);
    }
    input[type="range"]:active::-webkit-slider-thumb {
      transform: scale(1.05); box-shadow: 0 0 0 6px rgba(165,180,252,0.1);
    }
    input[type="range"]::-moz-range-thumb {
      width: 12px; height: 12px; border-radius: 50%;
      background: #a5b4fc; border: none; cursor: pointer;
    }
    input[type="range"]::-moz-range-track { height: 3px; background: #262626; border-radius: 2px; }
    .setting-divider { height: 1px; background: #1a1a1a; margin: 4px 14px; }

    /* ---- Detail panel (verbatim from graph.html) ---- */
    .detail-panel {
      position: fixed;
      bottom: 16px; right: 16px;
      background: #141414; border: 1px solid #262626;
      border-radius: 8px; padding: 16px;
      z-index: 20; width: 300px; max-height: 300px;
      overflow-y: auto; display: none;
    }
    .detail-panel .close-btn {
      position: absolute; top: 8px; right: 10px;
      background: none; border: none; color: #525252;
      cursor: pointer; font-size: 1rem;
    }
    .detail-panel .close-btn:hover { color: #fafafa; }
    .detail-title {
      font-weight: 600; font-size: 0.95rem; color: #fafafa;
      margin-bottom: 8px; padding-right: 20px;
    }
    .detail-row { display: flex; justify-content: space-between; font-size: 0.8rem; padding: 3px 0; }
    .detail-row .label { color: #525252; }
    .detail-row .value { color: #a3a3a3; }
    .detail-summary {
      font-size: 0.8rem; color: #737373; margin-top: 8px;
      line-height: 1.4; border-top: 1px solid #262626; padding-top: 8px;
    }

    /* ---- Legend (verbatim from graph.html) ---- */
    .legend {
      position: fixed; bottom: 16px; right: 16px;
      background: #141414; border: 1px solid #262626;
      border-radius: 8px; padding: 12px 16px;
      z-index: 20; max-height: 280px; overflow-y: auto;
    }
    .legend-title {
      font-size: 0.75rem; color: #525252; text-transform: uppercase;
      letter-spacing: 0.05em; margin-bottom: 8px;
    }
    .legend-item {
      display: flex; align-items: center; gap: 8px;
      padding: 2px 0; font-size: 0.8rem; color: #a3a3a3;
    }
    .legend-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
    .legend-ghost-ring {
      width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0;
      border: 1.5px dashed currentColor; background: transparent;
    }

    /* ---- Stats chip (verbatim from graph.html) ---- */
    .stats {
      position: fixed; top: 16px; right: 16px;
      background: #141414; border: 1px solid #262626;
      border-radius: 8px; padding: 8px 14px;
      font-size: 0.8rem; color: #737373; z-index: 20;
    }
    .stats span { color: #a5b4fc; }

    /* ---- Loading/error (verbatim from graph.html) ---- */
    .loading {
      position: fixed; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      color: #525252; font-size: 0.9rem; z-index: 30;
    }
    .error { color: #ef4444; }

    /* ---- Brain overview ---- */
    #brain-view {
      flex: 1; display: flex; align-items: center; justify-content: center;
      position: relative; overflow: hidden;
    }
    #brain-svg {
      max-height: 85vh; max-width: 90vw;
      transition: transform 0.22s ease-in, opacity 0.22s ease-in;
    }
    .brain-region {
      fill-opacity: 0.35; stroke-opacity: 0.7;
      cursor: pointer; transition: fill-opacity 0.2s, filter 0.2s;
    }
    .brain-region:hover { fill-opacity: 0.6; filter: brightness(1.4); }

    /* Stat chips overlaid on SVG container */
    .region-chip {
      position: absolute; pointer-events: none;
      background: rgba(10,10,10,0.72);
      border: 1px solid rgba(255,255,255,0.07);
      border-radius: 8px; padding: 7px 11px;
      backdrop-filter: blur(6px);
    }
    .chip-name { font-size: 0.78rem; font-weight: 600; line-height: 1.2; }
    .chip-region { font-size: 0.64rem; color: #525252; margin-top: 1px; }
    .chip-count { font-size: 0.68rem; color: #737373; margin-top: 4px; line-height: 1.4; }

    /* ---- Section detail view ---- */
    #section-view {
      flex: 1; display: none; flex-direction: column;
      transition: opacity 0.18s ease-out;
    }
    #section-view.visible { display: flex; }

    .section-header {
      display: flex; align-items: center; gap: 12px;
      padding: 10px 16px; border-bottom: 1px solid #1a1a1a;
      background: #0a0a0a; flex-shrink: 0;
    }
    .section-header-dot {
      width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0;
    }
    .section-header-name { font-size: 0.95rem; font-weight: 600; }
    .section-header-region { font-size: 0.75rem; color: #525252; margin-left: 4px; }
    .section-header-stats { font-size: 0.72rem; color: #404040; margin-left: auto; }

    #graph-container { flex: 1; position: relative; }

    /* Controls bar for section view */
    .controls {
      position: absolute; top: 12px; left: 12px;
      display: flex; gap: 8px; align-items: center; z-index: 10;
    }
    .controls input {
      background: #141414; border: 1px solid #262626;
      color: #fafafa; padding: 8px 12px;
      border-radius: 8px; font-size: 0.85rem;
      font-family: Inter, system-ui, sans-serif;
      outline: none; width: 200px; transition: border-color 0.15s;
    }
    .controls input:focus { border-color: #6366f1; }
    .controls input::placeholder { color: #525252; }

    /* Brain overview controls */
    #brain-controls {
      position: absolute; top: 12px; left: 12px;
      display: flex; gap: 8px; z-index: 10;
    }

    .hidden { display: none !important; }
  </style>
</head>
<body>

  <!-- ========== BRAIN OVERVIEW ========== -->
  <div id="brain-view">
    <div id="brain-controls">
      <button class="btn" id="refresh-btn">Refresh</button>
    </div>

    <svg id="brain-svg" viewBox="0 0 520 420" preserveAspectRatio="xMidYMid meet">
      <defs>
        <filter id="glow-ep">
          <feGaussianBlur stdDeviation="4" result="blur"/>
          <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
        </filter>
        <filter id="glow-sig">
          <feGaussianBlur stdDeviation="4" result="blur"/>
          <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
        </filter>
        <filter id="glow-kn">
          <feGaussianBlur stdDeviation="4" result="blur"/>
          <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
        </filter>
        <filter id="glow-pr">
          <feGaussianBlur stdDeviation="4" result="blur"/>
          <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
        </filter>
      </defs>

      <!-- Outer brain silhouette (decorative, non-interactive) -->
      <path d="M 80 220 Q 60 160 90 120 Q 110 80 155 60 Q 195 40 245 38 Q 295 36 335 55
               Q 375 74 400 105 Q 430 140 435 185 Q 440 225 430 260 Q 420 290 405 308
               Q 385 330 365 340 Q 340 352 310 358 Q 290 362 268 362
               Q 255 362 250 350 Q 242 338 228 342 Q 210 348 195 340
               Q 170 325 155 305 Q 135 278 115 258 Q 92 240 80 220 Z"
            fill="none" stroke="#2a2a2a" stroke-width="1.5"/>

      <!-- KNOWLEDGE — Neocortex (large outer cortex dome, top 2/3) -->
      <path id="region-KNOWLEDGE" data-section="KNOWLEDGE" class="brain-region"
            d="M 155 60 Q 195 40 245 38 Q 295 36 335 55 Q 375 74 400 105
               Q 430 140 435 185 Q 438 210 430 235 Q 410 225 380 215
               Q 350 208 320 205 Q 290 203 260 205 Q 230 207 205 215
               Q 180 223 162 235 Q 140 223 120 205 Q 105 188 100 168
               Q 95 145 105 122 Q 120 92 155 60 Z"
            fill="#4338ca" stroke="#6366f1" stroke-width="1.5"/>

      <!-- EPISODIC — Hippocampus (curved inner structure, center) -->
      <path id="region-EPISODIC" data-section="EPISODIC" class="brain-region"
            d="M 162 235 Q 180 223 205 215 Q 230 207 260 205 Q 290 203 320 205
               Q 350 208 380 215 Q 405 222 418 235 Q 425 248 420 268
               Q 415 288 400 300 Q 382 314 360 322 Q 335 330 305 332
               Q 280 334 258 332 Q 235 330 215 322 Q 190 312 175 298
               Q 158 282 155 265 Q 152 250 162 235 Z"
            fill="#15803d" stroke="#22c55e" stroke-width="1.5"/>

      <!-- SIGNALS — Sensory Cortex (posterior upper wedge, back-top right) -->
      <path id="region-SIGNALS" data-section="SIGNALS" class="brain-region"
            d="M 335 55 Q 375 74 400 105 Q 425 132 432 162 Q 410 158 390 150
               Q 372 143 355 138 Q 338 134 322 134 Q 305 134 292 140
               Q 280 145 272 152 Q 268 140 270 125 Q 274 105 290 88
               Q 308 70 335 55 Z"
            fill="#0e7490" stroke="#06b6d4" stroke-width="1.5"/>

      <!-- PROCEDURAL — Cerebellum (distinct bump at bottom-back) -->
      <path id="region-PROCEDURAL" data-section="PROCEDURAL" class="brain-region"
            d="M 155 265 Q 158 282 175 298 Q 190 312 215 322
               Q 200 335 190 348 Q 178 360 165 358 Q 148 355 138 342
               Q 126 326 120 308 Q 114 290 118 272 Q 128 260 145 258
               Q 152 258 155 265 Z"
            fill="#b45309" stroke="#f59e0b" stroke-width="1.5"/>

      <!-- Brainstem (decorative, non-interactive) -->
      <path d="M 215 322 Q 210 338 208 355 Q 206 368 210 380 Q 218 390 228 392
               Q 240 394 248 385 Q 254 376 252 362"
            fill="none" stroke="#333" stroke-width="2.5" stroke-linecap="round"/>

      <!-- Pathway lines between sections -->
      <g id="pathways" fill="none"></g>
    </svg>

    <!-- Stat chip overlays — positioned via JS -->
    <div id="chips-container" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;"></div>
  </div>

  <!-- ========== SECTION DETAIL VIEW ========== -->
  <div id="section-view">
    <div class="section-header" id="section-header">
      <button class="btn" id="back-btn" style="padding:6px 10px;font-size:0.75rem">← Back</button>
      <div class="section-header-dot" id="section-dot"></div>
      <span class="section-header-name" id="section-name"></span>
      <span class="section-header-region" id="section-region"></span>
      <span class="section-header-stats" id="section-stats"></span>
    </div>
    <div id="graph-container">
      <div class="controls">
        <input type="text" id="search" placeholder="Search..." autocomplete="off" />
        <button class="btn" id="settings-btn" title="Graph Settings">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="4" y1="21" x2="4" y2="14"/><line x1="4" y1="10" x2="4" y2="3"/>
            <line x1="12" y1="21" x2="12" y2="12"/><line x1="12" y1="8" x2="12" y2="3"/>
            <line x1="20" y1="21" x2="20" y2="16"/><line x1="20" y1="12" x2="20" y2="3"/>
            <line x1="1" y1="14" x2="7" y2="14"/><line x1="9" y1="8" x2="15" y2="8"/>
            <line x1="17" y1="16" x2="23" y2="16"/>
          </svg>
        </button>
        <button class="btn" id="reset-view-btn">Reset View</button>
      </div>
    </div>
  </div>

  <!-- Settings Panel (for section force graph) -->
  <div class="settings-panel" id="settings-panel">
    <div class="settings-header">
      <span>Display</span>
      <button class="settings-reset" id="settings-reset">Reset</button>
    </div>
    <div class="settings-body">
      <div class="setting-row">
        <div class="setting-label-row">
          <span class="setting-label">Node Size</span>
          <span class="setting-value" id="val-node-size">1.2</span>
        </div>
        <input type="range" id="setting-node-size" min="0.3" max="3" step="0.1" value="1.2" />
      </div>
      <div class="setting-row">
        <div class="setting-label-row">
          <span class="setting-label">Line Thickness</span>
          <span class="setting-value" id="val-line-thick">1.0</span>
        </div>
        <input type="range" id="setting-line-thick" min="0.2" max="4" step="0.1" value="1.0" />
      </div>
      <div class="setting-divider"></div>
      <div class="setting-row">
        <div class="setting-label-row">
          <span class="setting-label">Center Force</span>
          <span class="setting-value" id="val-center">0.08</span>
        </div>
        <input type="range" id="setting-center" min="0" max="0.2" step="0.005" value="0.08" />
      </div>
      <div class="setting-row">
        <div class="setting-label-row">
          <span class="setting-label">Repel Force</span>
          <span class="setting-value" id="val-repel">45</span>
        </div>
        <input type="range" id="setting-repel" min="0" max="300" step="5" value="45" />
      </div>
      <div class="setting-row">
        <div class="setting-label-row">
          <span class="setting-label">Link Force</span>
          <span class="setting-value" id="val-link-str">0.40</span>
        </div>
        <input type="range" id="setting-link-str" min="0" max="1" step="0.05" value="0.40" />
      </div>
      <div class="setting-row">
        <div class="setting-label-row">
          <span class="setting-label">Link Distance</span>
          <span class="setting-value" id="val-link-dist">70</span>
        </div>
        <input type="range" id="setting-link-dist" min="10" max="400" step="5" value="70" />
      </div>
    </div>
  </div>

  <!-- Legend (populated by JS) -->
  <div class="legend" id="legend" style="display:none;">
    <div class="legend-title" id="legend-title">Section Nodes</div>
  </div>

  <!-- Stats chip -->
  <div class="stats" id="stats" style="display:none;"></div>

  <!-- Detail panel -->
  <div class="detail-panel" id="detail">
    <button class="close-btn" id="detail-close">&times;</button>
    <div class="detail-title" id="detail-title"></div>
    <div id="detail-body"></div>
  </div>

  <!-- Loading indicator -->
  <div class="loading" id="loading">Loading brain data...</div>

  <script src="https://unpkg.com/d3-force@3/dist/d3-force.min.js"></script>
  <script src="https://unpkg.com/force-graph@1.47.4/dist/force-graph.min.js"></script>
  <script>
    // =====================================================================
    // SECTION MAPPING — must match src/hynous/nous/sections.py:42-65
    // =====================================================================
    const SUBTYPE_TO_SECTION = {
      'custom:trade_entry':        'EPISODIC',
      'custom:trade_close':        'EPISODIC',
      'custom:trade_modify':       'EPISODIC',
      'custom:trade':              'EPISODIC',
      'custom:turn_summary':       'EPISODIC',
      'custom:session_summary':    'EPISODIC',
      'custom:market_event':       'EPISODIC',
      'custom:signal':             'SIGNALS',
      'custom:watchpoint':         'SIGNALS',
      'custom:lesson':             'KNOWLEDGE',
      'custom:thesis':             'KNOWLEDGE',
      'custom:curiosity':          'KNOWLEDGE',
      'custom:playbook':           'PROCEDURAL',
      'custom:missed_opportunity': 'PROCEDURAL',
      'custom:good_pass':          'PROCEDURAL',
    };
    const DEFAULT_SECTION = 'KNOWLEDGE';
    function getSection(subtype) {
      return SUBTYPE_TO_SECTION[subtype] || DEFAULT_SECTION;
    }

    // =====================================================================
    // SECTION CONFIGURATION
    // =====================================================================
    const SECTION_CONFIG = {
      EPISODIC: {
        name: 'Episodic Memory', brainRegion: 'Hippocampus',
        description: 'What happened — trades, summaries, events',
        color: '#22c55e', colorDim: '#15803d', colorGhost: '#14532d', glowColor: '#4ade80',
        centroidX: 62, centroidY: 58,  // as % of SVG container for chip placement
      },
      SIGNALS: {
        name: 'Signal Monitor', brainRegion: 'Sensory Cortex',
        description: 'What to watch — signals, watchpoints',
        color: '#06b6d4', colorDim: '#0e7490', colorGhost: '#164e63', glowColor: '#67e8f9',
        centroidX: 72, centroidY: 22,
      },
      KNOWLEDGE: {
        name: 'Knowledge Base', brainRegion: 'Neocortex',
        description: "What I've learned — lessons, theses, curiosity",
        color: '#6366f1', colorDim: '#4338ca', colorGhost: '#312e81', glowColor: '#a5b4fc',
        centroidX: 35, centroidY: 22,
      },
      PROCEDURAL: {
        name: 'Procedural Store', brainRegion: 'Cerebellum',
        description: 'How to act — playbooks, outcome analysis',
        color: '#f59e0b', colorDim: '#b45309', colorGhost: '#78350f', glowColor: '#fcd34d',
        centroidX: 20, centroidY: 72,
      },
    };
    const SECTION_KEYS = ['EPISODIC', 'SIGNALS', 'KNOWLEDGE', 'PROCEDURAL'];

    // SVG centroids (in viewBox coords 0 0 520 420) for pathway line endpoints
    const SVG_CENTROIDS = {
      KNOWLEDGE:  { x: 268, y: 140 },
      EPISODIC:   { x: 290, y: 268 },
      SIGNALS:    { x: 352, y: 120 },
      PROCEDURAL: { x: 148, y: 305 },
    };

    // =====================================================================
    // NODE COLORS + LABELS (from graph.html + 3 PROCEDURAL subtypes added)
    // =====================================================================
    const COLORS = {
      'custom:watchpoint':         '#b48a1a',
      'custom:curiosity':          '#9b59a8',
      'custom:lesson':             '#4a7fb5',
      'custom:thesis':             '#7c6aad',
      'custom:market_event':       '#b07040',
      'custom:trade_entry':        '#3a9e6a',
      'custom:trade_close':        '#a04848',
      'custom:trade_modify':       '#a08030',
      'custom:signal':             '#3a8f85',
      'custom:turn_summary':       '#5a5a6a',
      'custom:session_summary':    '#6a6a78',
      'custom:preference':         '#a05580',
      'custom:trade':              '#2a8a7a',
      'custom:playbook':           '#c084fc',
      'custom:missed_opportunity': '#fb923c',
      'custom:good_pass':          '#34d399',
    };
    const LABELS = {
      'custom:watchpoint':         'Watchpoint',
      'custom:curiosity':          'Curiosity',
      'custom:lesson':             'Lesson',
      'custom:thesis':             'Thesis',
      'custom:market_event':       'Market Event',
      'custom:trade_entry':        'Trade Entry',
      'custom:trade_close':        'Trade Close',
      'custom:trade_modify':       'Trade Modify',
      'custom:signal':             'Signal',
      'custom:turn_summary':       'Turn Summary',
      'custom:session_summary':    'Session Summary',
      'custom:preference':         'Preference',
      'custom:trade':              'Trade',
      'custom:playbook':           'Playbook',
      'custom:missed_opportunity': 'Missed Opportunity',
      'custom:good_pass':          'Good Pass',
    };
    const DEFAULT_COLOR = '#5a6380';

    // =====================================================================
    // SETTINGS (localStorage key separate from graph.html)
    // =====================================================================
    const STORAGE_KEY = 'hynous-brain-settings';
    const SECTION_DEFAULTS = {
      nodeSize: 1.2, lineThick: 1.0,
      centerForce: 0.08, repelForce: 45, linkStrength: 0.4, linkDistance: 70,
    };
    const settings = { ...SECTION_DEFAULTS };

    function saveSettings() {
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(settings)); } catch {}
    }
    function loadSettings() {
      try {
        const saved = JSON.parse(localStorage.getItem(STORAGE_KEY));
        if (saved) Object.assign(settings, saved);
      } catch {}
    }

    // =====================================================================
    // APPLICATION STATE
    // =====================================================================
    let appMode = 'overview';   // 'overview' | 'section'
    let activeSection = null;
    let rawData = null;
    let sectionData = {};
    let nodeSection = new Map();   // nodeId → section key
    let adjMap = new Map();        // nodeId → Set<neighbor nodeIds>
    let nodeById = new Map();      // nodeId → node object
    let sectionGraph = null;       // ForceGraph instance (section view)
    let hoveredNode = null;
    let selectedNode = null;
    let searchTerm = '';
    let sectionLinks = [];         // current section's link array (for batched rendering)

    // =====================================================================
    // URL FALLBACK (same pattern as graph.html)
    // =====================================================================
    const _backendOrigin = location.port === '3000'
      ? location.origin.replace(':3000', ':8000')
      : location.origin.replace('://', '://api.');
    const NOUS_URLS = [
      `${_backendOrigin}/api/nous/graph`,
      'http://localhost:3100/v1/graph',
      'http://127.0.0.1:3100/v1/graph',
    ];
    let activeUrl = null;

    async function tryFetch() {
      if (activeUrl) {
        try {
          const resp = await fetch(activeUrl);
          if (resp.ok) return await resp.json();
        } catch {}
        activeUrl = null;
      }
      for (const url of NOUS_URLS) {
        try {
          const resp = await fetch(url, { signal: AbortSignal.timeout(3000) });
          if (!resp.ok) continue;
          const data = await resp.json();
          activeUrl = url;
          return data;
        } catch { continue; }
      }
      return null;
    }

    // =====================================================================
    // DATA LOADING
    // =====================================================================
    async function loadData() {
      const loadingEl = document.getElementById('loading');
      loadingEl.style.display = 'block';
      loadingEl.className = 'loading';
      loadingEl.textContent = 'Loading brain data...';

      for (let attempt = 0; attempt < 5; attempt++) {
        const data = await tryFetch();
        if (data) {
          rawData = data;
          loadingEl.style.display = 'none';
          classifyAndCompute();
          renderOverview();
          return;
        }
        if (attempt < 4) {
          loadingEl.textContent = `Waiting for Nous server... (attempt ${attempt + 2})`;
          await new Promise(r => setTimeout(r, (attempt + 1) * 1000));
        }
      }
      loadingEl.className = 'loading error';
      loadingEl.textContent = 'Could not connect to Nous server (port 3100). Make sure it is running.';
    }

    // =====================================================================
    // DATA CLASSIFICATION PIPELINE
    // =====================================================================
    function classifyAndCompute() {
      nodeSection = new Map();
      adjMap = new Map();
      nodeById = new Map();

      // Clean edges that reference missing nodes
      const nodeIds = new Set(rawData.nodes.map(n => n.id));
      rawData.edges = (rawData.edges || []).filter(e => nodeIds.has(e.source) && nodeIds.has(e.target));

      // 1. Classify every node into a section + build lookups
      for (const node of rawData.nodes) {
        const sec = getSection(node.subtype);
        nodeSection.set(node.id, sec);
        nodeById.set(node.id, node);
        adjMap.set(node.id, new Set());
        node._color = COLORS[node.subtype] || DEFAULT_COLOR;
        node._opacity = Math.max(0.15, (node.retrievability ?? 1) * 0.85 + 0.15);
        node._titleLower = (node.title || '').toLowerCase();
        node._subtypeLower = (node.subtype || '').toLowerCase();
        node._conns = 0;
      }

      // 2. Build adjacency map + connection counts
      for (const edge of rawData.edges) {
        const sid = edge.source;
        const tid = edge.target;
        adjMap.get(sid)?.add(tid);
        adjMap.get(tid)?.add(sid);
        const sn = nodeById.get(sid);
        const tn = nodeById.get(tid);
        if (sn) sn._conns++;
        if (tn) tn._conns++;
      }

      // 3. Base radius
      for (const node of rawData.nodes) {
        node._baseRadius = Math.min(6, 2.8 + Math.log2(node._conns + 1) * 1.1);
      }

      // 4. Compute per-section data
      for (const sectionKey of SECTION_KEYS) {
        const primaryNodes = rawData.nodes.filter(n => nodeSection.get(n.id) === sectionKey);
        const primaryIds = new Set(primaryNodes.map(n => n.id));
        const ghosts = computeGhosts(sectionKey, primaryIds);
        const healthStats = computeHealth(primaryNodes);
        const crossEdgeCount = countCrossEdges(primaryIds, ghosts);
        sectionData[sectionKey] = { nodes: primaryNodes, ghosts, healthStats, crossEdgeCount };
      }
    }

    function computeGhosts(sectionKey, primaryIds) {
      const ghostCounts = new Map();
      for (const edge of rawData.edges) {
        const srcIn = primaryIds.has(edge.source);
        const tgtIn = primaryIds.has(edge.target);
        if (srcIn && !tgtIn) {
          ghostCounts.set(edge.target, (ghostCounts.get(edge.target) || 0) + 1);
        }
        if (tgtIn && !srcIn) {
          ghostCounts.set(edge.source, (ghostCounts.get(edge.source) || 0) + 1);
        }
      }
      return [...ghostCounts.entries()]
        .filter(([id]) => !primaryIds.has(id))
        .sort((a, b) => b[1] - a[1])
        .slice(0, 50)
        .map(([id]) => nodeById.get(id))
        .filter(Boolean);
    }

    function computeHealth(nodes) {
      const stats = { ACTIVE: 0, WEAK: 0, DORMANT: 0, total: nodes.length };
      for (const n of nodes) {
        const lc = (n.lifecycle || '').toUpperCase();
        if (lc === 'ACTIVE') stats.ACTIVE++;
        else if (lc === 'WEAK') stats.WEAK++;
        else stats.DORMANT++;
      }
      return stats;
    }

    function countCrossEdges(primaryIds, ghosts) {
      const ghostIds = new Set(ghosts.map(g => g.id));
      let count = 0;
      for (const edge of rawData.edges) {
        const srcIn = primaryIds.has(edge.source);
        const tgtIn = primaryIds.has(edge.target);
        const srcGhost = ghostIds.has(edge.source);
        const tgtGhost = ghostIds.has(edge.target);
        if ((srcIn && tgtGhost) || (tgtIn && srcGhost)) count++;
      }
      return count;
    }

    function computePathways() {
      const counts = {};
      for (const edge of rawData.edges) {
        const s1 = nodeSection.get(edge.source);
        const s2 = nodeSection.get(edge.target);
        if (!s1 || !s2 || s1 === s2) continue;
        const key = [s1, s2].sort().join('↔');
        counts[key] = (counts[key] || 0) + 1;
      }
      return counts;
    }

    // =====================================================================
    // BRAIN OVERVIEW RENDERING
    // =====================================================================
    function renderOverview() {
      // Update region colors + opacity based on node count
      for (const key of SECTION_KEYS) {
        const cfg = SECTION_CONFIG[key];
        const el = document.getElementById(`region-${key}`);
        if (!el) continue;
        const nodeCount = sectionData[key]?.nodes.length || 0;
        el.setAttribute('fill', cfg.colorDim);
        el.setAttribute('stroke', cfg.color);
        if (nodeCount === 0) {
          el.style.fillOpacity = '0.15';
          el.style.strokeOpacity = '0.3';
        } else {
          el.style.fillOpacity = '0.35';
          el.style.strokeOpacity = '0.7';
        }
      }

      // Render pathway lines
      renderPathways();

      // Render stat chips
      renderChips();
    }

    function renderPathways() {
      const pathways = computePathways();
      const g = document.getElementById('pathways');
      g.innerHTML = '';

      const pairs = [
        ['KNOWLEDGE', 'EPISODIC'],
        ['KNOWLEDGE', 'SIGNALS'],
        ['KNOWLEDGE', 'PROCEDURAL'],
        ['EPISODIC', 'SIGNALS'],
        ['EPISODIC', 'PROCEDURAL'],
        ['SIGNALS', 'PROCEDURAL'],
      ];

      for (const [a, b] of pairs) {
        const key = [a, b].sort().join('↔');
        const count = pathways[key] || 0;
        if (count === 0) continue;

        const ca = SVG_CENTROIDS[a];
        const cb = SVG_CENTROIDS[b];
        const strokeW = Math.max(0.8, Math.min(4, Math.log2(count + 1) * 0.9));
        const cfgA = SECTION_CONFIG[a];

        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', ca.x); line.setAttribute('y1', ca.y);
        line.setAttribute('x2', cb.x); line.setAttribute('y2', cb.y);
        line.setAttribute('stroke', cfgA.color);
        line.setAttribute('stroke-width', strokeW);
        line.setAttribute('stroke-opacity', '0.25');
        line.setAttribute('stroke-dasharray', '4 3');
        g.appendChild(line);

        // Count label at midpoint if count > 5
        if (count > 5) {
          const mx = (ca.x + cb.x) / 2;
          const my = (ca.y + cb.y) / 2;
          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('x', mx); text.setAttribute('y', my);
          text.setAttribute('text-anchor', 'middle');
          text.setAttribute('dominant-baseline', 'middle');
          text.setAttribute('fill', '#525252');
          text.setAttribute('font-size', '9');
          text.setAttribute('font-family', 'Inter, system-ui, sans-serif');
          text.textContent = count;
          g.appendChild(text);
        }
      }
    }

    function renderChips() {
      const container = document.getElementById('chips-container');
      container.innerHTML = '';

      for (const key of SECTION_KEYS) {
        const cfg = SECTION_CONFIG[key];
        const data = sectionData[key];
        if (!data) continue;

        const h = data.healthStats;
        const chip = document.createElement('div');
        chip.className = 'region-chip';
        chip.style.left = cfg.centroidX + '%';
        chip.style.top = cfg.centroidY + '%';
        chip.style.transform = 'translate(-50%, -50%)';

        chip.innerHTML = `
          <div class="chip-name" style="color:${cfg.color}">${cfg.name}</div>
          <div class="chip-region">${cfg.brainRegion}</div>
          <div class="chip-count">${h.total} nodes — <span style="color:#22c55e">${h.ACTIVE} active</span> / <span style="color:#eab308">${h.WEAK} weak</span> / <span style="color:#525252">${h.DORMANT} dormant</span></div>
        `;
        container.appendChild(chip);
      }
    }

    // =====================================================================
    // SECTION TRANSITIONS
    // =====================================================================
    function enterSection(sectionKey) {
      appMode = 'section';
      activeSection = sectionKey;

      const svg = document.getElementById('brain-svg');
      svg.style.transition = 'transform 0.22s ease-in, opacity 0.22s ease-in';
      svg.style.transform = 'scale(1.8)';
      svg.style.opacity = '0';

      setTimeout(() => {
        document.getElementById('brain-view').classList.add('hidden');

        const sectionView = document.getElementById('section-view');
        sectionView.classList.remove('hidden');
        sectionView.classList.add('visible');
        sectionView.style.opacity = '0';
        sectionView.style.transition = 'opacity 0.18s ease-out';

        updateSectionHeader(sectionKey);
        mountSectionGraph(sectionKey);

        requestAnimationFrame(() => {
          sectionView.style.opacity = '1';
        });

        // Reset SVG for next visit
        svg.style.transition = 'none';
        svg.style.transform = 'scale(1)';
        svg.style.opacity = '1';
      }, 230);
    }

    function exitSection() {
      const sectionView = document.getElementById('section-view');
      sectionView.style.transition = 'opacity 0.18s ease-in';
      sectionView.style.opacity = '0';

      setTimeout(() => {
        if (sectionGraph) {
          try { sectionGraph._destructor?.(); } catch {}
          sectionGraph = null;
        }
        // Clear graph container
        const gc = document.getElementById('graph-container');
        const canvas = gc.querySelector('canvas');
        if (canvas) canvas.remove();

        sectionView.classList.add('hidden');
        sectionView.classList.remove('visible');

        // Hide panels
        document.getElementById('legend').style.display = 'none';
        document.getElementById('stats').style.display = 'none';
        document.getElementById('detail').style.display = 'none';
        document.getElementById('settings-panel').classList.remove('open');
        document.getElementById('settings-btn').classList.remove('active');
        document.getElementById('search').value = '';
        searchTerm = '';
        hoveredNode = null;
        selectedNode = null;

        const brainView = document.getElementById('brain-view');
        brainView.classList.remove('hidden');
        brainView.style.opacity = '0';
        brainView.style.transition = 'opacity 0.18s ease-out';
        requestAnimationFrame(() => { brainView.style.opacity = '1'; });

        activeSection = null;
        appMode = 'overview';
      }, 200);
    }

    // =====================================================================
    // SECTION HEADER
    // =====================================================================
    function updateSectionHeader(sectionKey) {
      const cfg = SECTION_CONFIG[sectionKey];
      const data = sectionData[sectionKey];
      const h = data.healthStats;

      document.getElementById('section-dot').style.background = cfg.color;
      document.getElementById('section-name').textContent = cfg.name;
      document.getElementById('section-name').style.color = cfg.color;
      document.getElementById('section-region').textContent = '· ' + cfg.brainRegion;
      document.getElementById('section-stats').textContent =
        `${h.total} primary · ${data.ghosts.length} ghosts · ${data.crossEdgeCount} cross-edges`;

      // Update search placeholder
      document.getElementById('search').placeholder = `Search ${cfg.name}...`;
    }

    // =====================================================================
    // SECTION GRAPH DATA
    // =====================================================================
    function buildSectionGraphData(sectionKey) {
      const primary = sectionData[sectionKey].nodes;
      const ghosts = sectionData[sectionKey].ghosts;
      const primarySet = new Set(primary.map(n => n.id));
      const ghostSet = new Set(ghosts.map(n => n.id));
      const allIds = new Set([...primarySet, ...ghostSet]);

      const nodes = [
        ...primary.map(n => ({ ...n, _role: 'primary' })),
        ...ghosts.map(n => ({ ...n, _role: 'ghost', _ghostSection: nodeSection.get(n.id) })),
      ];

      const links = rawData.edges
        .filter(e => allIds.has(e.source) && allIds.has(e.target))
        .map(e => ({
          ...e,
          _category: primarySet.has(e.source) && primarySet.has(e.target) ? 'primary'
            : (primarySet.has(e.source) || primarySet.has(e.target)) ? 'cross'
            : 'ghost',
        }));

      return { nodes, links };
    }

    // =====================================================================
    // HELPERS
    // =====================================================================
    function getRadius(node) {
      return (node._baseRadius || 2.8) * settings.nodeSize;
    }

    function isHighlighted(node) {
      if (!searchTerm) return true;
      return node._titleLower.includes(searchTerm) || node._subtypeLower.includes(searchTerm);
    }

    function formatDate(iso) {
      if (!iso) return '?';
      try {
        const d = new Date(iso);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
      } catch { return iso.slice(0, 10); }
    }

    function subtypeLabel(subtype) {
      if (!subtype) return 'unknown';
      return LABELS[subtype] || subtype.replace('custom:', '');
    }

    // =====================================================================
    // DETAIL PANEL
    // =====================================================================
    function showDetail(node) {
      selectedNode = node;
      const panel = document.getElementById('detail');
      const title = document.getElementById('detail-title');
      const body = document.getElementById('detail-body');

      title.textContent = node.title || 'Untitled';
      title.style.color = node._color || DEFAULT_COLOR;

      const retr = node.retrievability != null ? (node.retrievability * 100).toFixed(0) + '%' : '?';
      const sec = nodeSection.get(node.id) || DEFAULT_SECTION;
      const secCfg = SECTION_CONFIG[sec];
      const role = node._role === 'ghost' ? 'Ghost' : 'Primary';

      let html = '';
      html += `<div class="detail-row"><span class="label">Type</span><span class="value">${subtypeLabel(node.subtype)}</span></div>`;
      html += `<div class="detail-row"><span class="label">Section</span><span class="value" style="color:${secCfg.color}">${secCfg.name} (${role})</span></div>`;
      html += `<div class="detail-row"><span class="label">Lifecycle</span><span class="value">${node.lifecycle || '?'}</span></div>`;
      html += `<div class="detail-row"><span class="label">Retrievability</span><span class="value">${retr}</span></div>`;
      html += `<div class="detail-row"><span class="label">Access Count</span><span class="value">${node.access_count || 0}</span></div>`;
      html += `<div class="detail-row"><span class="label">Created</span><span class="value">${formatDate(node.created_at)}</span></div>`;
      html += `<div class="detail-row"><span class="label">Connections</span><span class="value">${node._conns || 0}</span></div>`;

      if (node.summary) {
        html += `<div class="detail-summary">${node.summary}</div>`;
      }

      body.innerHTML = html;
      panel.style.display = 'block';
    }

    function hideDetail() {
      selectedNode = null;
      document.getElementById('detail').style.display = 'none';
    }

    // =====================================================================
    // LEGEND
    // =====================================================================
    function buildSectionLegend(sectionKey) {
      const legendEl = document.getElementById('legend');
      const title = document.getElementById('legend-title');
      const cfg = SECTION_CONFIG[sectionKey];
      title.textContent = cfg.name;
      title.style.color = cfg.color;

      // Clear existing items
      legendEl.querySelectorAll('.legend-item').forEach(i => i.remove());

      const data = sectionData[sectionKey];
      const primarySubtypes = new Set(data.nodes.map(n => n.subtype).filter(Boolean));

      // Primary subtypes
      for (const [subtype, label] of Object.entries(LABELS)) {
        if (!primarySubtypes.has(subtype)) continue;
        const item = document.createElement('div');
        item.className = 'legend-item';
        item.innerHTML = `<div class="legend-dot" style="background:${COLORS[subtype] || DEFAULT_COLOR}"></div>${label}`;
        legendEl.appendChild(item);
      }

      // Ghost sections
      const ghostSections = new Map(); // section → count
      for (const ghost of data.ghosts) {
        const gs = nodeSection.get(ghost.id);
        if (gs && gs !== sectionKey) {
          ghostSections.set(gs, (ghostSections.get(gs) || 0) + 1);
        }
      }

      if (ghostSections.size > 0) {
        const divider = document.createElement('div');
        divider.style.cssText = 'height:1px;background:#1a1a1a;margin:6px 0;';
        legendEl.appendChild(divider);
        const ghostTitle = document.createElement('div');
        ghostTitle.style.cssText = 'font-size:0.68rem;color:#404040;text-transform:uppercase;letter-spacing:0.05em;padding:2px 0 4px;';
        ghostTitle.textContent = 'Neighbor Sections';
        legendEl.appendChild(ghostTitle);

        for (const [gs, count] of ghostSections.entries()) {
          const gcfg = SECTION_CONFIG[gs];
          const item = document.createElement('div');
          item.className = 'legend-item';
          item.innerHTML = `<div class="legend-ghost-ring" style="color:${gcfg.color}"></div><span style="color:${gcfg.color}">${gcfg.name}</span><span style="color:#404040;margin-left:4px">(${count})</span>`;
          legendEl.appendChild(item);
        }
      }

      legendEl.style.display = 'block';
    }

    // =====================================================================
    // FORCE GRAPH MOUNTING
    // =====================================================================
    function mountSectionGraph(sectionKey) {
      const cfg = SECTION_CONFIG[sectionKey];
      const graphData = buildSectionGraphData(sectionKey);
      sectionLinks = graphData.links;

      const el = document.getElementById('graph-container');

      document.getElementById('stats').innerHTML =
        `<span>${sectionData[sectionKey].nodes.length}</span> primary &middot; <span>${sectionData[sectionKey].ghosts.length}</span> ghosts`;
      document.getElementById('stats').style.display = 'block';

      buildSectionLegend(sectionKey);

      if (graphData.nodes.length === 0) {
        const msg = document.createElement('div');
        msg.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#404040;font-size:0.9rem;';
        msg.textContent = `No memories in ${cfg.name} yet.`;
        el.appendChild(msg);
        return;
      }

      sectionGraph = ForceGraph()(el)
        .graphData(graphData)
        .backgroundColor('#0a0a0a')
        .width(el.clientWidth)
        .height(el.clientHeight)
        .warmupTicks(60)
        .cooldownTime(3000)
        .d3AlphaDecay(0.03)

        // Node rendering
        .nodeCanvasObject((node, ctx) => {
          const r = getRadius(node);
          const isGhost = node._role === 'ghost';
          const isSelected = selectedNode && selectedNode.id === node.id;
          const isHovered = hoveredNode && hoveredNode.id === node.id;
          const isConnected = selectedNode && adjMap.get(selectedNode.id)?.has(node.id);

          // Determine alpha
          let alpha;
          if (isGhost) {
            alpha = 0.18;
            if (searchTerm && isHighlighted(node)) alpha = 0.6;
            if (searchTerm && !isHighlighted(node)) alpha = 0.05;
            if (selectedNode && (isSelected || isConnected)) alpha = 0.55;
            if (selectedNode && !isSelected && !isConnected) alpha = 0.06;
          } else {
            alpha = node._opacity;
            if (searchTerm && !isHighlighted(node)) alpha = 0.06;
            if (selectedNode && !isSelected && !isConnected) alpha = 0.12;
          }

          const nodeColor = isGhost
            ? (SECTION_CONFIG[node._ghostSection]?.colorGhost || DEFAULT_COLOR)
            : node._color;

          // Glow for hovered/selected
          if ((isHovered || isSelected) && !isGhost) {
            const glowR = r + 6 * settings.nodeSize;
            const grad = ctx.createRadialGradient(node.x, node.y, r * 0.3, node.x, node.y, glowR);
            const gc = cfg.glowColor;
            grad.addColorStop(0, gc + 'cc');
            grad.addColorStop(0.35, gc + '66');
            grad.addColorStop(0.7, gc + '22');
            grad.addColorStop(1, gc + '00');
            ctx.beginPath();
            ctx.arc(node.x, node.y, glowR, 0, 2 * Math.PI);
            ctx.fillStyle = grad;
            ctx.globalAlpha = isSelected ? 0.95 : 0.85;
            ctx.fill();
          }

          // Core node
          ctx.beginPath();
          ctx.arc(node.x, node.y, r, 0, 2 * Math.PI);
          ctx.fillStyle = isGhost ? (SECTION_CONFIG[node._ghostSection]?.colorGhost || DEFAULT_COLOR) : node._color;
          ctx.globalAlpha = alpha;
          ctx.fill();

          // Dashed ring for ghost nodes
          if (isGhost) {
            const ghostSecColor = SECTION_CONFIG[node._ghostSection]?.color || DEFAULT_COLOR;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.arc(node.x, node.y, r + 2.5, 0, 2 * Math.PI);
            ctx.strokeStyle = ghostSecColor;
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.3;
            ctx.stroke();
            ctx.setLineDash([]);
          }

          ctx.globalAlpha = 1;
        })
        .nodePointerAreaPaint((node, color, ctx) => {
          const r = getRadius(node) + 4;
          ctx.beginPath();
          ctx.arc(node.x, node.y, r, 0, 2 * Math.PI);
          ctx.fillStyle = color;
          ctx.fill();
        })

        // Edge rendering — batched by category
        .linkCanvasObject((link, ctx) => {
          if (link !== sectionLinks[0]) return;

          const lineThick = settings.lineThick;
          ctx.strokeStyle = '#9090a0';

          const primaryLinks = sectionLinks.filter(l => l._category === 'primary');
          const crossLinks = sectionLinks.filter(l => l._category === 'cross');
          const ghostLinks = sectionLinks.filter(l => l._category === 'ghost');

          function drawBatch(links, alpha, lw) {
            if (!links.length) return;
            ctx.globalAlpha = alpha;
            ctx.lineWidth = lw;
            ctx.beginPath();
            for (const l of links) {
              const sx = (l.source.x ?? l.source);
              const sy = (l.source.y ?? l.source);
              const tx = (l.target.x ?? l.target);
              const ty = (l.target.y ?? l.target);
              if (typeof sx !== 'number') continue;
              ctx.moveTo(sx, sy);
              ctx.lineTo(tx, ty);
            }
            ctx.stroke();
          }

          drawBatch(primaryLinks, 0.35, 0.4 * lineThick);
          drawBatch(crossLinks,   0.18, 0.3 * lineThick);
          drawBatch(ghostLinks,   0.06, 0.2 * lineThick);
          ctx.globalAlpha = 1;
        })
        .autoPauseRedraw(false)
        .onNodeHover((node) => {
          hoveredNode = node;
          el.style.cursor = node ? 'pointer' : 'default';
        })
        .onNodeClick((node) => {
          if (selectedNode && selectedNode.id === node.id) {
            selectedNode = null;
            hideDetail();
            return;
          }
          showDetail(node);
          sectionGraph.centerAt(node.x, node.y, 400);
          sectionGraph.zoom(3, 400);
        })
        .onBackgroundClick(() => {
          selectedNode = null;
          hideDetail();
        });

      // Forces
      sectionGraph.d3Force('charge').strength(-settings.repelForce);
      sectionGraph.d3Force('link').distance(settings.linkDistance);
      if (settings.linkStrength > 0) {
        sectionGraph.d3Force('link').strength(settings.linkStrength);
      }
      sectionGraph.d3Force('gravity-x', d3.forceX(0).strength(settings.centerForce));
      sectionGraph.d3Force('gravity-y', d3.forceY(0).strength(settings.centerForce));

      window.addEventListener('resize', onResize);
    }

    function onResize() {
      const el = document.getElementById('graph-container');
      if (sectionGraph) {
        sectionGraph.width(el.clientWidth).height(el.clientHeight);
      }
    }

    function applyForces() {
      if (!sectionGraph) return;
      sectionGraph.d3Force('charge').strength(-settings.repelForce);
      sectionGraph.d3Force('link').distance(settings.linkDistance);
      if (settings.linkStrength > 0) {
        sectionGraph.d3Force('link').strength(settings.linkStrength);
      }
      sectionGraph.d3Force('gravity-x').strength(settings.centerForce);
      sectionGraph.d3Force('gravity-y').strength(settings.centerForce);
      sectionGraph.d3ReheatSimulation();
    }

    // =====================================================================
    // SETTINGS PANEL
    // =====================================================================
    const sliderMap = [
      { id: 'setting-node-size',  valId: 'val-node-size',  key: 'nodeSize',     fmt: v => v.toFixed(1),               visual: true },
      { id: 'setting-line-thick', valId: 'val-line-thick', key: 'lineThick',    fmt: v => v.toFixed(1),               visual: true },
      { id: 'setting-center',     valId: 'val-center',     key: 'centerForce',  fmt: v => v.toFixed(2),               visual: false },
      { id: 'setting-repel',      valId: 'val-repel',      key: 'repelForce',   fmt: v => String(Math.round(v)),      visual: false },
      { id: 'setting-link-str',   valId: 'val-link-str',   key: 'linkStrength', fmt: v => v.toFixed(2),               visual: false },
      { id: 'setting-link-dist',  valId: 'val-link-dist',  key: 'linkDistance', fmt: v => String(Math.round(v)),      visual: false },
    ];

    function initSettings() {
      loadSettings();
      for (const s of sliderMap) {
        const slider = document.getElementById(s.id);
        const valEl  = document.getElementById(s.valId);
        slider.value = settings[s.key];
        valEl.textContent = s.fmt(settings[s.key]);

        slider.addEventListener('input', () => {
          const v = parseFloat(slider.value);
          settings[s.key] = v;
          valEl.textContent = s.fmt(v);
          saveSettings();
          if (s.visual) { if (sectionGraph) sectionGraph.refresh(); }
          else { applyForces(); }
        });
      }
    }

    function resetSettings() {
      Object.assign(settings, SECTION_DEFAULTS);
      saveSettings();
      for (const s of sliderMap) {
        const slider = document.getElementById(s.id);
        const valEl  = document.getElementById(s.valId);
        slider.value = settings[s.key];
        valEl.textContent = s.fmt(settings[s.key]);
      }
      applyForces();
      if (sectionGraph) sectionGraph.refresh();
    }

    // =====================================================================
    // EVENT HANDLERS
    // =====================================================================

    // Brain region clicks
    document.querySelectorAll('.brain-region').forEach(el => {
      el.addEventListener('click', () => {
        const key = el.dataset.section;
        if (key) enterSection(key);
      });
    });

    // Back button
    document.getElementById('back-btn').addEventListener('click', exitSection);

    // Refresh button (overview)
    document.getElementById('refresh-btn').addEventListener('click', () => {
      rawData = null;
      loadData();
    });

    // Search
    document.getElementById('search').addEventListener('input', (e) => {
      searchTerm = e.target.value.toLowerCase().trim();
      if (sectionGraph) sectionGraph.refresh();
    });

    // Reset view
    document.getElementById('reset-view-btn').addEventListener('click', () => {
      searchTerm = '';
      document.getElementById('search').value = '';
      selectedNode = null;
      hideDetail();
      if (sectionGraph) {
        sectionGraph.centerAt(0, 0, 400);
        sectionGraph.zoom(1, 400);
        sectionGraph.refresh();
      }
    });

    // Settings toggle
    document.getElementById('settings-btn').addEventListener('click', () => {
      const panel = document.getElementById('settings-panel');
      const btn   = document.getElementById('settings-btn');
      panel.classList.toggle('open');
      btn.classList.toggle('active');
    });

    // Settings reset
    document.getElementById('settings-reset').addEventListener('click', resetSettings);

    // Detail close
    document.getElementById('detail-close').addEventListener('click', () => {
      hideDetail();
      if (sectionGraph) sectionGraph.refresh();
    });

    // =====================================================================
    // INIT
    // =====================================================================
    initSettings();
    loadData();
  </script>
</body>
</html>
