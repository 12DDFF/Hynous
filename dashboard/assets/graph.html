<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hynous Memory Graph</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0a0a0a;
      color: #fafafa;
      font-family: Inter, system-ui, sans-serif;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
    }

    #graph { width: 100%; height: 100%; }

    /* Controls overlay */
    .controls {
      position: fixed;
      top: 16px;
      left: 16px;
      display: flex;
      gap: 8px;
      align-items: center;
      z-index: 10;
    }

    .controls input {
      background: #141414;
      border: 1px solid #262626;
      color: #fafafa;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 0.85rem;
      font-family: Inter, system-ui, sans-serif;
      outline: none;
      width: 220px;
      transition: border-color 0.15s;
    }

    .controls input:focus {
      border-color: #6366f1;
    }

    .controls input::placeholder {
      color: #525252;
    }

    .btn {
      background: #141414;
      border: 1px solid #262626;
      color: #a3a3a3;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 0.8rem;
      font-family: Inter, system-ui, sans-serif;
      cursor: pointer;
      transition: all 0.15s;
      white-space: nowrap;
    }

    .btn:hover {
      background: #1a1a1a;
      color: #fafafa;
      border-color: #404040;
    }

    .btn.active {
      background: #1e1b4b;
      border-color: #6366f1;
      color: #a5b4fc;
    }

    .btn svg {
      display: block;
    }

    /* Settings panel */
    .settings-panel {
      position: fixed;
      top: 56px;
      left: 16px;
      background: #111111;
      border: 1px solid #1e1e1e;
      border-radius: 10px;
      padding: 0;
      z-index: 10;
      width: 240px;
      display: none;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    }

    .settings-panel.open {
      display: block;
    }

    .settings-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 14px 8px;
      border-bottom: 1px solid #1a1a1a;
    }

    .settings-header span {
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: #525252;
    }

    .settings-reset {
      font-size: 0.65rem;
      color: #525252;
      cursor: pointer;
      background: none;
      border: none;
      font-family: Inter, system-ui, sans-serif;
      transition: color 0.15s;
      padding: 2px 6px;
      border-radius: 4px;
    }

    .settings-reset:hover {
      color: #a5b4fc;
      background: #1a1a2e;
    }

    .settings-body {
      padding: 6px 0;
    }

    .setting-row {
      padding: 6px 14px;
    }

    .setting-label-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 4px;
    }

    .setting-label {
      font-size: 0.75rem;
      color: #8a8a8a;
      font-weight: 400;
    }

    .setting-value {
      font-size: 0.7rem;
      color: #525252;
      font-family: 'SF Mono', 'Fira Code', monospace;
      min-width: 32px;
      text-align: right;
    }

    /* Range slider — custom styled */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 3px;
      background: #262626;
      border-radius: 2px;
      outline: none;
      cursor: pointer;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #a5b4fc;
      border: none;
      cursor: pointer;
      transition: transform 0.1s, box-shadow 0.15s;
      box-shadow: 0 0 0 0 rgba(165,180,252,0);
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.15);
      box-shadow: 0 0 0 4px rgba(165,180,252,0.15);
    }

    input[type="range"]:active::-webkit-slider-thumb {
      transform: scale(1.05);
      box-shadow: 0 0 0 6px rgba(165,180,252,0.1);
    }

    input[type="range"]::-moz-range-thumb {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #a5b4fc;
      border: none;
      cursor: pointer;
    }

    input[type="range"]::-moz-range-track {
      height: 3px;
      background: #262626;
      border-radius: 2px;
    }

    .setting-divider {
      height: 1px;
      background: #1a1a1a;
      margin: 4px 14px;
    }

    /* Stats */
    .stats {
      position: fixed;
      top: 16px;
      right: 16px;
      background: #141414;
      border: 1px solid #262626;
      border-radius: 8px;
      padding: 8px 14px;
      font-size: 0.8rem;
      color: #737373;
      z-index: 10;
    }

    .stats span { color: #a5b4fc; }

    /* Legend */
    .legend {
      position: fixed;
      bottom: 16px;
      left: 16px;
      background: #141414;
      border: 1px solid #262626;
      border-radius: 8px;
      padding: 12px 16px;
      z-index: 10;
      max-height: 280px;
      overflow-y: auto;
    }

    .legend-title {
      font-size: 0.75rem;
      color: #525252;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 8px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 2px 0;
      font-size: 0.8rem;
      color: #a3a3a3;
    }

    .legend-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    /* Detail panel */
    .detail-panel {
      position: fixed;
      bottom: 16px;
      right: 16px;
      background: #141414;
      border: 1px solid #262626;
      border-radius: 8px;
      padding: 16px;
      z-index: 10;
      width: 300px;
      max-height: 300px;
      overflow-y: auto;
      display: none;
    }

    .detail-panel .close-btn {
      position: absolute;
      top: 8px;
      right: 10px;
      background: none;
      border: none;
      color: #525252;
      cursor: pointer;
      font-size: 1rem;
    }

    .detail-panel .close-btn:hover { color: #fafafa; }

    .detail-title {
      font-weight: 600;
      font-size: 0.95rem;
      color: #fafafa;
      margin-bottom: 8px;
      padding-right: 20px;
    }

    .detail-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      padding: 3px 0;
    }

    .detail-row .label { color: #525252; }
    .detail-row .value { color: #a3a3a3; }

    .detail-summary {
      font-size: 0.8rem;
      color: #737373;
      margin-top: 8px;
      line-height: 1.4;
      border-top: 1px solid #262626;
      padding-top: 8px;
    }

    /* Loading */
    .loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #525252;
      font-size: 0.9rem;
      z-index: 30;
    }

    .error {
      color: #ef4444;
    }
  </style>
</head>
<body>
  <div id="graph"></div>

  <div class="controls">
    <input type="text" id="search" placeholder="Search memories..." autocomplete="off" />
    <button class="btn" id="refresh-btn">Refresh</button>
    <button class="btn" id="reset-btn">Reset View</button>
    <button class="btn" id="settings-btn" title="Graph Settings">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="4" y1="21" x2="4" y2="14"></line><line x1="4" y1="10" x2="4" y2="3"></line>
        <line x1="12" y1="21" x2="12" y2="12"></line><line x1="12" y1="8" x2="12" y2="3"></line>
        <line x1="20" y1="21" x2="20" y2="16"></line><line x1="20" y1="12" x2="20" y2="3"></line>
        <line x1="1" y1="14" x2="7" y2="14"></line><line x1="9" y1="8" x2="15" y2="8"></line>
        <line x1="17" y1="16" x2="23" y2="16"></line>
      </svg>
    </button>
  </div>

  <!-- Settings Panel -->
  <div class="settings-panel" id="settings-panel">
    <div class="settings-header">
      <span>Display</span>
      <button class="settings-reset" id="settings-reset">Reset</button>
    </div>
    <div class="settings-body">
      <div class="setting-row">
        <div class="setting-label-row">
          <span class="setting-label">Node Size</span>
          <span class="setting-value" id="val-node-size">1.0</span>
        </div>
        <input type="range" id="setting-node-size" min="0.3" max="3" step="0.1" value="1.0" />
      </div>
      <div class="setting-row">
        <div class="setting-label-row">
          <span class="setting-label">Line Thickness</span>
          <span class="setting-value" id="val-line-thick">1.0</span>
        </div>
        <input type="range" id="setting-line-thick" min="0.2" max="4" step="0.1" value="1.0" />
      </div>

      <div class="setting-divider"></div>

      <div class="setting-row">
        <div class="setting-label-row">
          <span class="setting-label">Center Force</span>
          <span class="setting-value" id="val-center">0.04</span>
        </div>
        <input type="range" id="setting-center" min="0" max="0.2" step="0.005" value="0.04" />
      </div>
      <div class="setting-row">
        <div class="setting-label-row">
          <span class="setting-label">Repel Force</span>
          <span class="setting-value" id="val-repel">60</span>
        </div>
        <input type="range" id="setting-repel" min="0" max="300" step="5" value="60" />
      </div>
      <div class="setting-row">
        <div class="setting-label-row">
          <span class="setting-label">Link Force</span>
          <span class="setting-value" id="val-link-str">0.30</span>
        </div>
        <input type="range" id="setting-link-str" min="0" max="1" step="0.05" value="0.30" />
      </div>
      <div class="setting-row">
        <div class="setting-label-row">
          <span class="setting-label">Link Distance</span>
          <span class="setting-value" id="val-link-dist">80</span>
        </div>
        <input type="range" id="setting-link-dist" min="10" max="400" step="5" value="80" />
      </div>
    </div>
  </div>

  <div class="stats" id="stats"></div>

  <div class="legend" id="legend">
    <div class="legend-title">Memory Types</div>
  </div>


  <div class="detail-panel" id="detail">
    <button class="close-btn" id="detail-close">&times;</button>
    <div class="detail-title" id="detail-title"></div>
    <div id="detail-body"></div>
  </div>

  <div class="loading" id="loading">Loading graph...</div>

  <script src="https://unpkg.com/d3-force@3/dist/d3-force.min.js"></script>
  <script src="https://unpkg.com/force-graph@1.47.4/dist/force-graph.min.js"></script>
  <script>
    // ---- Configuration ----
    // Primary: proxy through the Reflex backend (same origin, no CORS/port issues).
    // Fallback: direct to Nous for local dev where proxy may not be running.
    const NOUS_URLS = [
      `${location.origin}/api/nous/graph`,
      'http://localhost:3100/v1/graph',
      'http://127.0.0.1:3100/v1/graph',
    ];

    const COLORS = {
      'custom:watchpoint':      '#b48a1a',
      'custom:curiosity':       '#9b59a8',
      'custom:lesson':          '#4a7fb5',
      'custom:thesis':          '#7c6aad',
      'custom:market_event':    '#b07040',
      'custom:trade_entry':     '#3a9e6a',
      'custom:trade_close':     '#a04848',
      'custom:trade_modify':    '#a08030',
      'custom:signal':          '#3a8f85',
      'custom:turn_summary':    '#5a5a6a',
      'custom:session_summary': '#6a6a78',
      'custom:preference':      '#a05580',
      'custom:trade':           '#2a8a7a',
    };

    const LABELS = {
      'custom:watchpoint':      'Watchpoint',
      'custom:curiosity':       'Curiosity',
      'custom:lesson':          'Lesson',
      'custom:thesis':          'Thesis',
      'custom:market_event':    'Market Event',
      'custom:trade_entry':     'Trade Entry',
      'custom:trade_close':     'Trade Close',
      'custom:trade_modify':    'Trade Modify',
      'custom:signal':          'Signal',
      'custom:turn_summary':    'Turn Summary',
      'custom:session_summary': 'Session Summary',
      'custom:preference':      'Preference',
      'custom:trade':           'Trade',
    };

    const DEFAULT_COLOR = '#5a6380';

    // ---- Settings defaults ----
    const DEFAULTS = {
      nodeSize:     1.0,
      lineThick:    1.0,
      centerForce:  0.04,
      repelForce:   60,
      linkStrength: 0.30,
      linkDistance:  80,
    };

    // Live settings — mutated by sliders
    const settings = { ...DEFAULTS };

    // ---- State ----
    let graph = null;
    let hoveredNode = null;
    let selectedNode = null;
    let searchTerm = '';
    let graphData = { nodes: [], links: [] };

    // ---- Precomputed lookup tables (rebuilt on data load) ----
    // adjMap: nodeId → Set of connected nodeIds — O(1) neighbor check
    let adjMap = new Map();
    // nodeById: nodeId → node object — O(1) node lookup
    let nodeById = new Map();

    function buildLookups() {
      adjMap = new Map();
      nodeById = new Map();
      for (const n of graphData.nodes) {
        nodeById.set(n.id, n);
        adjMap.set(n.id, new Set());
        n._conns = 0;
        // Pre-cache per-node properties (avoids Map lookups + Math per frame)
        n._color = COLORS[n.subtype] || DEFAULT_COLOR;
        n._opacity = Math.max(0.15, (n.retrievability ?? 1) * 0.85 + 0.15);
        n._titleLower = (n.title || '').toLowerCase();
        n._subtypeLower = (n.subtype || '').toLowerCase();
      }
      for (const l of graphData.links) {
        const sid = l.source.id ?? l.source;
        const tid = l.target.id ?? l.target;
        const sSet = adjMap.get(sid);
        const tSet = adjMap.get(tid);
        if (sSet) sSet.add(tid);
        if (tSet) tSet.add(sid);
        const sn = nodeById.get(sid);
        const tn = nodeById.get(tid);
        if (sn) sn._conns++;
        if (tn) tn._conns++;
      }
      // Pre-cache base radius now that _conns is final
      for (const n of graphData.nodes) {
        n._baseRadius = Math.min(6, 2.8 + Math.log2(n._conns + 1) * 1.1);
      }
    }

    // ---- Settings persistence (localStorage) ----
    const STORAGE_KEY = 'hynous-graph-settings';

    function saveSettings() {
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(settings)); } catch {}
    }

    function loadSettings() {
      try {
        const saved = JSON.parse(localStorage.getItem(STORAGE_KEY));
        if (saved) Object.assign(settings, saved);
      } catch {}
    }

    // ---- Legend ----
    function buildLegend(nodes) {
      const legendEl = document.getElementById('legend');
      // Clear existing items (keep title)
      const items = legendEl.querySelectorAll('.legend-item');
      items.forEach(i => i.remove());

      // Find which subtypes exist in the data
      const subtypes = new Set(nodes.map(n => n.subtype).filter(Boolean));

      for (const [subtype, label] of Object.entries(LABELS)) {
        if (!subtypes.has(subtype)) continue;
        const item = document.createElement('div');
        item.className = 'legend-item';
        item.innerHTML = `<div class="legend-dot" style="background:${COLORS[subtype] || DEFAULT_COLOR}"></div>${label}`;
        legendEl.appendChild(item);
      }
    }

    // ---- Helpers (use pre-cached values from buildLookups) ----
    function getRadius(node) {
      return (node._baseRadius || 2.8) * settings.nodeSize;
    }

    function isHighlighted(node) {
      if (!searchTerm) return true;
      return node._titleLower.includes(searchTerm) || node._subtypeLower.includes(searchTerm);
    }

    function formatDate(iso) {
      if (!iso) return '?';
      try {
        const d = new Date(iso);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
      } catch { return iso.slice(0, 10); }
    }

    function subtypeLabel(subtype) {
      if (!subtype) return 'unknown';
      return LABELS[subtype] || subtype.replace('custom:', '');
    }


    // ---- Detail panel ----
    function showDetail(node) {
      selectedNode = node;
      const panel = document.getElementById('detail');
      const title = document.getElementById('detail-title');
      const body = document.getElementById('detail-body');

      title.textContent = node.title || 'Untitled';
      title.style.color = node._color || DEFAULT_COLOR;

      const retr = node.retrievability != null ? (node.retrievability * 100).toFixed(0) + '%' : '?';

      let html = '';
      html += `<div class="detail-row"><span class="label">Type</span><span class="value">${subtypeLabel(node.subtype)}</span></div>`;
      html += `<div class="detail-row"><span class="label">Lifecycle</span><span class="value">${node.lifecycle || '?'}</span></div>`;
      html += `<div class="detail-row"><span class="label">Retrievability</span><span class="value">${retr}</span></div>`;
      html += `<div class="detail-row"><span class="label">Access Count</span><span class="value">${node.access_count || 0}</span></div>`;
      html += `<div class="detail-row"><span class="label">Created</span><span class="value">${formatDate(node.created_at)}</span></div>`;
      html += `<div class="detail-row"><span class="label">ID</span><span class="value" style="font-family:monospace;font-size:0.7rem">${node.id}</span></div>`;

      // Count connections (pre-computed)
      const connCount = node._conns || 0;
      html += `<div class="detail-row"><span class="label">Connections</span><span class="value">${connCount}</span></div>`;

      if (node.summary) {
        html += `<div class="detail-summary">${node.summary}</div>`;
      }

      body.innerHTML = html;
      panel.style.display = 'block';
    }

    function hideDetail() {
      selectedNode = null;
      document.getElementById('detail').style.display = 'none';
    }

    // ---- Apply settings to graph forces ----
    function applyForces() {
      if (!graph) return;

      graph.d3Force('charge').strength(-settings.repelForce);
      graph.d3Force('link').distance(settings.linkDistance);

      // Link strength — d3 default is adaptive (1/min(degree)), override with fixed value
      if (settings.linkStrength > 0) {
        graph.d3Force('link').strength(settings.linkStrength);
      }

      graph.d3Force('gravity-x').strength(settings.centerForce);
      graph.d3Force('gravity-y').strength(settings.centerForce);

      graph.d3ReheatSimulation();
    }

    // ---- Graph rendering ----
    function renderGraph(data) {
      const el = document.getElementById('graph');
      const loadingEl = document.getElementById('loading');
      loadingEl.style.display = 'none';

      // Clean edges that reference missing nodes
      const nodeIds = new Set(data.nodes.map(n => n.id));
      const validEdges = data.edges.filter(e => nodeIds.has(e.source) && nodeIds.has(e.target));

      graphData = { nodes: data.nodes, links: validEdges };

      // Build O(1) lookup tables — eliminates per-frame O(N*M) scans
      buildLookups();

      // Stats
      document.getElementById('stats').innerHTML =
        `<span>${data.nodes.length}</span> memories &middot; <span>${validEdges.length}</span> connections`;

      // Legend
      buildLegend(data.nodes);

      if (graph) {
        graph.graphData(graphData);
        return;
      }

      graph = ForceGraph()(el)
        .graphData(graphData)
        .backgroundColor('#0a0a0a')
        .width(el.clientWidth)
        .height(el.clientHeight)
        .warmupTicks(80)         // Pre-compute layout before first paint
        .cooldownTime(4000)      // Stop physics sooner (default 15s)
        .d3AlphaDecay(0.03)      // Faster simulation settling

        // Node rendering — uses pre-cached _color, _opacity, _baseRadius
        .nodeCanvasObject((node, ctx, globalScale) => {
          const r = getRadius(node);
          const color = node._color;
          const isSelected = selectedNode && selectedNode.id === node.id;
          const isHovered = hoveredNode && hoveredNode.id === node.id;
          const isConnected = selectedNode && adjMap.get(selectedNode.id)?.has(node.id);

          let alpha = node._opacity;
          if (searchTerm && !isHighlighted(node)) alpha = 0.06;
          if (selectedNode && !isSelected && !isConnected) alpha = 0.12;

          // Soft glow (only 1-2 nodes per frame)
          if (isHovered || isSelected) {
            const glowR = r + 6 * settings.nodeSize;
            const grad = ctx.createRadialGradient(node.x, node.y, r * 0.3, node.x, node.y, glowR);
            grad.addColorStop(0, color + 'cc');
            grad.addColorStop(0.35, color + '66');
            grad.addColorStop(0.7, color + '22');
            grad.addColorStop(1, color + '00');
            ctx.beginPath();
            ctx.arc(node.x, node.y, glowR, 0, 2 * Math.PI);
            ctx.fillStyle = grad;
            ctx.globalAlpha = isSelected ? 0.95 : 0.85;
            ctx.fill();
          }

          // Core node
          ctx.beginPath();
          ctx.arc(node.x, node.y, r, 0, 2 * Math.PI);
          ctx.fillStyle = color;
          ctx.globalAlpha = alpha;
          ctx.fill();

          ctx.globalAlpha = 1;
        })
        .nodePointerAreaPaint((node, color, ctx) => {
          const r = getRadius(node) + 4;
          ctx.beginPath();
          ctx.arc(node.x, node.y, r, 0, 2 * Math.PI);
          ctx.fillStyle = color;
          ctx.fill();
        })

        // Edge rendering — batched: draw ALL links in one pass on first link call
        // Reduces 3000 individual beginPath→stroke calls to 2-3 batched paths
        .linkCanvasObject((link, ctx) => {
          // Only draw on first link — batch all links at once
          if (link !== graphData.links[0]) return;

          const selId = selectedNode?.id;
          const selNeighbors = selId ? adjMap.get(selId) : null;
          const lineThick = settings.lineThick;
          ctx.strokeStyle = '#9090a0';

          if (!selId && !searchTerm) {
            // Fast path: no selection, no search — one batch at alpha 0.3
            ctx.globalAlpha = 0.3;
            ctx.lineWidth = 0.35 * lineThick;
            ctx.beginPath();
            for (const l of graphData.links) {
              ctx.moveTo(l.source.x, l.source.y);
              ctx.lineTo(l.target.x, l.target.y);
            }
            ctx.stroke();
          } else if (selId) {
            // Selection: 2 batches — connected (bright) + rest (dim)
            ctx.lineWidth = 0.4 * lineThick;
            // Connected links
            ctx.globalAlpha = 0.45;
            ctx.beginPath();
            for (const l of graphData.links) {
              const sid = l.source.id;
              const tid = l.target.id;
              if (sid === selId || tid === selId) {
                ctx.moveTo(l.source.x, l.source.y);
                ctx.lineTo(l.target.x, l.target.y);
              }
            }
            ctx.stroke();
            // Unconnected links
            ctx.globalAlpha = 0.04;
            ctx.beginPath();
            for (const l of graphData.links) {
              const sid = l.source.id;
              const tid = l.target.id;
              if (sid !== selId && tid !== selId) {
                ctx.moveTo(l.source.x, l.source.y);
                ctx.lineTo(l.target.x, l.target.y);
              }
            }
            ctx.stroke();
          } else {
            // Search: 2 batches — matching (visible) + rest (dim)
            ctx.lineWidth = 0.35 * lineThick;
            ctx.globalAlpha = 0.25;
            ctx.beginPath();
            let hasMatch = false;
            for (const l of graphData.links) {
              const src = nodeById.get(l.source.id);
              const tgt = nodeById.get(l.target.id);
              if (src && tgt && isHighlighted(src) && isHighlighted(tgt)) {
                ctx.moveTo(l.source.x, l.source.y);
                ctx.lineTo(l.target.x, l.target.y);
                hasMatch = true;
              }
            }
            if (hasMatch) ctx.stroke();
            ctx.globalAlpha = 0.02;
            ctx.beginPath();
            for (const l of graphData.links) {
              const src = nodeById.get(l.source.id);
              const tgt = nodeById.get(l.target.id);
              if (!src || !tgt || !isHighlighted(src) || !isHighlighted(tgt)) {
                ctx.moveTo(l.source.x, l.source.y);
                ctx.lineTo(l.target.x, l.target.y);
              }
            }
            ctx.stroke();
          }
          ctx.globalAlpha = 1;
        })

        // Interactions
        .onNodeHover((node) => {
          hoveredNode = node;
          el.style.cursor = node ? 'pointer' : 'default';
        })
        .autoPauseRedraw(false)
        .onNodeClick((node) => {
          if (selectedNode && selectedNode.id === node.id) {
            selectedNode = null;
            hideDetail();
            return;
          }
          showDetail(node);
          graph.centerAt(node.x, node.y, 400);
          graph.zoom(3, 400);
        })
        .onBackgroundClick(() => {
          selectedNode = null;
          hideDetail();
        })

        // Physics
        ;

      // Set up forces with saved/default settings
      graph.d3Force('charge').strength(-settings.repelForce);
      graph.d3Force('link').distance(settings.linkDistance);
      if (settings.linkStrength > 0) {
        graph.d3Force('link').strength(settings.linkStrength);
      }

      graph.d3Force('gravity-x', d3.forceX(0).strength(settings.centerForce));
      graph.d3Force('gravity-y', d3.forceY(0).strength(settings.centerForce));

      // Handle window resize
      window.addEventListener('resize', () => {
        graph.width(el.clientWidth).height(el.clientHeight);
      });
    }

    // ---- Data loading ----
    let activeUrl = null;
    let graphRendered = false;

    async function tryFetch() {
      // If we already found a working URL, try it first
      if (activeUrl) {
        try {
          const resp = await fetch(activeUrl);
          if (resp.ok) return await resp.json();
        } catch {}
        activeUrl = null;
      }

      // Try each URL
      for (const url of NOUS_URLS) {
        try {
          const resp = await fetch(url, { signal: AbortSignal.timeout(3000) });
          if (!resp.ok) continue;
          const data = await resp.json();
          activeUrl = url;
          return data;
        } catch {
          continue;
        }
      }
      return null;
    }

    async function loadGraph() {
      const loadingEl = document.getElementById('loading');
      loadingEl.style.display = 'block';
      loadingEl.className = 'loading';
      loadingEl.textContent = 'Loading graph...';

      // Retry up to 5 times with increasing delay (server may still be starting)
      for (let attempt = 0; attempt < 5; attempt++) {
        const data = await tryFetch();
        if (data) {
          graphRendered = true;
          renderGraph(data);
          return;
        }
        // Wait before retrying (1s, 2s, 3s, 4s)
        if (attempt < 4) {
          loadingEl.textContent = `Waiting for Nous server... (attempt ${attempt + 2})`;
          await new Promise(r => setTimeout(r, (attempt + 1) * 1000));
        }
      }

      // Only show error if graph never rendered
      if (!graphRendered) {
        loadingEl.className = 'loading error';
        loadingEl.textContent = 'Could not connect to Nous server (port 3100). Make sure it is running.';
      } else {
        loadingEl.style.display = 'none';
      }
    }

    // ---- Settings panel logic ----
    const sliderMap = [
      { id: 'setting-node-size',  valId: 'val-node-size',  key: 'nodeSize',     fmt: v => v.toFixed(1),  visual: true },
      { id: 'setting-line-thick', valId: 'val-line-thick', key: 'lineThick',    fmt: v => v.toFixed(1),  visual: true },
      { id: 'setting-center',    valId: 'val-center',     key: 'centerForce',  fmt: v => v.toFixed(2),  visual: false },
      { id: 'setting-repel',     valId: 'val-repel',      key: 'repelForce',   fmt: v => String(Math.round(v)), visual: false },
      { id: 'setting-link-str',  valId: 'val-link-str',   key: 'linkStrength', fmt: v => v.toFixed(2),  visual: false },
      { id: 'setting-link-dist', valId: 'val-link-dist',  key: 'linkDistance', fmt: v => String(Math.round(v)), visual: false },
    ];

    function initSettings() {
      loadSettings();

      for (const s of sliderMap) {
        const slider = document.getElementById(s.id);
        const valEl = document.getElementById(s.valId);

        // Set slider to current (saved or default) value
        slider.value = settings[s.key];
        valEl.textContent = s.fmt(settings[s.key]);

        slider.addEventListener('input', () => {
          const v = parseFloat(slider.value);
          settings[s.key] = v;
          valEl.textContent = s.fmt(v);
          saveSettings();

          if (s.visual) {
            // Node size / line thickness — just refresh canvas, no physics change
            if (graph) graph.refresh();
          } else {
            // Physics force — reheat simulation
            applyForces();
          }
        });
      }
    }

    function resetSettings() {
      Object.assign(settings, DEFAULTS);
      saveSettings();

      for (const s of sliderMap) {
        const slider = document.getElementById(s.id);
        const valEl = document.getElementById(s.valId);
        slider.value = settings[s.key];
        valEl.textContent = s.fmt(settings[s.key]);
      }

      applyForces();
      if (graph) graph.refresh();
    }

    // ---- Event handlers ----
    document.getElementById('search').addEventListener('input', (e) => {
      searchTerm = e.target.value.toLowerCase().trim();
      if (graph) graph.refresh();
    });

    document.getElementById('refresh-btn').addEventListener('click', () => {
      loadGraph();
    });

    document.getElementById('reset-btn').addEventListener('click', () => {
      searchTerm = '';
      document.getElementById('search').value = '';
      selectedNode = null;
      hideDetail();
      if (graph) {
        graph.centerAt(0, 0, 400);
        graph.zoom(1, 400);
        graph.refresh();
      }
    });

    document.getElementById('detail-close').addEventListener('click', () => {
      hideDetail();
      if (graph) graph.refresh();
    });

    // Settings toggle
    document.getElementById('settings-btn').addEventListener('click', () => {
      const panel = document.getElementById('settings-panel');
      const btn = document.getElementById('settings-btn');
      const isOpen = panel.classList.contains('open');
      panel.classList.toggle('open');
      btn.classList.toggle('active');
    });

    // Settings reset
    document.getElementById('settings-reset').addEventListener('click', resetSettings);

    // ---- Init ----
    initSettings();
    loadGraph();
  </script>
</body>
</html>
