<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hynous Memory Graph</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0a0a0a;
      color: #fafafa;
      font-family: Inter, system-ui, sans-serif;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
    }

    #graph { width: 100%; height: 100%; }

    /* Controls overlay */
    .controls {
      position: fixed;
      top: 16px;
      left: 16px;
      display: flex;
      gap: 8px;
      align-items: center;
      z-index: 10;
    }

    .controls input {
      background: #141414;
      border: 1px solid #262626;
      color: #fafafa;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 0.85rem;
      font-family: Inter, system-ui, sans-serif;
      outline: none;
      width: 220px;
      transition: border-color 0.15s;
    }

    .controls input:focus {
      border-color: #6366f1;
    }

    .controls input::placeholder {
      color: #525252;
    }

    .btn {
      background: #141414;
      border: 1px solid #262626;
      color: #a3a3a3;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 0.8rem;
      font-family: Inter, system-ui, sans-serif;
      cursor: pointer;
      transition: all 0.15s;
      white-space: nowrap;
    }

    .btn:hover {
      background: #1a1a1a;
      color: #fafafa;
      border-color: #404040;
    }

    .btn.active {
      background: #1e1b4b;
      border-color: #6366f1;
      color: #a5b4fc;
    }

    /* Stats */
    .stats {
      position: fixed;
      top: 16px;
      right: 16px;
      background: #141414;
      border: 1px solid #262626;
      border-radius: 8px;
      padding: 8px 14px;
      font-size: 0.8rem;
      color: #737373;
      z-index: 10;
    }

    .stats span { color: #a5b4fc; }

    /* Legend */
    .legend {
      position: fixed;
      bottom: 16px;
      left: 16px;
      background: #141414;
      border: 1px solid #262626;
      border-radius: 8px;
      padding: 12px 16px;
      z-index: 10;
      max-height: 280px;
      overflow-y: auto;
    }

    .legend-title {
      font-size: 0.75rem;
      color: #525252;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 8px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 2px 0;
      font-size: 0.8rem;
      color: #a3a3a3;
    }

    .legend-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    /* Detail panel */
    .detail-panel {
      position: fixed;
      bottom: 16px;
      right: 16px;
      background: #141414;
      border: 1px solid #262626;
      border-radius: 8px;
      padding: 16px;
      z-index: 10;
      width: 300px;
      max-height: 300px;
      overflow-y: auto;
      display: none;
    }

    .detail-panel .close-btn {
      position: absolute;
      top: 8px;
      right: 10px;
      background: none;
      border: none;
      color: #525252;
      cursor: pointer;
      font-size: 1rem;
    }

    .detail-panel .close-btn:hover { color: #fafafa; }

    .detail-title {
      font-weight: 600;
      font-size: 0.95rem;
      color: #fafafa;
      margin-bottom: 8px;
      padding-right: 20px;
    }

    .detail-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      padding: 3px 0;
    }

    .detail-row .label { color: #525252; }
    .detail-row .value { color: #a3a3a3; }

    .detail-summary {
      font-size: 0.8rem;
      color: #737373;
      margin-top: 8px;
      line-height: 1.4;
      border-top: 1px solid #262626;
      padding-top: 8px;
    }

    /* Loading */
    .loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #525252;
      font-size: 0.9rem;
      z-index: 30;
    }

    .error {
      color: #ef4444;
    }
  </style>
</head>
<body>
  <div id="graph"></div>

  <div class="controls">
    <input type="text" id="search" placeholder="Search memories..." autocomplete="off" />
    <button class="btn" id="refresh-btn">Refresh</button>
    <button class="btn" id="reset-btn">Reset View</button>
    <button class="btn" id="cluster-btn" title="Toggle cluster visualization">Clusters</button>
  </div>

  <div class="stats" id="stats"></div>

  <div class="legend" id="legend">
    <div class="legend-title">Memory Types</div>
  </div>


  <div class="detail-panel" id="detail">
    <button class="close-btn" id="detail-close">&times;</button>
    <div class="detail-title" id="detail-title"></div>
    <div id="detail-body"></div>
  </div>

  <div class="loading" id="loading">Loading graph...</div>

  <script src="https://unpkg.com/d3-force@3/dist/d3-force.min.js"></script>
  <script src="https://unpkg.com/force-graph@1.47.4/dist/force-graph.min.js"></script>
  <script>
    // ---- Configuration ----
    // Graph data is fetched through the Reflex backend proxy (/api/nous/*).
    // Backend URL is discovered from Reflex's env.json so it works in any
    // environment (local dev, VPS, etc.) without hardcoded ports.
    let NOUS_URLS = [];
    async function _initUrls() {
      try {
        const env = await fetch('/env.json').then(r => r.json());
        // env.PING = "http://host:8000/ping" — extract base URL
        const base = env.PING.replace('/ping', '');
        NOUS_URLS = [`${base}/api/nous/graph`];
      } catch {
        // Fallback: same host, port 8000
        NOUS_URLS = [`${window.location.protocol}//${window.location.hostname}:8000/api/nous/graph`];
      }
    }

    const COLORS = {
      'custom:watchpoint':      '#b48a1a',
      'custom:curiosity':       '#9b59a8',
      'custom:lesson':          '#4a7fb5',
      'custom:thesis':          '#7c6aad',
      'custom:market_event':    '#b07040',
      'custom:trade_entry':     '#3a9e6a',
      'custom:trade_close':     '#a04848',
      'custom:trade_modify':    '#a08030',
      'custom:signal':          '#3a8f85',
      'custom:turn_summary':    '#5a5a6a',
      'custom:session_summary': '#6a6a78',
      'custom:preference':      '#a05580',
      'custom:trade':           '#2a8a7a',
    };

    const LABELS = {
      'custom:watchpoint':      'Watchpoint',
      'custom:curiosity':       'Curiosity',
      'custom:lesson':          'Lesson',
      'custom:thesis':          'Thesis',
      'custom:market_event':    'Market Event',
      'custom:trade_entry':     'Trade Entry',
      'custom:trade_close':     'Trade Close',
      'custom:trade_modify':    'Trade Modify',
      'custom:signal':          'Signal',
      'custom:turn_summary':    'Turn Summary',
      'custom:session_summary': 'Session Summary',
      'custom:preference':      'Preference',
      'custom:trade':           'Trade',
    };

    const DEFAULT_COLOR = '#5a6380';

    // ---- Cluster palette (semi-transparent for Venn overlap) ----
    const CLUSTER_PALETTE = [
      { fill: 'rgba(247, 147, 26, 0.06)',  stroke: 'rgba(247, 147, 26, 0.25)' },
      { fill: 'rgba(98, 126, 234, 0.06)',  stroke: 'rgba(98, 126, 234, 0.25)' },
      { fill: 'rgba(153, 69, 255, 0.06)',  stroke: 'rgba(153, 69, 255, 0.25)' },
      { fill: 'rgba(96, 165, 250, 0.06)',  stroke: 'rgba(96, 165, 250, 0.25)' },
      { fill: 'rgba(163, 230, 53, 0.06)',  stroke: 'rgba(163, 230, 53, 0.25)' },
      { fill: 'rgba(245, 158, 11, 0.06)',  stroke: 'rgba(245, 158, 11, 0.25)' },
      { fill: 'rgba(236, 72, 153, 0.06)',  stroke: 'rgba(236, 72, 153, 0.25)' },
      { fill: 'rgba(34, 211, 238, 0.06)',  stroke: 'rgba(34, 211, 238, 0.25)' },
      { fill: 'rgba(248, 113, 113, 0.06)', stroke: 'rgba(248, 113, 113, 0.25)' },
      { fill: 'rgba(74, 222, 128, 0.06)',  stroke: 'rgba(74, 222, 128, 0.25)' },
      { fill: 'rgba(251, 191, 36, 0.06)',  stroke: 'rgba(251, 191, 36, 0.25)' },
      { fill: 'rgba(167, 139, 250, 0.06)', stroke: 'rgba(167, 139, 250, 0.25)' },
    ];

    // Fixed color slots for known cluster names (matches dashboard accent_map)
    const CLUSTER_NAME_COLOR_INDEX = {
      'BTC': 0, 'ETH': 1, 'SOL': 2, 'Thesis': 3, 'Theses': 3,
      'Lessons': 4, 'Trade History': 5,
    };

    // ---- State ----
    let graph = null;
    let hoveredNode = null;
    let selectedNode = null;
    let searchTerm = '';
    let graphData = { nodes: [], links: [] };

    // Cluster state
    let clustersEnabled = false;
    let clusterData = [];
    let clusterMemberships = [];
    let clusterNodeMap = {};   // node_id -> [cluster_id, ...]
    let clusterColorMap = {};  // cluster_id -> { fill, stroke }
    let nodeById = {};

    // ---- Cluster color assignment ----
    function assignClusterColors(clusters) {
      const used = new Set();
      clusterColorMap = {};
      for (const c of clusters) {
        if (c.name in CLUSTER_NAME_COLOR_INDEX) {
          const idx = CLUSTER_NAME_COLOR_INDEX[c.name];
          clusterColorMap[c.id] = CLUSTER_PALETTE[idx];
          used.add(idx);
        }
      }
      let nextIdx = 0;
      for (const c of clusters) {
        if (clusterColorMap[c.id]) continue;
        while (used.has(nextIdx)) nextIdx++;
        clusterColorMap[c.id] = CLUSTER_PALETTE[nextIdx % CLUSTER_PALETTE.length];
        used.add(nextIdx);
        nextIdx++;
      }
    }

    // ---- Convex hull geometry ----
    function _cross(o, a, b) {
      return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
    }

    function convexHull(points) {
      if (points.length <= 1) return points.slice();
      if (points.length === 2) return points.slice();
      const sorted = points.slice().sort((a, b) => a.x - b.x || a.y - b.y);
      const lower = [];
      for (const p of sorted) {
        while (lower.length >= 2 && _cross(lower[lower.length-2], lower[lower.length-1], p) <= 0)
          lower.pop();
        lower.push(p);
      }
      const upper = [];
      for (let i = sorted.length - 1; i >= 0; i--) {
        const p = sorted[i];
        while (upper.length >= 2 && _cross(upper[upper.length-2], upper[upper.length-1], p) <= 0)
          upper.pop();
        upper.push(p);
      }
      lower.pop();
      upper.pop();
      return lower.concat(upper);
    }

    function expandHull(hull, pad) {
      if (hull.length < 3) return hull;
      const cx = hull.reduce((s, p) => s + p.x, 0) / hull.length;
      const cy = hull.reduce((s, p) => s + p.y, 0) / hull.length;
      return hull.map(p => {
        const dx = p.x - cx, dy = p.y - cy;
        const d = Math.sqrt(dx*dx + dy*dy) || 1;
        return { x: p.x + (dx/d) * pad, y: p.y + (dy/d) * pad };
      });
    }

    function drawSmoothHull(ctx, hull) {
      if (hull.length < 3) return;
      ctx.beginPath();
      const n = hull.length;
      const mx0 = (hull[0].x + hull[n-1].x) / 2;
      const my0 = (hull[0].y + hull[n-1].y) / 2;
      ctx.moveTo(mx0, my0);
      for (let i = 0; i < n; i++) {
        const next = (i + 1) % n;
        const mx = (hull[i].x + hull[next].x) / 2;
        const my = (hull[i].y + hull[next].y) / 2;
        ctx.quadraticCurveTo(hull[i].x, hull[i].y, mx, my);
      }
      ctx.closePath();
    }

    function drawCapsule(ctx, p1, p2, pad) {
      const dx = p2.x - p1.x, dy = p2.y - p1.y;
      const len = Math.sqrt(dx*dx + dy*dy) || 1;
      const angle = Math.atan2(dy, dx);
      ctx.beginPath();
      ctx.arc(p1.x, p1.y, pad, angle + Math.PI/2, angle - Math.PI/2, false);
      ctx.arc(p2.x, p2.y, pad, angle - Math.PI/2, angle + Math.PI/2, false);
      ctx.closePath();
    }

    // ---- Cluster force ----
    // Each cluster is assigned a fixed target position on a circle so
    // clusters spread apart instead of all collapsing to center.
    let clusterTargets = {}; // cluster_id -> {x, y}

    function computeClusterTargets() {
      clusterTargets = {};
      // Only position clusters that actually have graphed members
      const activeClusters = clusterData.filter(c =>
        clusterMemberships.some(m => m.cluster_id === c.id)
      );
      if (activeClusters.length === 0) return;

      const radius = 350;
      const angleStep = (2 * Math.PI) / activeClusters.length;
      activeClusters.forEach((c, i) => {
        const angle = angleStep * i - Math.PI / 2; // start from top
        clusterTargets[c.id] = {
          x: Math.cos(angle) * radius,
          y: Math.sin(angle) * radius,
        };
      });
    }

    function applyClusterForces() {
      if (!graph) return;
      if (clustersEnabled && clusterData.length > 0) {
        computeClusterTargets();

        // Weaken gravity so clusters can spread out from center
        graph.d3Force('gravity-x').strength(0.005);
        graph.d3Force('gravity-y').strength(0.005);

        graph.d3Force('cluster', (alpha) => {
          const strength = 0.04;

          for (const node of graphData.nodes) {
            const clusters = clusterNodeMap[node.id];
            if (!clusters || clusters.length === 0) continue;

            // Target = average of this node's cluster targets
            // Multi-cluster nodes drift to the midpoint (Venn intersection)
            let tx = 0, ty = 0, count = 0;
            for (const cid of clusters) {
              const t = clusterTargets[cid];
              if (t) { tx += t.x; ty += t.y; count++; }
            }
            if (count === 0) continue;
            tx /= count;
            ty /= count;

            const s = strength * alpha;
            node.vx += (tx - node.x) * s;
            node.vy += (ty - node.y) * s;
          }
        });

        graph.d3ReheatSimulation();
      } else {
        // Restore normal gravity
        graph.d3Force('gravity-x').strength(0.04);
        graph.d3Force('gravity-y').strength(0.04);
        graph.d3Force('cluster', null);
        graph.d3ReheatSimulation();
      }
    }

    // ---- Cluster legend ----
    function buildClusterLegend() {
      const legendEl = document.getElementById('legend');
      legendEl.querySelectorAll('.cluster-legend-item, .cluster-divider').forEach(e => e.remove());
      if (!clustersEnabled || clusterData.length === 0) return;

      const divider = document.createElement('div');
      divider.className = 'cluster-divider';
      divider.style.cssText = 'border-top:1px solid #262626; margin:8px 0; padding-top:8px;';
      legendEl.appendChild(divider);

      const title = document.createElement('div');
      title.className = 'legend-title cluster-legend-item';
      title.textContent = 'Clusters';
      title.style.marginBottom = '6px';
      legendEl.appendChild(title);

      for (const cluster of clusterData) {
        const colors = clusterColorMap[cluster.id];
        if (!colors) continue;
        const memberCount = clusterMemberships.filter(m => m.cluster_id === cluster.id).length;
        if (memberCount === 0) continue;
        const item = document.createElement('div');
        item.className = 'legend-item cluster-legend-item';
        const dotColor = colors.stroke.replace(/[\d.]+\)$/, '0.7)');
        item.innerHTML = `<div class="legend-dot" style="background:${dotColor};border:1px solid ${colors.stroke}"></div>${cluster.name} (${memberCount})`;
        legendEl.appendChild(item);
      }
    }

    // ---- Legend ----
    function buildLegend(nodes) {
      const legendEl = document.getElementById('legend');
      // Clear existing type items (keep title and cluster items)
      const items = legendEl.querySelectorAll('.legend-item:not(.cluster-legend-item)');
      items.forEach(i => i.remove());

      // Find which subtypes exist in the data
      const subtypes = new Set(nodes.map(n => n.subtype).filter(Boolean));

      // Insert type items before the cluster divider (if present)
      const clusterDivider = legendEl.querySelector('.cluster-divider');

      for (const [subtype, label] of Object.entries(LABELS)) {
        if (!subtypes.has(subtype)) continue;
        const item = document.createElement('div');
        item.className = 'legend-item';
        item.innerHTML = `<div class="legend-dot" style="background:${COLORS[subtype] || DEFAULT_COLOR}"></div>${label}`;
        if (clusterDivider) {
          legendEl.insertBefore(item, clusterDivider);
        } else {
          legendEl.appendChild(item);
        }
      }
    }

    // ---- Helpers ----
    function getColor(node) {
      return COLORS[node.subtype] || DEFAULT_COLOR;
    }

    function getRadius(node) {
      // Size varies by connection count — subtle but visible
      if (node._conns === undefined) {
        node._conns = graphData.links.filter(l =>
          (l.source.id || l.source) === node.id || (l.target.id || l.target) === node.id
        ).length;
      }
      const c = node._conns;
      // 0 conns: 2.8px, 1-2: ~3.5px, 5: ~4.5px, 10+: ~5.5px, cap 6px
      return Math.min(6, 2.8 + Math.log2(c + 1) * 1.1);
    }

    function getOpacity(node) {
      const r = node.retrievability ?? 1;
      // Map retrievability to opacity: 1.0 → 1.0, 0.0 → 0.15
      return Math.max(0.15, r * 0.85 + 0.15);
    }

    function isHighlighted(node) {
      if (!searchTerm) return true;
      const title = (node.title || '').toLowerCase();
      const subtype = (node.subtype || '').toLowerCase();
      return title.includes(searchTerm) || subtype.includes(searchTerm);
    }

    function formatDate(iso) {
      if (!iso) return '?';
      try {
        const d = new Date(iso);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
      } catch { return iso.slice(0, 10); }
    }

    function subtypeLabel(subtype) {
      if (!subtype) return 'unknown';
      return LABELS[subtype] || subtype.replace('custom:', '');
    }


    // ---- Detail panel ----
    function showDetail(node) {
      selectedNode = node;
      const panel = document.getElementById('detail');
      const title = document.getElementById('detail-title');
      const body = document.getElementById('detail-body');

      title.textContent = node.title || 'Untitled';
      title.style.color = getColor(node);

      const retr = node.retrievability != null ? (node.retrievability * 100).toFixed(0) + '%' : '?';

      let html = '';
      html += `<div class="detail-row"><span class="label">Type</span><span class="value">${subtypeLabel(node.subtype)}</span></div>`;
      html += `<div class="detail-row"><span class="label">Lifecycle</span><span class="value">${node.lifecycle || '?'}</span></div>`;
      html += `<div class="detail-row"><span class="label">Retrievability</span><span class="value">${retr}</span></div>`;
      html += `<div class="detail-row"><span class="label">Access Count</span><span class="value">${node.access_count || 0}</span></div>`;
      html += `<div class="detail-row"><span class="label">Created</span><span class="value">${formatDate(node.created_at)}</span></div>`;
      html += `<div class="detail-row"><span class="label">ID</span><span class="value" style="font-family:monospace;font-size:0.7rem">${node.id}</span></div>`;

      // Count connections
      const connections = graphData.links.filter(l =>
        (l.source.id || l.source) === node.id || (l.target.id || l.target) === node.id
      );
      html += `<div class="detail-row"><span class="label">Connections</span><span class="value">${connections.length}</span></div>`;

      // Cluster memberships
      if (clusterNodeMap[node.id] && clusterNodeMap[node.id].length > 0) {
        const clusterNames = clusterNodeMap[node.id]
          .map(cid => (clusterData.find(c => c.id === cid) || {}).name || cid)
          .join(', ');
        html += `<div class="detail-row"><span class="label">Clusters</span><span class="value">${clusterNames}</span></div>`;
      }

      if (node.summary) {
        html += `<div class="detail-summary">${node.summary}</div>`;
      }

      body.innerHTML = html;
      panel.style.display = 'block';
    }

    function hideDetail() {
      selectedNode = null;
      document.getElementById('detail').style.display = 'none';
    }

    // ---- Graph rendering ----
    function renderGraph(data) {
      const el = document.getElementById('graph');
      const loadingEl = document.getElementById('loading');
      loadingEl.style.display = 'none';

      // Clean edges that reference missing nodes
      const nodeIds = new Set(data.nodes.map(n => n.id));
      const validEdges = data.edges.filter(e => nodeIds.has(e.source) && nodeIds.has(e.target));

      graphData = { nodes: data.nodes, links: validEdges };

      // Process cluster data
      clusterData = data.clusters || [];
      clusterMemberships = (data.memberships || []).filter(m => nodeIds.has(m.node_id));
      clusterNodeMap = {};
      for (const m of clusterMemberships) {
        if (!clusterNodeMap[m.node_id]) clusterNodeMap[m.node_id] = [];
        clusterNodeMap[m.node_id].push(m.cluster_id);
      }
      assignClusterColors(clusterData);
      nodeById = {};
      data.nodes.forEach(n => { nodeById[n.id] = n; });

      // Stats
      document.getElementById('stats').innerHTML =
        `<span>${data.nodes.length}</span> memories &middot; <span>${validEdges.length}</span> connections`;

      // Legend
      buildLegend(data.nodes);
      if (clustersEnabled) buildClusterLegend();

      if (graph) {
        graph.graphData(graphData);
        if (clustersEnabled) applyClusterForces();
        return;
      }

      graph = ForceGraph()(el)
        .graphData(graphData)
        .backgroundColor('#0a0a0a')
        .width(el.clientWidth)
        .height(el.clientHeight)

        // Node rendering
        .nodeCanvasObject((node, ctx, globalScale) => {
          const r = getRadius(node);
          const color = getColor(node);
          const opacity = getOpacity(node);
          const highlighted = isHighlighted(node);
          const isSelected = selectedNode && selectedNode.id === node.id;
          const isHovered = hoveredNode && hoveredNode.id === node.id;
          const isConnected = selectedNode && graphData.links.some(l =>
            ((l.source.id || l.source) === selectedNode.id && (l.target.id || l.target) === node.id) ||
            ((l.target.id || l.target) === selectedNode.id && (l.source.id || l.source) === node.id)
          );

          let alpha = opacity;
          if (searchTerm && !highlighted) alpha = 0.06;
          if (selectedNode && !isSelected && !isConnected) alpha = 0.12;

          // Soft glow — color-rich, tight to node, premium feel
          if (isHovered || isSelected) {
            const glowR = r + 6;
            const grad = ctx.createRadialGradient(node.x, node.y, r * 0.3, node.x, node.y, glowR);
            grad.addColorStop(0, color + 'cc');
            grad.addColorStop(0.35, color + '66');
            grad.addColorStop(0.7, color + '22');
            grad.addColorStop(1, color + '00');
            ctx.beginPath();
            ctx.arc(node.x, node.y, glowR, 0, 2 * Math.PI);
            ctx.fillStyle = grad;
            ctx.globalAlpha = isSelected ? 0.95 : 0.85;
            ctx.fill();
          }

          // Core node
          ctx.beginPath();
          ctx.arc(node.x, node.y, r, 0, 2 * Math.PI);
          ctx.fillStyle = color;
          ctx.globalAlpha = alpha;
          ctx.fill();

          ctx.globalAlpha = 1;
        })
        .nodePointerAreaPaint((node, color, ctx) => {
          const r = getRadius(node) + 4;
          ctx.beginPath();
          ctx.arc(node.x, node.y, r, 0, 2 * Math.PI);
          ctx.fillStyle = color;
          ctx.fill();
        })

        // Edge rendering — subtle, thin lines
        .linkCanvasObject((link, ctx) => {
          const strength = link.strength || 0.5;
          const width = Math.max(0.2, strength * 0.6);
          const sourceId = link.source.id || link.source;
          const targetId = link.target.id || link.target;

          let alpha = 0.3;
          if (selectedNode) {
            if (sourceId === selectedNode.id || targetId === selectedNode.id) {
              alpha = 0.45;
            } else {
              alpha = 0.04;
            }
          }
          if (searchTerm) {
            const srcNode = graphData.nodes.find(n => n.id === sourceId);
            const tgtNode = graphData.nodes.find(n => n.id === targetId);
            if (srcNode && tgtNode && isHighlighted(srcNode) && isHighlighted(tgtNode)) {
              alpha = 0.25;
            } else if (searchTerm) {
              alpha = 0.02;
            }
          }

          ctx.beginPath();
          ctx.moveTo(link.source.x, link.source.y);
          ctx.lineTo(link.target.x, link.target.y);
          ctx.strokeStyle = '#9090a0';
          ctx.globalAlpha = alpha;
          ctx.lineWidth = width;
          ctx.stroke();
          ctx.globalAlpha = 1;
        })

        // Interactions
        .onNodeHover((node) => {
          hoveredNode = node;
          el.style.cursor = node ? 'pointer' : 'default';
        })
        .autoPauseRedraw(false)
        .onNodeClick((node) => {
          if (selectedNode && selectedNode.id === node.id) {
            selectedNode = null;
            hideDetail();
            return;
          }
          showDetail(node);
          graph.centerAt(node.x, node.y, 400);
          graph.zoom(3, 400);
        })
        .onBackgroundClick(() => {
          selectedNode = null;
          hideDetail();
        })

        // Cluster hull rendering — drawn behind nodes and edges
        .onRenderFramePre((ctx, globalScale) => {
          if (!clustersEnabled || clusterData.length === 0) return;
          const pad = 20 / globalScale;

          for (const cluster of clusterData) {
            const members = clusterMemberships
              .filter(m => m.cluster_id === cluster.id)
              .map(m => nodeById[m.node_id])
              .filter(n => n && n.x !== undefined);

            if (members.length === 0) continue;
            const colors = clusterColorMap[cluster.id];
            if (!colors) continue;

            if (members.length === 1) {
              ctx.beginPath();
              ctx.arc(members[0].x, members[0].y, pad, 0, 2 * Math.PI);
            } else if (members.length === 2) {
              drawCapsule(ctx, members[0], members[1], pad);
            } else {
              const points = members.map(n => ({ x: n.x, y: n.y }));
              const hull = convexHull(points);
              const expanded = expandHull(hull, pad);
              drawSmoothHull(ctx, expanded);
            }

            ctx.fillStyle = colors.fill;
            ctx.fill();
            ctx.strokeStyle = colors.stroke;
            ctx.lineWidth = 1 / globalScale;
            ctx.stroke();

            // Cluster label at centroid
            const cx = members.reduce((s, n) => s + n.x, 0) / members.length;
            const cy = members.reduce((s, n) => s + n.y, 0) / members.length;
            const fontSize = Math.max(3, 10 / globalScale);
            ctx.font = `500 ${fontSize}px Inter, system-ui, sans-serif`;
            ctx.fillStyle = colors.stroke.replace(/[\d.]+\)$/, '0.5)');
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(cluster.name, cx, cy);
          }
        })

        // Physics — configure AFTER creation (d3Force returns the force, not the graph)
        ;

      // Gentle charge — enough to spread nodes but not launch orphans
      graph.d3Force('charge').strength(-60);
      graph.d3Force('link').distance(80);

      // Gravity toward center — prevents orphans from drifting into the void
      graph.d3Force('gravity-x', d3.forceX(0).strength(0.04));
      graph.d3Force('gravity-y', d3.forceY(0).strength(0.04));

      // Handle window resize
      window.addEventListener('resize', () => {
        graph.width(el.clientWidth).height(el.clientHeight);
      });
    }

    // ---- Data loading ----
    let activeUrl = null;
    let graphRendered = false;

    async function tryFetch() {
      // If we already found a working URL, try it first
      if (activeUrl) {
        try {
          const resp = await fetch(activeUrl);
          if (resp.ok) return await resp.json();
        } catch {}
        activeUrl = null;
      }

      // Try each URL
      for (const url of NOUS_URLS) {
        try {
          const resp = await fetch(url, { signal: AbortSignal.timeout(3000) });
          if (!resp.ok) continue;
          const data = await resp.json();
          activeUrl = url;
          return data;
        } catch {
          continue;
        }
      }
      return null;
    }

    async function loadGraph() {
      const loadingEl = document.getElementById('loading');
      loadingEl.style.display = 'block';
      loadingEl.className = 'loading';
      loadingEl.textContent = 'Loading graph...';

      // Retry up to 5 times with increasing delay (server may still be starting)
      for (let attempt = 0; attempt < 5; attempt++) {
        const data = await tryFetch();
        if (data) {
          graphRendered = true;
          renderGraph(data);
          return;
        }
        // Wait before retrying (1s, 2s, 3s, 4s)
        if (attempt < 4) {
          loadingEl.textContent = `Waiting for Nous server... (attempt ${attempt + 2})`;
          await new Promise(r => setTimeout(r, (attempt + 1) * 1000));
        }
      }

      // Only show error if graph never rendered
      if (!graphRendered) {
        loadingEl.className = 'loading error';
        loadingEl.textContent = 'Could not connect to Nous server. Make sure it is running.';
      } else {
        loadingEl.style.display = 'none';
      }
    }

    // ---- Event handlers ----
    document.getElementById('search').addEventListener('input', (e) => {
      searchTerm = e.target.value.toLowerCase().trim();
      if (graph) graph.refresh();
    });

    document.getElementById('refresh-btn').addEventListener('click', () => {
      loadGraph();
    });

    document.getElementById('reset-btn').addEventListener('click', () => {
      searchTerm = '';
      document.getElementById('search').value = '';
      selectedNode = null;
      hideDetail();
      if (graph) {
        graph.centerAt(0, 0, 400);
        graph.zoom(1, 400);
        graph.refresh();
      }
    });

    document.getElementById('detail-close').addEventListener('click', () => {
      hideDetail();
      if (graph) graph.refresh();
    });

    document.getElementById('cluster-btn').addEventListener('click', () => {
      clustersEnabled = !clustersEnabled;
      document.getElementById('cluster-btn').classList.toggle('active', clustersEnabled);
      buildClusterLegend();
      applyClusterForces();
      if (graph) graph.refresh();
    });

    // ---- Init ----
    _initUrls().then(() => loadGraph());
  </script>
</body>
</html>
