<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hynous Data Intelligence</title>
<script src="https://unpkg.com/lightweight-charts@4/dist/lightweight-charts.standalone.production.js"></script>
<script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0a0a;
    color: #fafafa;
    font-family: Inter, system-ui, sans-serif;
    overflow-x: hidden;
  }
  ::-webkit-scrollbar { width: 4px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: #262626; border-radius: 4px; }

  /* Header */
  .header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 10px 20px;
    border-bottom: 1px solid #1a1a1a;
    background: #0a0a0a;
    position: sticky; top: 0; z-index: 10;
  }
  .header-left { display: flex; align-items: center; gap: 12px; }
  .header-title { font-size: 0.95rem; font-weight: 600; }
  .header-subtitle { font-size: 0.7rem; color: #525252; }

  /* Coin Tabs */
  .coin-tabs {
    display: flex; gap: 2px; padding: 3px;
    background: #0f0f0f; border-radius: 8px; border: 1px solid #1a1a1a;
  }
  .coin-tab {
    padding: 5px 14px; border-radius: 6px; border: none;
    background: transparent; color: #525252;
    font-size: 0.78rem; font-weight: 500; cursor: pointer;
    transition: all 0.15s; font-family: inherit;
  }
  .coin-tab:hover { background: #1a1a1a; color: #a3a3a3; }
  .coin-tab.active { background: #1a1a1a; color: #fafafa; }

  /* Stats Bar */
  .stats-bar {
    display: flex; gap: 20px; padding: 6px 20px;
    border-bottom: 1px solid #141414; font-size: 0.68rem;
  }
  .stat-item { display: flex; align-items: center; gap: 5px; color: #404040; }
  .stat-dot { width: 5px; height: 5px; border-radius: 50%; }
  .stat-dot.on { background: #22c55e; box-shadow: 0 0 4px #22c55e; }
  .stat-dot.off { background: #ef4444; }
  .stat-dot.wait { background: #eab308; }
  .stat-val { color: #737373; font-family: 'JetBrains Mono', monospace; }

  /* Panel Grid */
  .grid {
    display: grid; grid-template-columns: 1fr 1fr;
    grid-auto-rows: minmax(260px, 340px);
    gap: 10px; padding: 12px;
  }
  .panel {
    background: #0c0c0c; border: 1px solid #141414;
    border-radius: 8px; overflow: hidden; min-height: 260px;
    display: flex; flex-direction: column;
  }
  .panel.full { grid-column: 1 / -1; }
  .panel-hdr {
    display: flex; align-items: center; justify-content: space-between;
    padding: 8px 12px; border-bottom: 1px solid #141414;
    flex-shrink: 0;
  }
  .panel-title {
    font-size: 0.72rem; font-weight: 600; color: #737373;
    text-transform: uppercase; letter-spacing: 0.05em;
  }
  .panel-badge {
    font-size: 0.62rem; color: #404040;
    font-family: 'JetBrains Mono', monospace;
  }
  .panel-body { padding: 0; flex: 1; min-height: 0; position: relative; }
  .panel-body.padded { padding: 10px; }

  /* Tooltip */
  .lw-tooltip {
    position: absolute; display: none; pointer-events: none; z-index: 20;
    background: rgba(12,12,12,0.95); border: 1px solid #262626;
    border-radius: 6px; padding: 6px 10px;
    font-size: 0.72rem; color: #fafafa;
    backdrop-filter: blur(8px); white-space: nowrap;
  }
  .lw-tooltip .tt-time { color: #525252; font-size: 0.62rem; margin-bottom: 2px; }
  .lw-tooltip .tt-price { font-family: 'JetBrains Mono', monospace; font-weight: 600; font-size: 0.82rem; }

  /* Order Flow */
  .flow-row { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
  .flow-tf {
    font-size: 0.68rem; color: #525252; width: 28px; text-align: right;
    font-family: 'JetBrains Mono', monospace; flex-shrink: 0;
  }
  .flow-bar-wrap { flex: 1; height: 26px; display: flex; border-radius: 4px; overflow: hidden; }
  .flow-buy {
    background: linear-gradient(90deg, #14532d, #22c55e);
    display: flex; align-items: center; justify-content: center;
    font-size: 0.6rem; color: #fff; font-weight: 500; min-width: 28px;
    transition: width 0.8s cubic-bezier(0.22, 1, 0.36, 1);
  }
  .flow-sell {
    background: linear-gradient(90deg, #ef4444, #7f1d1d);
    display: flex; align-items: center; justify-content: center;
    font-size: 0.6rem; color: #fff; font-weight: 500; min-width: 28px;
    transition: width 0.8s cubic-bezier(0.22, 1, 0.36, 1);
  }
  .flow-cvd {
    font-size: 0.68rem; font-family: 'JetBrains Mono', monospace;
    width: 80px; text-align: right; flex-shrink: 0;
    transition: color 0.3s ease;
  }
  .flow-cvd.pos { color: #22c55e; }
  .flow-cvd.neg { color: #ef4444; }
  @keyframes flow-flash { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
  .flow-cvd.flash { animation: flow-flash 0.4s ease-out; }
  .flow-net {
    margin-top: 10px; padding: 8px 10px;
    background: #111; border-radius: 6px;
    display: flex; justify-content: space-between; align-items: center;
    font-size: 0.72rem;
    transition: background 0.3s ease;
  }
  .flow-net-label { color: #525252; font-weight: 500; }

  /* Tables */
  .data-table { width: 100%; border-collapse: collapse; font-size: 0.7rem; }
  .data-table th {
    text-align: left; padding: 6px 8px; color: #404040; font-weight: 500;
    text-transform: uppercase; letter-spacing: 0.04em; font-size: 0.6rem;
    border-bottom: 1px solid #1a1a1a; position: sticky; top: 0; background: #0c0c0c;
  }
  .data-table td {
    padding: 5px 8px; color: #a3a3a3; border-bottom: 1px solid #0f0f0f;
    font-family: 'JetBrains Mono', monospace;
  }
  .data-table tr:hover td { background: #0f0f0f; }
  .side-dot {
    display: inline-block; width: 6px; height: 6px;
    border-radius: 50%; margin-right: 5px; vertical-align: middle;
  }
  .side-dot.long { background: #22c55e; }
  .side-dot.short { background: #ef4444; }
  .bar-fill {
    display: inline-block; height: 3px; border-radius: 2px;
    background: #6366f1; opacity: 0.5;
  }

  /* Collapsible */
  .collapse-btn {
    background: none; border: none; color: #525252; cursor: pointer;
    font-size: 0.62rem; padding: 2px 6px; border-radius: 4px;
    font-family: inherit;
  }
  .collapse-btn:hover { color: #a3a3a3; background: #1a1a1a; }

  /* Whale view tabs */
  .whale-tabs {
    display: flex; gap: 1px; background: #141414; border-radius: 5px; padding: 2px;
  }
  .whale-tab {
    padding: 2px 8px; border-radius: 4px; border: none;
    background: transparent; color: #404040;
    font-size: 0.6rem; font-weight: 500; cursor: pointer;
    transition: all 0.15s; font-family: inherit;
  }
  .whale-tab:hover { color: #737373; }
  .whale-tab.active { background: #1a1a1a; color: #a3a3a3; }
  .whale-stats {
    display: flex; gap: 14px; padding: 4px 12px;
    font-size: 0.58rem; color: #404040; border-bottom: 1px solid #0f0f0f;
  }
  .whale-stats .ws-val { color: #737373; font-family: 'JetBrains Mono', monospace; }
  .whale-stats .ws-long { color: #22c55e; }
  .whale-stats .ws-short { color: #ef4444; }
  .whale-stats { flex-shrink: 0; }
  .whale-limit {
    background: #141414; border: 1px solid #1a1a1a; border-radius: 4px;
    color: #737373; font-size: 0.6rem; font-family: 'JetBrains Mono', monospace;
    padding: 2px 4px; cursor: pointer; outline: none;
  }
  .whale-limit:hover { border-color: #262626; color: #a3a3a3; }
  .whale-limit option { background: #0c0c0c; color: #a3a3a3; }

  .empty { display: flex; align-items: center; justify-content: center; height: 100%; color: #262626; font-size: 0.78rem; }

  /* Whale Explorer Overlay */
  .whale-overlay {
    position: fixed; inset: 0; z-index: 1000;
    background: #0a0a0a; display: none;
  }
  .whale-overlay-hdr {
    display: flex; align-items: center; justify-content: space-between;
    padding: 10px 20px; border-bottom: 1px solid #1a1a1a;
  }
  .whale-overlay-hdr .title { font-size: 0.95rem; font-weight: 600; }
  .whale-overlay-hdr .subtitle { font-size: 0.7rem; color: #525252; margin-left: 12px; }
  .whale-overlay-close {
    background: none; border: 1px solid #262626; color: #737373;
    cursor: pointer; padding: 4px 14px; border-radius: 6px;
    font-family: inherit; font-size: 0.72rem; transition: all 0.15s;
  }
  .whale-overlay-close:hover { color: #fafafa; border-color: #404040; }
  .whale-overlay-chart { position: absolute; top: 46px; left: 0; right: 0; bottom: 0; }
</style>
</head>
<body>
  <!-- Header -->
  <div class="header">
    <div class="header-left">
      <span class="header-title">Data Intelligence</span>
      <span class="header-subtitle">Liquidations, order flow, whales, smart money</span>
    </div>
    <div class="coin-tabs" id="coin-tabs">
      <button class="coin-tab active" data-coin="BTC">BTC</button>
      <button class="coin-tab" data-coin="ETH">ETH</button>
      <button class="coin-tab" data-coin="SOL">SOL</button>
    </div>
  </div>

  <!-- Stats Bar -->
  <div class="stats-bar">
    <div class="stat-item"><div class="stat-dot wait" id="ws-dot"></div><span>Data Layer</span><span class="stat-val" id="stat-status">connecting</span></div>
    <div class="stat-item"><span>Wallets</span><span class="stat-val" id="stat-wallets">-</span></div>
    <div class="stat-item"><span>Positions</span><span class="stat-val" id="stat-positions">-</span></div>
    <div class="stat-item"><span>Uptime</span><span class="stat-val" id="stat-uptime">-</span></div>
    <div class="stat-item"><span>Last Update</span><span class="stat-val" id="stat-updated">-</span></div>
  </div>

  <!-- Panels -->
  <div class="grid">
    <!-- Price chart -->
    <div class="panel full">
      <div class="panel-hdr">
        <span class="panel-title">Price</span>
        <span class="panel-badge" id="price-badge">loading</span>
      </div>
      <div class="panel-body" id="price-wrap" style="height:300px">
        <div class="lw-tooltip" id="price-tooltip"></div>
      </div>
    </div>

    <!-- Heatmap -->
    <div class="panel">
      <div class="panel-hdr">
        <span class="panel-title">Liquidation Heatmap</span>
        <span class="panel-badge" id="hm-badge"></span>
      </div>
      <div class="panel-body" id="hm-panel"></div>
    </div>

    <!-- Whales -->
    <div class="panel">
      <div class="panel-hdr">
        <div style="display:flex;align-items:center;gap:10px">
          <span class="panel-title">Whale Positions</span>
          <div class="whale-tabs" id="whale-view-tabs">
            <button class="whale-tab active" data-view="landscape">Landscape</button>
            <button class="whale-tab" data-view="cascade">Cascade</button>
            <button class="whale-tab" data-view="treemap">Treemap</button>
          </div>
          <div id="whale-treemap-opts" style="display:none;align-items:center;gap:6px">
            <select id="whale-group" class="whale-limit">
              <option value="none">No Group</option>
              <option value="side">By Side</option>
              <option value="leverage">By Leverage</option>
              <option value="pnl">By PnL</option>
            </select>
            <select id="whale-size-metric" class="whale-limit">
              <option value="size">Size USD</option>
              <option value="pnl">|PnL|</option>
              <option value="leverage">Leverage</option>
            </select>
          </div>
        </div>
        <div style="display:flex;align-items:center;gap:8px">
          <select id="whale-limit" class="whale-limit">
            <option value="100">100</option>
            <option value="500" selected>500</option>
            <option value="1000">1K</option>
            <option value="2000">2K</option>
            <option value="5000">5K</option>
          </select>
          <span class="panel-badge" id="whale-badge"></span>
          <button class="collapse-btn" id="whale-expand">Explore</button>
        </div>
      </div>
      <div class="whale-stats" id="whale-stats"></div>
      <div class="panel-body" id="whale-panel"></div>
    </div>

    <!-- Order Flow -->
    <div class="panel">
      <div class="panel-hdr">
        <span class="panel-title">Order Flow</span>
        <span class="panel-badge" id="flow-badge"></span>
      </div>
      <div class="panel-body padded" id="flow-panel"><div class="empty">Waiting for data</div></div>
    </div>

    <!-- Smart Money -->
    <div class="panel">
      <div class="panel-hdr">
        <span class="panel-title">Smart Money</span>
        <span class="panel-badge" id="sm-badge"></span>
      </div>
      <div class="panel-body" id="sm-panel" style="overflow-y:auto"><div class="empty">Waiting for data</div></div>
    </div>

    <!-- HLP -->
    <div class="panel full">
      <div class="panel-hdr">
        <span class="panel-title">HLP Vault Positions</span>
        <div style="display:flex;align-items:center;gap:8px">
          <span class="panel-badge" id="hlp-badge"></span>
          <button class="collapse-btn" id="hlp-toggle">Collapse</button>
        </div>
      </div>
      <div class="panel-body" id="hlp-panel" style="overflow-y:auto;min-height:80px"><div class="empty">Waiting for data</div></div>
    </div>
  </div>

<!-- Whale Explorer Overlay -->
<div class="whale-overlay" id="whale-overlay">
  <div class="whale-overlay-hdr">
    <div style="display:flex;align-items:center;gap:12px">
      <span class="title">Whale Explorer</span>
      <div class="whale-tabs" id="whale-overlay-tabs">
        <button class="whale-tab active" data-view="landscape">Landscape</button>
        <button class="whale-tab" data-view="cascade">Cascade</button>
        <button class="whale-tab" data-view="treemap">Treemap</button>
      </div>
      <span class="subtitle" id="whale-overlay-stats"></span>
    </div>
    <button class="whale-overlay-close" id="whale-close">Close</button>
  </div>
  <div class="whale-overlay-chart" id="whale-overlay-chart"></div>
</div>

<script>
(function() {
  'use strict';

  const B = location.origin.replace(':3000', ':8000');
  let coin = 'BTC';
  let hlpCollapsed = false;

  // --- Tab switching ---
  document.getElementById('coin-tabs').addEventListener('click', e => {
    const btn = e.target.closest('.coin-tab');
    if (!btn) return;
    document.querySelectorAll('.coin-tab').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    coin = btn.dataset.coin;
    flowBuilt = false;  // force skeleton rebuild for new coin
    livePrice = 0;      // reset price ticker
    refreshAll();
  });

  // --- HLP collapse ---
  document.getElementById('hlp-toggle').addEventListener('click', function() {
    hlpCollapsed = !hlpCollapsed;
    this.textContent = hlpCollapsed ? 'Expand' : 'Collapse';
    document.getElementById('hlp-panel').style.display = hlpCollapsed ? 'none' : '';
  });

  // --- Helpers ---
  async function api(url) {
    try { const r = await fetch(url); if (!r.ok) return null; return await r.json(); }
    catch { return null; }
  }
  function $(n) { return (Math.abs(n) >= 1e6) ? '$' + (n/1e6).toFixed(1) + 'M' : (Math.abs(n) >= 1e3) ? '$' + (n/1e3).toFixed(1) + 'K' : '$' + n.toFixed(0); }
  function addr(a) { return (!a || a.length < 10) ? (a||'?') : a.slice(0,6) + '\u2026' + a.slice(-4); }
  function vis() { return !document.hidden; }

  // =====================================================================
  // PRICE CHART — Polymarket-style area chart
  // =====================================================================
  let chart, series;

  function initPrice() {
    const el = document.getElementById('price-wrap');
    chart = LightweightCharts.createChart(el, {
      width: el.clientWidth, height: el.clientHeight,
      layout: { background: { color: '#0c0c0c' }, textColor: 'rgba(255,255,255,0.3)', fontSize: 10, fontFamily: "'JetBrains Mono', monospace" },
      grid: { vertLines: { visible: false }, horzLines: { visible: false } },
      crosshair: {
        mode: 0,
        vertLine: { color: 'rgba(255,255,255,0.12)', width: 1, style: 0, labelVisible: false },
        horzLine: { visible: false, labelVisible: false },
      },
      rightPriceScale: { borderVisible: false, scaleMargins: { top: 0.08, bottom: 0.15 } },
      timeScale: { borderVisible: false, timeVisible: true, secondsVisible: false, rightOffset: 3 },
      handleScroll: { mouseWheel: true, pressedMouseMove: true },
      handleScale: { mouseWheel: true, pinch: true },
    });

    series = chart.addAreaSeries({
      lineColor: '#6366f1', lineWidth: 2,
      topColor: 'rgba(99,102,241,0.25)', bottomColor: 'rgba(99,102,241,0)',
      crosshairMarkerVisible: true,
      crosshairMarkerRadius: 4,
      crosshairMarkerBorderColor: '#6366f1',
      crosshairMarkerBackgroundColor: '#6366f1',
      crosshairMarkerBorderWidth: 0,
      priceLineVisible: false,
      lastValueVisible: true,
    });

    // Floating tooltip
    const tip = document.getElementById('price-tooltip');
    chart.subscribeCrosshairMove(param => {
      if (!param.point || !param.time || param.point.x < 0 || param.point.y < 0) {
        tip.style.display = 'none'; return;
      }
      const d = param.seriesData.get(series);
      if (!d) { tip.style.display = 'none'; return; }
      const px = d.value !== undefined ? d.value : d.close;
      const dt = new Date(param.time * 1000);
      const ts = dt.toLocaleString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
      const fmtPx = px >= 1 ? '$' + px.toLocaleString(undefined, {maximumFractionDigits: 2}) : '$' + px.toFixed(4);
      tip.innerHTML = '<div class="tt-time">' + ts + '</div><div class="tt-price" style="color:#6366f1">' + fmtPx + '</div>';
      let left = param.point.x;
      const tw = tip.offsetWidth || 100;
      if (left + tw/2 > el.clientWidth) left = el.clientWidth - tw/2;
      if (left - tw/2 < 0) left = tw/2;
      tip.style.left = left + 'px';
      tip.style.top = Math.max(0, param.point.y - 48) + 'px';
      tip.style.transform = 'translateX(-50%)';
      tip.style.display = 'block';
    });

    new ResizeObserver(() => chart.applyOptions({ width: el.clientWidth, height: el.clientHeight })).observe(el);
  }

  async function updatePrice() {
    const candles = await api(B + '/api/candles?symbol=' + coin + '&interval=5m&hours=48');
    if (!candles || candles.error || !Array.isArray(candles) || !candles.length) {
      document.getElementById('price-badge').textContent = 'no data'; return;
    }
    series.setData(candles.map(c => ({ time: Math.floor(c.t/1000), value: c.c })));
    const last = candles[candles.length-1];
    const px = last.c >= 1 ? '$' + last.c.toLocaleString(undefined,{maximumFractionDigits:2}) : '$' + last.c.toFixed(4);
    document.getElementById('price-badge').textContent = coin + ' ' + px;
  }

  // =====================================================================
  // LIQUIDATION HEATMAP — Coinglass-inspired vertical heatmap
  // =====================================================================
  let hmChart;
  let hmBuckets = []; // stored for live price line updates

  function initHeatmap() {
    hmChart = echarts.init(document.getElementById('hm-panel'), null, { renderer: 'canvas' });
    new ResizeObserver(() => hmChart.resize()).observe(document.getElementById('hm-panel'));
  }

  // Fast price dot update (called every 3s by tickPrice)
  // Uses a scatter series (index 2) — ECharts animates position change smoothly
  function updateHeatmapPrice(price) {
    if (!hmChart || !hmBuckets.length || !price) return;
    let midIdx = 0, minDist = Infinity;
    hmBuckets.forEach((b, i) => { const d = Math.abs(b.price_mid - price); if (d < minDist) { minDist = d; midIdx = i; } });
    const pLabel = price >= 1 ? '$' + price.toLocaleString(undefined, {maximumFractionDigits: 0}) : '$' + price.toFixed(4);
    hmChart.setOption({
      series: [
        {}, // index 0 — Long bars (unchanged)
        {}, // index 1 — Short bars (unchanged)
        {   // index 2 — Price dot
          data: [[0, midIdx]],
          label: { formatter: pLabel },
        }
      ]
    });
  }

  async function updateHeatmap() {
    const data = await api(B + '/api/data/heatmap/' + coin);
    if (!data || data.error || !data.buckets || !data.buckets.length) {
      hmChart.setOption({ title: { text: 'No heatmap data', left: 'center', top: 'center', textStyle: { color: '#262626', fontSize: 12 } }, series: [] });
      hmBuckets = []; return;
    }

    const buckets = data.buckets;
    hmBuckets = buckets; // store for live price line
    const mid = data.mid_price || 0;

    // Build vertical bar-style heatmap — each bucket is a horizontal bar
    // Y = price level, bar width = liquidation magnitude, color = long (green) / short (red)
    const prices = buckets.map(b => {
      const p = b.price_mid;
      return p >= 1000 ? '$' + (p/1000).toFixed(1) + 'K' : p >= 1 ? '$' + p.toFixed(0) : '$' + p.toFixed(4);
    });
    const longVals = buckets.map(b => b.long_liq_usd || 0);
    const shortVals = buckets.map(b => -(b.short_liq_usd || 0)); // negative for left side
    const maxVal = Math.max(...buckets.map(b => Math.max(b.long_liq_usd || 0, b.short_liq_usd || 0)), 1);

    // Find current price index for markLine
    let midIdx = 0;
    let minDist = Infinity;
    buckets.forEach((b, i) => { const d = Math.abs(b.price_mid - mid); if (d < minDist) { minDist = d; midIdx = i; } });

    hmChart.setOption({
      title: null,
      tooltip: {
        trigger: 'axis', axisPointer: { type: 'shadow' },
        backgroundColor: 'rgba(12,12,12,0.95)', borderColor: '#262626', textStyle: { color: '#fafafa', fontSize: 11 },
        formatter: function(params) {
          const idx = params[0].dataIndex;
          const b = buckets[idx];
          const p = b.price_mid;
          const pStr = p >= 1 ? '$' + p.toLocaleString(undefined,{maximumFractionDigits:0}) : '$' + p.toFixed(4);
          return '<div style="font-size:11px;color:#737373;margin-bottom:4px">' + pStr + '</div>' +
            '<div style="color:#22c55e">Long Liqs: <b>' + $(b.long_liq_usd || 0) + '</b></div>' +
            '<div style="color:#ef4444">Short Liqs: <b>' + $(b.short_liq_usd || 0) + '</b></div>';
        }
      },
      grid: { left: 60, right: 16, top: 8, bottom: 24 },
      xAxis: {
        type: 'value',
        axisLine: { show: false }, axisTick: { show: false },
        axisLabel: { color: '#404040', fontSize: 9, formatter: function(v) { return $(Math.abs(v)); } },
        splitLine: { lineStyle: { color: '#141414' } },
      },
      yAxis: {
        type: 'category', data: prices,
        axisLine: { lineStyle: { color: '#1a1a1a' } },
        axisTick: { show: false },
        axisLabel: { color: '#525252', fontSize: 8 },
      },
      series: [
        {
          name: 'Long', type: 'bar', stack: 'liq', data: longVals,
          itemStyle: {
            color: function(p) {
              const ratio = Math.min(1, (p.value || 0) / maxVal);
              const r = Math.round(34 + ratio * 0), g = Math.round(80 + ratio * 117), b_ = Math.round(50 + ratio * 44);
              return 'rgb(' + r + ',' + g + ',' + b_ + ')';
            },
            borderRadius: [0, 3, 3, 0],
          },
          barMaxWidth: 12,
        },
        {
          name: 'Short', type: 'bar', stack: 'liq', data: shortVals,
          itemStyle: {
            color: function(p) {
              const ratio = Math.min(1, Math.abs(p.value || 0) / maxVal);
              const r = Math.round(127 + ratio * 112), g = Math.round(29 + ratio * 0), b_ = Math.round(29 + ratio * 0);
              return 'rgb(' + r + ',' + g + ',' + b_ + ')';
            },
            borderRadius: [3, 0, 0, 3],
          },
          barMaxWidth: 12,
        },
        // Price dot — scatter point at x=0 (center), y=price bucket index
        // tickPrice() updates this every 3s, ECharts animates the Y position change
        {
          name: 'Price', type: 'scatter',
          data: mid > 0 ? [[0, midIdx]] : [],
          symbolSize: 14,
          z: 10,
          itemStyle: {
            color: '#6366f1',
            borderColor: '#a5b4fc',
            borderWidth: 2,
            shadowColor: 'rgba(99, 102, 241, 0.6)',
            shadowBlur: 10,
          },
          label: {
            show: true,
            position: 'right',
            distance: 8,
            color: '#a5b4fc',
            fontSize: 9,
            fontWeight: 600,
            fontFamily: 'JetBrains Mono, monospace',
            formatter: mid >= 1 ? '$' + mid.toLocaleString(undefined, {maximumFractionDigits: 0}) : '$' + mid.toFixed(4),
            backgroundColor: 'rgba(10, 10, 10, 0.85)',
            padding: [2, 5],
            borderRadius: 3,
          },
          animationDuration: 800,
          animationEasing: 'cubicOut',
        },
      ],
    });

    document.getElementById('hm-badge').textContent = buckets.length + ' levels';
  }

  // =====================================================================
  // WHALE POSITIONS — 3 views: Landscape, Cascade, Scatter
  // =====================================================================
  let whaleChart, whaleOverlayChart;
  let whaleData = [];
  let whaleView = 'landscape';      // panel view
  let whaleOverlayView = 'landscape'; // explorer view
  let landscapeBuckets = [];        // stored for live price line
  function whaleLimit() { return document.getElementById('whale-limit').value || '500'; }

  // Fast landscape price line update (called every 3s by tickPrice)
  function updateLandscapePrice(price) {
    if (!whaleChart || whaleView !== 'landscape' || !landscapeBuckets.length || !price) return;
    let midIdx = 0, minDist = Infinity;
    landscapeBuckets.forEach((b, i) => { const d = Math.abs(b.mid - price); if (d < minDist) { minDist = d; midIdx = i; } });
    whaleChart.setOption({
      series: [{ markLine: { silent: true, symbol: 'none',
        animationDuration: 800, animationEasing: 'cubicOut',
        data: [{ yAxis: midIdx, lineStyle: { color: '#6366f1', width: 2, type: 'dashed' },
          label: { show: true, formatter: px(price), color: '#6366f1', fontSize: 8, position: 'insideEndTop' } }],
      }}]
    });
  }

  function initWhale() {
    whaleChart = echarts.init(document.getElementById('whale-panel'), null, { renderer: 'canvas' });
    new ResizeObserver(() => whaleChart.resize()).observe(document.getElementById('whale-panel'));
  }

  // --- Parse raw API positions ---
  function parseWhales(raw) {
    return (raw || []).map(p => ({
      size: Math.abs(p.size_usd || p.notional_usd || p.sz_usd || 0),
      pnl: p.pnl_usd || p.unrealized_pnl || 0,
      entry: p.entry_px || p.entry_price || p.avg_entry || 0,
      mark: p.mark_px || 0,
      lev: p.leverage || p.lev || 1,
      side: ((p.side || '').toLowerCase().startsWith('l') || (p.side || '').toLowerCase() === 'buy') ? 'long' : 'short',
      address: p.address || p.addr || '',
      liq: p.liq_px || 0,
    })).filter(p => p.size > 0 && p.entry > 0);
  }
  function px(v) { return v >= 1000 ? '$' + (v/1000).toFixed(1) + 'K' : v >= 1 ? '$' + v.toFixed(0) : '$' + v.toFixed(4); }

  // --- Stats strip ---
  function updateWhaleStats(whales) {
    const el = document.getElementById('whale-stats');
    if (!whales.length) { el.innerHTML = ''; return; }
    const longs = whales.filter(w => w.side === 'long');
    const shorts = whales.filter(w => w.side !== 'long');
    const longUSD = longs.reduce((s, w) => s + w.size, 0);
    const shortUSD = shorts.reduce((s, w) => s + w.size, 0);
    const total = longUSD + shortUSD;
    const ratio = shortUSD > 0 ? (longUSD / shortUSD).toFixed(2) : '\u221E';
    const avgLev = (whales.reduce((s, w) => s + w.lev, 0) / whales.length).toFixed(1);
    const top = whales.reduce((a, b) => b.size > a.size ? b : a);
    const liqWhales = whales.filter(w => w.liq > 0);
    const liqTotal = liqWhales.reduce((s, w) => s + w.size, 0);
    el.innerHTML =
      '<span>L/S <span class="ws-val">' + ratio + '</span> <span class="ws-long">' + longs.length + 'L</span>/<span class="ws-short">' + shorts.length + 'S</span></span>' +
      '<span>Exposure <span class="ws-val">' + $(total) + '</span></span>' +
      '<span>Avg Lev <span class="ws-val">' + avgLev + 'x</span></span>' +
      '<span>Liq Vol <span class="ws-val">' + $(liqTotal) + '</span></span>';
  }

  // =================================================================
  // VIEW 1: LANDSCAPE — Two-sided depth chart by price level
  // =================================================================
  function buildLandscape(chart, whales, markPx, large) {
    const N = large ? 40 : 28;
    const entries = whales.map(w => w.entry);
    const minE = Math.min(...entries), maxE = Math.max(...entries);
    const range = maxE - minE || 1, step = range / N;
    const buckets = Array.from({length: N}, (_, i) => {
      const lo = minE + i * step;
      return { lo, hi: lo + step, mid: lo + step/2, longUSD: 0, shortUSD: 0, longLiq: 0, shortLiq: 0, longCount: 0, shortCount: 0 };
    });
    whales.forEach(w => {
      const bi = Math.min(N-1, Math.floor((w.entry - minE) / range * N));
      if (w.side === 'long') { buckets[bi].longUSD += w.size; buckets[bi].longCount++; }
      else { buckets[bi].shortUSD += w.size; buckets[bi].shortCount++; }
      if (w.liq > 0 && w.liq >= minE && w.liq <= maxE + step) {
        const li = Math.min(N-1, Math.max(0, Math.floor((w.liq - minE) / range * N)));
        if (w.side === 'long') buckets[li].longLiq += w.size;
        else buckets[li].shortLiq += w.size;
      }
    });
    if (!large) landscapeBuckets = buckets; // store for live price ticks
    const labels = buckets.map(b => px(b.mid));
    const maxVal = Math.max(...buckets.map(b => Math.max(b.longUSD + b.longLiq, b.shortUSD + b.shortLiq)), 1);
    let midIdx = 0;
    if (markPx > 0) { let md = Infinity; buckets.forEach((b, i) => { const d = Math.abs(b.mid - markPx); if (d < md) { md = d; midIdx = i; } }); }
    const g = large ? { left: 70, right: 30, top: 30, bottom: 30 } : { left: 50, right: 12, top: 8, bottom: 20 };
    const fs = large ? 11 : 9;
    chart.setOption({
      tooltip: {
        trigger: 'axis', axisPointer: { type: 'shadow' },
        backgroundColor: 'rgba(12,12,12,0.95)', borderColor: '#262626', textStyle: { color: '#fafafa', fontSize: 11 },
        formatter: function(params) {
          const idx = params[0]?.dataIndex; if (idx === undefined) return '';
          const b = buckets[idx];
          const pLabel = px(b.lo) + ' \u2013 ' + px(b.hi);
          let h = '<div style="font-size:11px;color:#737373;margin-bottom:4px">' + pLabel + '</div>';
          if (b.longUSD > 0 || b.longCount > 0) h += '<div style="color:#22c55e">Long: <b>' + $(b.longUSD) + '</b> (' + b.longCount + ')</div>';
          if (b.shortUSD > 0 || b.shortCount > 0) h += '<div style="color:#ef4444">Short: <b>' + $(b.shortUSD) + '</b> (' + b.shortCount + ')</div>';
          if (b.longLiq > 0) h += '<div style="color:#fbbf24;font-size:10px">\u26A0 Long liqs here: ' + $(b.longLiq) + '</div>';
          if (b.shortLiq > 0) h += '<div style="color:#fbbf24;font-size:10px">\u26A0 Short liqs here: ' + $(b.shortLiq) + '</div>';
          return h;
        }
      },
      grid: g,
      xAxis: {
        type: 'value',
        axisLine: { show: false }, axisTick: { show: false },
        axisLabel: { color: '#404040', fontSize: fs, formatter: v => $(Math.abs(v)) },
        splitLine: { lineStyle: { color: '#141414' } },
      },
      yAxis: {
        type: 'category', data: labels,
        axisLine: { lineStyle: { color: '#1a1a1a' } }, axisTick: { show: false },
        axisLabel: { color: '#525252', fontSize: large ? 10 : 8 },
      },
      legend: large ? { show: true, top: 4, right: 20, textStyle: { color: '#525252', fontSize: 10 }, itemWidth: 10, itemHeight: 10 } : { show: false },
      dataZoom: large ? [
        { type: 'inside', yAxisIndex: 0, filterMode: 'none', zoomOnMouseWheel: true, moveOnMouseWheel: false, moveOnMouseMove: false, throttle: 120 },
      ] : [],
      series: [
        {
          name: 'Long', type: 'bar', stack: 'pos', data: buckets.map(b => b.longUSD),
          itemStyle: { color: 'rgba(34,197,94,0.7)', borderRadius: [0, 3, 3, 0] }, barMaxWidth: large ? 18 : 12,
          markLine: markPx > 0 ? { silent: true, symbol: 'none', data: [{ yAxis: midIdx,
            lineStyle: { color: '#6366f1', width: 1.5, type: 'dashed' },
            label: { show: true, formatter: px(markPx), color: '#6366f1', fontSize: large ? 10 : 8, position: 'insideEndTop' } }] } : undefined,
        },
        {
          name: 'Short', type: 'bar', stack: 'pos', data: buckets.map(b => -b.shortUSD),
          itemStyle: { color: 'rgba(239,68,68,0.7)', borderRadius: [3, 0, 0, 3] }, barMaxWidth: large ? 18 : 12,
        },
        {
          name: 'Long Liq Zone', type: 'bar', stack: 'liq', data: buckets.map(b => b.longLiq),
          itemStyle: { color: 'rgba(251,191,36,0.15)', borderColor: 'rgba(251,191,36,0.4)', borderWidth: 1 }, barMaxWidth: large ? 18 : 12,
        },
        {
          name: 'Short Liq Zone', type: 'bar', stack: 'liq', data: buckets.map(b => -b.shortLiq),
          itemStyle: { color: 'rgba(251,191,36,0.15)', borderColor: 'rgba(251,191,36,0.4)', borderWidth: 1 }, barMaxWidth: large ? 18 : 12,
        },
      ],
    }, true);
  }

  // =================================================================
  // VIEW 2: CASCADE — Cumulative liquidation fuel gauge
  // =================================================================
  function buildCascade(chart, whales, markPx, large) {
    if (!markPx) { chart.setOption({ title: { text: 'No mark price', left: 'center', top: 'center', textStyle: { color: '#262626', fontSize: 12 } }, series: [] }, true); return; }
    const pcts = [], longLiqs = [], shortLiqs = [];
    for (let p = -15; p <= 15; p += 0.5) {
      const priceAt = markPx * (1 + p / 100);
      let lL = 0, sL = 0;
      whales.forEach(w => {
        if (w.liq <= 0) return;
        if (w.side === 'long' && w.liq >= priceAt && w.liq <= markPx) lL += w.size;
        else if (w.side !== 'long' && w.liq <= priceAt && w.liq >= markPx) sL += w.size;
      });
      pcts.push(p); longLiqs.push(lL); shortLiqs.push(sL);
    }
    const g = large ? { left: 70, right: 30, top: 40, bottom: 40 } : { left: 48, right: 12, top: 8, bottom: 24 };
    const fs = large ? 11 : 9;
    chart.setOption({
      tooltip: {
        trigger: 'axis',
        backgroundColor: 'rgba(12,12,12,0.95)', borderColor: '#262626', textStyle: { color: '#fafafa', fontSize: 11 },
        formatter: function(params) {
          const idx = params[0]?.dataIndex; if (idx === undefined) return '';
          const pct = pcts[idx], priceAt = markPx * (1 + pct / 100);
          let h = '<div style="font-size:11px;color:#737373;margin-bottom:4px">' + (pct >= 0 ? '+' : '') + pct.toFixed(1) + '% \u2192 ' + px(priceAt) + '</div>';
          if (longLiqs[idx] > 0) h += '<div style="color:#ef4444">Long liqs: <b>' + $(longLiqs[idx]) + '</b></div>';
          if (shortLiqs[idx] > 0) h += '<div style="color:#22c55e">Short liqs: <b>' + $(shortLiqs[idx]) + '</b></div>';
          if (!longLiqs[idx] && !shortLiqs[idx]) h += '<div style="color:#404040">No liquidations</div>';
          return h;
        }
      },
      grid: g,
      xAxis: {
        type: 'category', data: pcts.map(p => (p >= 0 ? '+' : '') + p.toFixed(1) + '%'),
        axisLine: { lineStyle: { color: '#1a1a1a' } }, axisTick: { show: false },
        axisLabel: { color: '#525252', fontSize: fs, interval: large ? 3 : 5 },
        name: large ? 'Price Move from Current' : '', nameLocation: 'center', nameGap: 26,
        nameTextStyle: { color: '#404040', fontSize: 11 },
      },
      yAxis: {
        type: 'value',
        axisLine: { show: false }, axisTick: { show: false },
        axisLabel: { color: '#404040', fontSize: fs, formatter: v => $(v) },
        splitLine: { lineStyle: { color: '#141414' } },
        name: large ? 'Cumulative Liquidation Volume' : '', nameLocation: 'center', nameGap: 55,
        nameTextStyle: { color: '#404040', fontSize: 11 },
      },
      legend: large ? { show: true, top: 4, right: 20, textStyle: { color: '#525252', fontSize: 10 }, itemWidth: 10, itemHeight: 10 } : { show: false },
      dataZoom: large ? [{ type: 'inside', xAxisIndex: 0, filterMode: 'none', zoomOnMouseWheel: true, moveOnMouseWheel: false, moveOnMouseMove: false }] : [],
      series: [
        {
          name: 'Long Liquidations', type: 'line', data: longLiqs, smooth: true,
          lineStyle: { color: '#ef4444', width: 2 },
          areaStyle: { color: { type: 'linear', x: 0, y: 0, x2: 0, y2: 1, colorStops: [{ offset: 0, color: 'rgba(239,68,68,0.35)' }, { offset: 1, color: 'rgba(239,68,68,0)' }] } },
          itemStyle: { color: '#ef4444' }, symbol: 'none',
          markLine: { silent: true, symbol: 'none', data: [{ xAxis: pcts.indexOf(0) >= 0 ? pcts.indexOf(0) : 30,
            lineStyle: { color: '#6366f1', width: 1.5, type: 'dashed' },
            label: { show: true, formatter: 'Current', color: '#6366f1', fontSize: large ? 10 : 8, position: 'insideEndTop' } }] },
        },
        {
          name: 'Short Liquidations', type: 'line', data: shortLiqs, smooth: true,
          lineStyle: { color: '#22c55e', width: 2 },
          areaStyle: { color: { type: 'linear', x: 0, y: 0, x2: 0, y2: 1, colorStops: [{ offset: 0, color: 'rgba(34,197,94,0.35)' }, { offset: 1, color: 'rgba(34,197,94,0)' }] } },
          itemStyle: { color: '#22c55e' }, symbol: 'none',
        },
      ],
    }, true);
  }

  // =================================================================
  // VIEW 3: TREEMAP — Rectangle map sized by position
  // =================================================================
  function buildTreemap(chart, whales, markPx, large) {
    const groupBy = document.getElementById('whale-group').value || 'none';
    const sizeMetric = document.getElementById('whale-size-metric').value || 'size';

    function val(w) {
      if (sizeMetric === 'pnl') return Math.abs(w.pnl) || 1;
      if (sizeMetric === 'leverage') return w.lev || 1;
      return w.size;
    }
    function wColor(w, alpha) {
      return w.side === 'long' ? 'rgba(34,197,94,' + alpha + ')' : 'rgba(239,68,68,' + alpha + ')';
    }
    function whaleLeaf(w) {
      return { name: addr(w.address), value: val(w), whale: w,
        itemStyle: { color: wColor(w, 0.6), borderColor: wColor(w, 0.85) } };
    }
    function whaleTip(w) {
      const pC = w.pnl >= 0 ? '#22c55e' : '#ef4444';
      const sC = w.side === 'long' ? '#22c55e' : '#ef4444';
      const pnlStr = (w.pnl >= 0 ? '+' : '') + $(w.pnl);
      return '<div style="min-width:180px">' +
        '<div style="font-size:12px;font-weight:600;margin-bottom:4px">' + addr(w.address) + '</div>' +
        '<div style="font-size:11px"><span style="color:' + sC + '">' + w.side.toUpperCase() + '</span> \u00B7 ' + $(w.size) + ' \u00B7 ' + w.lev + 'x</div>' +
        '<div style="font-size:11px;color:#a3a3a3">Entry: ' + px(w.entry) + '</div>' +
        '<div style="font-size:11px;color:' + pC + '">PnL: <b>' + pnlStr + '</b></div>' +
        (w.liq > 0 ? '<div style="font-size:10px;color:#525252">Liq: ' + px(w.liq) + '</div>' : '') +
        '</div>';
    }

    // --- Build data: flat or grouped ---
    let data, isFlat = false;
    const sorted = [...whales].sort((a, b) => val(b) - val(a));

    if (groupBy === 'none') {
      // Flat — longs and shorts mixed, biggest first
      data = sorted.map(whaleLeaf);
      isFlat = true;
    } else {
      let groups;
      if (groupBy === 'leverage') {
        groups = [
          { name: '1\u20133x', whales: sorted.filter(w => w.lev <= 3) },
          { name: '3\u201310x', whales: sorted.filter(w => w.lev > 3 && w.lev <= 10) },
          { name: '10\u201325x', whales: sorted.filter(w => w.lev > 10 && w.lev <= 25) },
          { name: '25x+', whales: sorted.filter(w => w.lev > 25) },
        ];
      } else if (groupBy === 'pnl') {
        groups = [
          { name: 'In Profit', whales: sorted.filter(w => w.pnl >= 0) },
          { name: 'Underwater', whales: sorted.filter(w => w.pnl < 0) },
        ];
      } else {
        groups = [
          { name: 'Long', whales: sorted.filter(w => w.side === 'long') },
          { name: 'Short', whales: sorted.filter(w => w.side !== 'long') },
        ];
      }
      data = groups.filter(g => g.whales.length > 0).map(g => {
        const totalUSD = g.whales.reduce((s, w) => s + w.size, 0);
        const lC = g.whales.filter(w => w.side === 'long').length, sC = g.whales.length - lC;
        return {
          name: g.name + ' (' + g.whales.length + ') \u00B7 ' + $(totalUSD) + ' \u00B7 ' + lC + 'L/' + sC + 'S',
          children: g.whales.map(whaleLeaf),
        };
      });
    }

    // --- Label sizing ---
    const smallLabel = large ? 600 : 1500;
    const medLabel = large ? 2500 : 6000;
    const fullLabel = large ? 6000 : 15000;
    function leafLabel(p) {
      const w = p.data.whale; if (!w) return '';
      const area = p.rect ? p.rect.width * p.rect.height : 0;
      if (area < smallLabel) return '';
      const pC = w.pnl >= 0 ? '#4ade80' : '#f87171';
      const sIcon = w.side === 'long' ? '\u25B2' : '\u25BC';
      const sC = w.side === 'long' ? '{lg|' + sIcon + '}' : '{sh|' + sIcon + '}';
      const pnl = (w.pnl >= 0 ? '+' : '') + $(w.pnl);
      if (area < medLabel) return sC + ' ' + $(val(w));
      if (area < fullLabel) return sC + ' ' + $(w.size) + ' ' + w.lev + 'x\n{pnl' + (w.pnl >= 0 ? 'g' : 'r') + '|' + pnl + '}';
      return sC + ' {addr|' + addr(w.address) + '}\n' + $(w.size) + ' \u00B7 ' + w.lev + 'x\n{pnl' + (w.pnl >= 0 ? 'g' : 'r') + '|' + pnl + '}';
    }
    const leafRich = {
      lg: { color: '#22c55e', fontSize: large ? 12 : 10 },
      sh: { color: '#ef4444', fontSize: large ? 12 : 10 },
      addr: { color: '#a3a3a3', fontSize: large ? 10 : 8 },
      pnlg: { color: '#4ade80', fontSize: large ? 10 : 9, fontWeight: 600 },
      pnlr: { color: '#f87171', fontSize: large ? 10 : 9, fontWeight: 600 },
    };

    // --- Levels config ---
    const levels = isFlat ? [
      {
        itemStyle: { borderColor: '#0a0a0a', borderWidth: 1, gapWidth: 1 },
        label: {
          show: true, formatter: leafLabel, rich: leafRich,
          color: '#fafafa', fontSize: large ? 11 : 9,
          fontFamily: "'JetBrains Mono', monospace",
          lineHeight: large ? 16 : 13, position: 'insideCenter', overflow: 'truncate',
        },
      },
    ] : [
      {
        itemStyle: { borderColor: '#1a1a1a', borderWidth: 3, gapWidth: 2 },
        upperLabel: {
          show: true, height: large ? 22 : 16,
          color: '#d4d4d4', fontSize: large ? 11 : 9, fontWeight: 600,
          backgroundColor: 'rgba(10,10,10,0.85)', padding: [2, 6],
        },
      },
      {
        itemStyle: { borderColor: '#0a0a0a', borderWidth: 1, gapWidth: 1 },
        label: {
          show: true, formatter: leafLabel, rich: leafRich,
          color: '#fafafa', fontSize: large ? 11 : 9,
          fontFamily: "'JetBrains Mono', monospace",
          lineHeight: large ? 16 : 13, position: 'insideCenter', overflow: 'truncate',
        },
      },
    ];

    chart.setOption({
      tooltip: {
        backgroundColor: 'rgba(12,12,12,0.95)', borderColor: '#262626', borderRadius: 8,
        textStyle: { color: '#fafafa', fontSize: 11 },
        formatter: function(p) {
          if (p.data.whale) return whaleTip(p.data.whale);
          return '<b>' + p.name + '</b>';
        },
      },
      series: [{
        type: 'treemap',
        data: data,
        roam: isFlat ? 'zoomMove' : false,
        nodeClick: isFlat ? false : 'zoomToNode',
        width: '100%', height: '100%',
        squareRatio: 0.6,
        breadcrumb: {
          show: !isFlat && large,
          top: 4, left: 8,
          itemStyle: { color: '#1a1a1a', borderColor: '#262626' },
          textStyle: { color: '#737373', fontSize: 10 },
        },
        levels: levels,
      }],
    }, true);
  }

  // =================================================================
  // Render dispatch — panel + overlay share the same builders
  // =================================================================
  function renderWhaleView(chart, view, whales, markPx, large) {
    if (view === 'landscape') buildLandscape(chart, whales, markPx, large);
    else if (view === 'cascade') buildCascade(chart, whales, markPx, large);
    else buildTreemap(chart, whales, markPx, large);
    // Show/hide treemap options
    document.getElementById('whale-treemap-opts').style.display = (view === 'treemap') ? 'flex' : 'none';
  }

  // --- Fetch + render panel ---
  async function updateWhale() {
    const data = await api(B + '/api/data/whales/' + coin + '?top_n=' + whaleLimit());
    if (!data || data.error) {
      whaleChart.setOption({ title: { text: 'No whale data', left: 'center', top: 'center', textStyle: { color: '#262626', fontSize: 12 } }, series: [] }, true);
      whaleData = []; updateWhaleStats([]); return;
    }
    whaleData = parseWhales(data.positions);
    if (!whaleData.length) {
      whaleChart.setOption({ title: { text: 'No positions', left: 'center', top: 'center', textStyle: { color: '#262626', fontSize: 12 } }, series: [] }, true);
      updateWhaleStats([]); return;
    }
    const markPx = whaleData.find(w => w.mark > 0)?.mark || 0;
    updateWhaleStats(whaleData);
    renderWhaleView(whaleChart, whaleView, whaleData, markPx, false);
    const lC = whaleData.filter(w => w.side === 'long').length;
    document.getElementById('whale-badge').textContent = whaleData.length + ' \u00B7 ' + lC + 'L/' + (whaleData.length - lC) + 'S';
  }

  // --- Tab switching ---
  function setWhaleTab(tabsEl, view) {
    tabsEl.querySelectorAll('.whale-tab').forEach(t => t.classList.toggle('active', t.dataset.view === view));
  }
  document.getElementById('whale-view-tabs').addEventListener('click', e => {
    const btn = e.target.closest('.whale-tab'); if (!btn) return;
    whaleView = btn.dataset.view;
    setWhaleTab(document.getElementById('whale-view-tabs'), whaleView);
    if (whaleData.length) {
      const markPx = whaleData.find(w => w.mark > 0)?.mark || 0;
      renderWhaleView(whaleChart, whaleView, whaleData, markPx, false);
    }
  });
  document.getElementById('whale-limit').addEventListener('change', () => updateWhale());
  // Treemap option changes → re-render
  document.getElementById('whale-group').addEventListener('change', () => {
    if (whaleData.length) {
      const m = whaleData.find(w => w.mark > 0)?.mark || 0;
      if (whaleView === 'treemap') renderWhaleView(whaleChart, 'treemap', whaleData, m, false);
      if (whaleOverlayChart && whaleOverlayView === 'treemap') renderWhaleView(whaleOverlayChart, 'treemap', whaleData, m, true);
    }
  });
  document.getElementById('whale-size-metric').addEventListener('change', () => {
    if (whaleData.length) {
      const m = whaleData.find(w => w.mark > 0)?.mark || 0;
      if (whaleView === 'treemap') renderWhaleView(whaleChart, 'treemap', whaleData, m, false);
      if (whaleOverlayChart && whaleOverlayView === 'treemap') renderWhaleView(whaleOverlayChart, 'treemap', whaleData, m, true);
    }
  });
  document.getElementById('whale-overlay-tabs').addEventListener('click', e => {
    const btn = e.target.closest('.whale-tab'); if (!btn) return;
    whaleOverlayView = btn.dataset.view;
    setWhaleTab(document.getElementById('whale-overlay-tabs'), whaleOverlayView);
    if (whaleOverlayChart && whaleData.length) {
      const markPx = whaleData.find(w => w.mark > 0)?.mark || 0;
      renderWhaleView(whaleOverlayChart, whaleOverlayView, whaleData, markPx, true);
    }
  });

  // --- Explorer overlay ---
  async function openWhaleOverlay() {
    if (!whaleData.length) {
      const data = await api(B + '/api/data/whales/' + coin + '?top_n=' + whaleLimit());
      if (data && !data.error && data.positions) whaleData = parseWhales(data.positions);
    }
    if (!whaleData.length) return;
    document.getElementById('whale-overlay').style.display = 'block';
    whaleOverlayView = whaleView; // sync with panel view
    setWhaleTab(document.getElementById('whale-overlay-tabs'), whaleOverlayView);
    const el = document.getElementById('whale-overlay-chart');
    whaleOverlayChart = echarts.init(el, null, { renderer: 'canvas' });
    const markPx = whaleData.find(w => w.mark > 0)?.mark || 0;
    renderWhaleView(whaleOverlayChart, whaleOverlayView, whaleData, markPx, true);
    const lC = whaleData.filter(w => w.side === 'long').length, sC = whaleData.length - lC;
    const totalSz = whaleData.reduce((s, w) => s + w.size, 0);
    document.getElementById('whale-overlay-stats').textContent =
      whaleData.length + ' positions \u00B7 ' + lC + 'L/' + sC + 'S \u00B7 ' + $(totalSz) + ' \u00B7 Scroll to zoom';
    new ResizeObserver(() => whaleOverlayChart && whaleOverlayChart.resize()).observe(el);
  }

  function closeWhaleOverlay() {
    document.getElementById('whale-overlay').style.display = '';
    if (whaleOverlayChart) { whaleOverlayChart.dispose(); whaleOverlayChart = null; }
  }

  // =====================================================================
  // ORDER FLOW
  // =====================================================================
  let flowBuilt = false; // true after first render — enables DOM updates for CSS transitions

  async function updateFlow() {
    const data = await api(B + '/api/data/orderflow/' + coin);
    const el = document.getElementById('flow-panel');
    if (!data || data.error) { el.innerHTML = '<div class="empty">No order flow data</div>'; flowBuilt = false; return; }

    const w = data.windows || {};
    const tfs = ['1m', '5m', '15m', '1h'];
    let netCvd = 0;

    // First render: build DOM skeleton so subsequent updates can transition
    if (!flowBuilt || !el.querySelector('.flow-row')) {
      let html = '';
      tfs.forEach(tf => {
        const d = w[tf];
        if (!d) return;
        const bp = d.buy_pct || 50;
        const sp = 100 - bp;
        const cvd = d.cvd || 0;
        netCvd += cvd;
        const arrow = cvd >= 0 ? '\u2191' : '\u2193';
        const cls = cvd >= 0 ? 'pos' : 'neg';
        html += '<div class="flow-row" data-tf="' + tf + '">' +
          '<span class="flow-tf">' + tf + '</span>' +
          '<div class="flow-bar-wrap">' +
          '<div class="flow-buy" style="width:' + bp + '%">' + bp.toFixed(0) + '%</div>' +
          '<div class="flow-sell" style="width:' + sp + '%">' + sp.toFixed(0) + '%</div>' +
          '</div>' +
          '<span class="flow-cvd ' + cls + '">' + arrow + ' ' + $(Math.abs(cvd)) + '</span>' +
          '</div>';
      });
      const netCls = netCvd >= 0 ? 'pos' : 'neg';
      const netArrow = netCvd >= 0 ? '\u2191 Net Buy' : '\u2193 Net Sell';
      html += '<div class="flow-net" id="flow-net-row">' +
        '<span class="flow-net-label">Aggregate</span>' +
        '<span class="flow-cvd ' + netCls + '" id="flow-net-cvd" style="width:auto">' + netArrow + ' ' + $(Math.abs(netCvd)) + '</span>' +
        '</div>';
      el.innerHTML = html || '<div class="empty">No windows</div>';
      flowBuilt = true;
    } else {
      // Subsequent updates: modify existing DOM → CSS transitions fire smoothly
      tfs.forEach(tf => {
        const d = w[tf];
        if (!d) return;
        const bp = d.buy_pct || 50;
        const sp = 100 - bp;
        const cvd = d.cvd || 0;
        netCvd += cvd;
        const row = el.querySelector('[data-tf="' + tf + '"]');
        if (!row) return;
        const buyBar = row.querySelector('.flow-buy');
        const sellBar = row.querySelector('.flow-sell');
        const cvdEl = row.querySelector('.flow-cvd');
        if (buyBar) { buyBar.style.width = bp + '%'; buyBar.textContent = bp.toFixed(0) + '%'; }
        if (sellBar) { sellBar.style.width = sp + '%'; sellBar.textContent = sp.toFixed(0) + '%'; }
        if (cvdEl) {
          const arrow = cvd >= 0 ? '\u2191' : '\u2193';
          const oldText = cvdEl.textContent;
          const newText = arrow + ' ' + $(Math.abs(cvd));
          cvdEl.className = 'flow-cvd ' + (cvd >= 0 ? 'pos' : 'neg');
          if (oldText !== newText) {
            cvdEl.textContent = newText;
            cvdEl.classList.add('flash');
            setTimeout(() => cvdEl.classList.remove('flash'), 400);
          }
        }
      });
      // Update aggregate
      const netEl = document.getElementById('flow-net-cvd');
      if (netEl) {
        const netArrow = netCvd >= 0 ? '\u2191 Net Buy' : '\u2193 Net Sell';
        const oldNet = netEl.textContent;
        const newNet = netArrow + ' ' + $(Math.abs(netCvd));
        netEl.className = 'flow-cvd ' + (netCvd >= 0 ? 'pos' : 'neg');
        if (oldNet !== newNet) {
          netEl.textContent = newNet;
          netEl.classList.add('flash');
          setTimeout(() => netEl.classList.remove('flash'), 400);
        }
      }
    }
    document.getElementById('flow-badge').textContent = Object.keys(w).length + ' windows';
  }

  // =====================================================================
  // SMART MONEY
  // =====================================================================
  async function updateSM() {
    const data = await api(B + '/api/data/smart-money?top_n=20');
    const el = document.getElementById('sm-panel');
    if (!data || data.error || !(data.traders || []).length) { el.innerHTML = '<div class="empty">No smart money data</div>'; return; }

    const t = data.traders;
    let html = '<table class="data-table"><thead><tr><th>#</th><th>Address</th><th>PnL 24h</th><th>Equity</th><th>Pos</th></tr></thead><tbody>';
    t.forEach((tr, i) => {
      const pnl = tr.pnl_24h || 0;
      const c = pnl >= 0 ? '#22c55e' : '#ef4444';
      const s = pnl >= 0 ? '+' : '';
      html += '<tr><td style="color:#525252">' + (i+1) + '</td><td>' + addr(tr.address) + '</td>' +
        '<td style="color:' + c + '">' + s + $(pnl) + '</td>' +
        '<td>' + $(tr.equity || 0) + '</td><td>' + (tr.positions || 0) + '</td></tr>';
    });
    html += '</tbody></table>';
    el.innerHTML = html;
    document.getElementById('sm-badge').textContent = t.length + ' traders';
  }

  // =====================================================================
  // HLP VAULT — with PnL column
  // =====================================================================
  async function updateHLP() {
    if (hlpCollapsed) return;
    const data = await api(B + '/api/data/hlp/positions');
    const el = document.getElementById('hlp-panel');
    if (!data || data.error || !(data.positions || []).length) { el.innerHTML = '<div class="empty">No HLP positions</div>'; return; }

    const pos = data.positions;
    const maxSz = Math.max(...pos.map(p => p.size_usd || 0), 1);

    let html = '<table class="data-table"><thead><tr>' +
      '<th>Coin</th><th>Side</th><th>Size</th><th style="width:100px"></th><th>Lev</th><th>Entry</th><th>PnL</th>' +
      '</tr></thead><tbody>';

    pos.forEach(p => {
      const side = (p.side || 'long').toLowerCase();
      const sz = p.size_usd || 0;
      const barW = Math.max(4, (sz / maxSz) * 100);
      const pnl = p.pnl_usd || p.unrealized_pnl || 0;
      const pnlPct = p.return_pct || p.pnl_pct || 0;
      const pnlC = pnl >= 0 ? '#22c55e' : '#ef4444';
      const entry = p.entry_px || 0;
      const eStr = entry >= 1 ? '$' + entry.toLocaleString(undefined,{maximumFractionDigits:2}) : entry > 0 ? '$' + entry.toFixed(4) : '-';
      const pnlStr = pnl !== 0 ? (pnl >= 0 ? '+' : '') + $(pnl) + (pnlPct ? ' (' + pnlPct.toFixed(1) + '%)' : '') : '-';

      html += '<tr>' +
        '<td style="color:#e5e5e5;font-weight:500">' + (p.coin || '?') + '</td>' +
        '<td><span class="side-dot ' + side + '"></span>' + side.toUpperCase() + '</td>' +
        '<td>' + $(sz) + '</td>' +
        '<td><span class="bar-fill" style="width:' + barW + '%"></span></td>' +
        '<td>' + (p.leverage || 1).toFixed(0) + 'x</td>' +
        '<td>' + eStr + '</td>' +
        '<td style="color:' + pnlC + '">' + pnlStr + '</td>' +
        '</tr>';
    });

    html += '</tbody></table>';
    el.innerHTML = html;
    document.getElementById('hlp-badge').textContent = pos.length + ' positions';
  }

  // =====================================================================
  // STATS BAR
  // =====================================================================
  async function updateStats() {
    const h = await api(B + '/api/data-health');
    const dot = document.getElementById('ws-dot');
    const status = document.getElementById('stat-status');

    if (!h || h.error) {
      dot.className = 'stat-dot off'; status.textContent = 'offline'; return;
    }
    dot.className = 'stat-dot on'; status.textContent = 'online';

    // /health for positions + uptime, /stats for total wallets (nested field)
    const pos = h.positions_tracked || 0;
    document.getElementById('stat-positions').textContent = pos ? pos.toLocaleString() : '-';
    const up = h.uptime_seconds ? (h.uptime_seconds / 3600).toFixed(1) + 'h' : '-';
    document.getElementById('stat-uptime').textContent = up;

    const s = await api(B + '/api/data/stats');
    if (s && !s.error) {
      const wallets = (s.trade_stream && s.trade_stream.total_addresses_discovered) || 0;
      document.getElementById('stat-wallets').textContent = wallets ? wallets.toLocaleString() : '-';
    }
    document.getElementById('stat-updated').textContent = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
  }

  // =====================================================================
  // LIVE PRICE TICKER — 3s fast tick drives price lines on all charts
  // =====================================================================
  let livePrice = 0;

  async function tickPrice() {
    const c = await api(B + '/api/candles?symbol=' + coin + '&interval=1m&hours=0.05');
    if (!c || !c.length) return;
    const p = c[c.length - 1].c;
    if (p === livePrice) return;
    livePrice = p;
    // Update header badge
    const fmtP = p >= 1 ? '$' + p.toLocaleString(undefined, {maximumFractionDigits: 2}) : '$' + p.toFixed(4);
    document.getElementById('price-badge').textContent = coin + ' ' + fmtP;
    // Slide price lines on heatmap + landscape
    updateHeatmapPrice(p);
    updateLandscapePrice(p);
  }

  // =====================================================================
  // ORCHESTRATION
  // =====================================================================
  function refreshAll() { updatePrice(); updateHeatmap(); updateWhale(); updateFlow(); updateSM(); updateHLP(); updateStats(); }

  // Whale explorer expand/close
  document.getElementById('whale-expand').addEventListener('click', openWhaleOverlay);
  document.getElementById('whale-close').addEventListener('click', closeWhaleOverlay);
  document.addEventListener('keydown', e => {
    if (e.key === 'Escape' && document.getElementById('whale-overlay').style.display === 'block') closeWhaleOverlay();
  });

  initPrice(); initHeatmap(); initWhale();
  refreshAll();

  // Fast tick: price line slides on heatmap + landscape every 3s
  setInterval(() => { if (vis()) tickPrice(); }, 3000);
  // Price chart + order flow: 10s
  setInterval(() => { if (vis()) { updatePrice(); updateFlow(); } }, 10000);
  // Heatmap + whales: 30s
  setInterval(() => { if (!vis()) return; updateHeatmap(); updateWhale(); }, 30000);
  // Smart money + HLP + stats: 60s
  setInterval(() => { if (!vis()) return; updateSM(); updateHLP(); updateStats(); }, 60000);
})();
</script>
</body>
</html>
