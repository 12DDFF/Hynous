<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hynous Data Intelligence</title>
<script src="https://unpkg.com/lightweight-charts@4/dist/lightweight-charts.standalone.production.js"></script>
<script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0a0a;
    color: #fafafa;
    font-family: Inter, system-ui, sans-serif;
    overflow-x: hidden;
  }
  ::-webkit-scrollbar { width: 4px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: #262626; border-radius: 4px; }

  /* Header */
  .header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 10px 20px;
    border-bottom: 1px solid #1a1a1a;
    background: #0a0a0a;
    position: sticky; top: 0; z-index: 10;
  }
  .header-left { display: flex; align-items: center; gap: 12px; }
  .header-title { font-size: 0.95rem; font-weight: 600; }
  .header-subtitle { font-size: 0.7rem; color: #525252; }

  /* Coin Tabs */
  .coin-tabs {
    display: flex; gap: 2px; padding: 3px;
    background: #0f0f0f; border-radius: 8px; border: 1px solid #1a1a1a;
  }
  .coin-tab {
    padding: 5px 14px; border-radius: 6px; border: none;
    background: transparent; color: #525252;
    font-size: 0.78rem; font-weight: 500; cursor: pointer;
    transition: all 0.15s; font-family: inherit;
  }
  .coin-tab:hover { background: #1a1a1a; color: #a3a3a3; }
  .coin-tab.active { background: #1a1a1a; color: #fafafa; }

  /* Stats Bar */
  .stats-bar {
    display: flex; gap: 20px; padding: 6px 20px;
    border-bottom: 1px solid #141414; font-size: 0.68rem;
  }
  .stat-item { display: flex; align-items: center; gap: 5px; color: #404040; }
  .stat-dot { width: 5px; height: 5px; border-radius: 50%; }
  .stat-dot.on { background: #22c55e; box-shadow: 0 0 4px #22c55e; }
  .stat-dot.off { background: #ef4444; }
  .stat-dot.wait { background: #eab308; }
  .stat-val { color: #737373; font-family: 'JetBrains Mono', monospace; }

  /* Panel Grid */
  .grid {
    display: grid; grid-template-columns: 1fr 1fr;
    gap: 10px; padding: 12px;
  }
  .panel {
    background: #0c0c0c; border: 1px solid #141414;
    border-radius: 8px; overflow: hidden; min-height: 260px;
  }
  .panel.full { grid-column: 1 / -1; }
  .panel-hdr {
    display: flex; align-items: center; justify-content: space-between;
    padding: 8px 12px; border-bottom: 1px solid #141414;
  }
  .panel-title {
    font-size: 0.72rem; font-weight: 600; color: #737373;
    text-transform: uppercase; letter-spacing: 0.05em;
  }
  .panel-badge {
    font-size: 0.62rem; color: #404040;
    font-family: 'JetBrains Mono', monospace;
  }
  .panel-body { padding: 0; height: calc(100% - 36px); position: relative; }
  .panel-body.padded { padding: 10px; }

  /* Tooltip */
  .lw-tooltip {
    position: absolute; display: none; pointer-events: none; z-index: 20;
    background: rgba(12,12,12,0.95); border: 1px solid #262626;
    border-radius: 6px; padding: 6px 10px;
    font-size: 0.72rem; color: #fafafa;
    backdrop-filter: blur(8px); white-space: nowrap;
  }
  .lw-tooltip .tt-time { color: #525252; font-size: 0.62rem; margin-bottom: 2px; }
  .lw-tooltip .tt-price { font-family: 'JetBrains Mono', monospace; font-weight: 600; font-size: 0.82rem; }

  /* Order Flow */
  .flow-row { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
  .flow-tf {
    font-size: 0.68rem; color: #525252; width: 28px; text-align: right;
    font-family: 'JetBrains Mono', monospace; flex-shrink: 0;
  }
  .flow-bar-wrap { flex: 1; height: 26px; display: flex; border-radius: 4px; overflow: hidden; }
  .flow-buy {
    background: linear-gradient(90deg, #14532d, #22c55e);
    display: flex; align-items: center; justify-content: center;
    font-size: 0.6rem; color: #fff; font-weight: 500; min-width: 28px;
  }
  .flow-sell {
    background: linear-gradient(90deg, #ef4444, #7f1d1d);
    display: flex; align-items: center; justify-content: center;
    font-size: 0.6rem; color: #fff; font-weight: 500; min-width: 28px;
  }
  .flow-cvd {
    font-size: 0.68rem; font-family: 'JetBrains Mono', monospace;
    width: 80px; text-align: right; flex-shrink: 0;
  }
  .flow-cvd.pos { color: #22c55e; }
  .flow-cvd.neg { color: #ef4444; }
  .flow-net {
    margin-top: 10px; padding: 8px 10px;
    background: #111; border-radius: 6px;
    display: flex; justify-content: space-between; align-items: center;
    font-size: 0.72rem;
  }
  .flow-net-label { color: #525252; font-weight: 500; }

  /* Tables */
  .data-table { width: 100%; border-collapse: collapse; font-size: 0.7rem; }
  .data-table th {
    text-align: left; padding: 6px 8px; color: #404040; font-weight: 500;
    text-transform: uppercase; letter-spacing: 0.04em; font-size: 0.6rem;
    border-bottom: 1px solid #1a1a1a; position: sticky; top: 0; background: #0c0c0c;
  }
  .data-table td {
    padding: 5px 8px; color: #a3a3a3; border-bottom: 1px solid #0f0f0f;
    font-family: 'JetBrains Mono', monospace;
  }
  .data-table tr:hover td { background: #0f0f0f; }
  .side-dot {
    display: inline-block; width: 6px; height: 6px;
    border-radius: 50%; margin-right: 5px; vertical-align: middle;
  }
  .side-dot.long { background: #22c55e; }
  .side-dot.short { background: #ef4444; }
  .bar-fill {
    display: inline-block; height: 3px; border-radius: 2px;
    background: #6366f1; opacity: 0.5;
  }

  /* Collapsible */
  .collapse-btn {
    background: none; border: none; color: #525252; cursor: pointer;
    font-size: 0.62rem; padding: 2px 6px; border-radius: 4px;
    font-family: inherit;
  }
  .collapse-btn:hover { color: #a3a3a3; background: #1a1a1a; }

  .empty { display: flex; align-items: center; justify-content: center; height: 100%; color: #262626; font-size: 0.78rem; }

  /* Whale Explorer Overlay */
  .whale-overlay {
    position: fixed; inset: 0; z-index: 1000;
    background: #0a0a0a; display: none;
  }
  .whale-overlay-hdr {
    display: flex; align-items: center; justify-content: space-between;
    padding: 10px 20px; border-bottom: 1px solid #1a1a1a;
  }
  .whale-overlay-hdr .title { font-size: 0.95rem; font-weight: 600; }
  .whale-overlay-hdr .subtitle { font-size: 0.7rem; color: #525252; margin-left: 12px; }
  .whale-overlay-close {
    background: none; border: 1px solid #262626; color: #737373;
    cursor: pointer; padding: 4px 14px; border-radius: 6px;
    font-family: inherit; font-size: 0.72rem; transition: all 0.15s;
  }
  .whale-overlay-close:hover { color: #fafafa; border-color: #404040; }
  .whale-overlay-chart { position: absolute; top: 46px; left: 0; right: 0; bottom: 0; }
</style>
</head>
<body>
  <!-- Header -->
  <div class="header">
    <div class="header-left">
      <span class="header-title">Data Intelligence</span>
      <span class="header-subtitle">Liquidations, order flow, whales, smart money</span>
    </div>
    <div class="coin-tabs" id="coin-tabs">
      <button class="coin-tab active" data-coin="BTC">BTC</button>
      <button class="coin-tab" data-coin="ETH">ETH</button>
      <button class="coin-tab" data-coin="SOL">SOL</button>
    </div>
  </div>

  <!-- Stats Bar -->
  <div class="stats-bar">
    <div class="stat-item"><div class="stat-dot wait" id="ws-dot"></div><span>Data Layer</span><span class="stat-val" id="stat-status">connecting</span></div>
    <div class="stat-item"><span>Wallets</span><span class="stat-val" id="stat-wallets">-</span></div>
    <div class="stat-item"><span>Positions</span><span class="stat-val" id="stat-positions">-</span></div>
    <div class="stat-item"><span>Uptime</span><span class="stat-val" id="stat-uptime">-</span></div>
    <div class="stat-item"><span>Last Update</span><span class="stat-val" id="stat-updated">-</span></div>
  </div>

  <!-- Panels -->
  <div class="grid">
    <!-- Price chart -->
    <div class="panel full">
      <div class="panel-hdr">
        <span class="panel-title">Price</span>
        <span class="panel-badge" id="price-badge">loading</span>
      </div>
      <div class="panel-body" id="price-wrap" style="height:300px">
        <div class="lw-tooltip" id="price-tooltip"></div>
      </div>
    </div>

    <!-- Heatmap -->
    <div class="panel">
      <div class="panel-hdr">
        <span class="panel-title">Liquidation Heatmap</span>
        <span class="panel-badge" id="hm-badge"></span>
      </div>
      <div class="panel-body" id="hm-panel"></div>
    </div>

    <!-- Whales -->
    <div class="panel">
      <div class="panel-hdr">
        <span class="panel-title">Whale Positions</span>
        <div style="display:flex;align-items:center;gap:8px">
          <span class="panel-badge" id="whale-badge"></span>
          <button class="collapse-btn" id="whale-expand">Explore</button>
        </div>
      </div>
      <div class="panel-body" id="whale-panel"></div>
    </div>

    <!-- Order Flow -->
    <div class="panel">
      <div class="panel-hdr">
        <span class="panel-title">Order Flow</span>
        <span class="panel-badge" id="flow-badge"></span>
      </div>
      <div class="panel-body padded" id="flow-panel"><div class="empty">Waiting for data</div></div>
    </div>

    <!-- Smart Money -->
    <div class="panel">
      <div class="panel-hdr">
        <span class="panel-title">Smart Money</span>
        <span class="panel-badge" id="sm-badge"></span>
      </div>
      <div class="panel-body" id="sm-panel" style="overflow-y:auto"><div class="empty">Waiting for data</div></div>
    </div>

    <!-- HLP -->
    <div class="panel full">
      <div class="panel-hdr">
        <span class="panel-title">HLP Vault Positions</span>
        <div style="display:flex;align-items:center;gap:8px">
          <span class="panel-badge" id="hlp-badge"></span>
          <button class="collapse-btn" id="hlp-toggle">Collapse</button>
        </div>
      </div>
      <div class="panel-body" id="hlp-panel" style="overflow-y:auto;min-height:80px"><div class="empty">Waiting for data</div></div>
    </div>
  </div>

<!-- Whale Explorer Overlay -->
<div class="whale-overlay" id="whale-overlay">
  <div class="whale-overlay-hdr">
    <div style="display:flex;align-items:center">
      <span class="title">Whale Explorer</span>
      <span class="subtitle" id="whale-overlay-stats"></span>
    </div>
    <button class="whale-overlay-close" id="whale-close">Close</button>
  </div>
  <div class="whale-overlay-chart" id="whale-overlay-chart"></div>
</div>

<script>
(function() {
  'use strict';

  const B = location.origin.replace(':3000', ':8000');
  let coin = 'BTC';
  let hlpCollapsed = false;

  // --- Tab switching ---
  document.getElementById('coin-tabs').addEventListener('click', e => {
    const btn = e.target.closest('.coin-tab');
    if (!btn) return;
    document.querySelectorAll('.coin-tab').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    coin = btn.dataset.coin;
    refreshAll();
  });

  // --- HLP collapse ---
  document.getElementById('hlp-toggle').addEventListener('click', function() {
    hlpCollapsed = !hlpCollapsed;
    this.textContent = hlpCollapsed ? 'Expand' : 'Collapse';
    document.getElementById('hlp-panel').style.display = hlpCollapsed ? 'none' : '';
  });

  // --- Helpers ---
  async function api(url) {
    try { const r = await fetch(url); if (!r.ok) return null; return await r.json(); }
    catch { return null; }
  }
  function $(n) { return (Math.abs(n) >= 1e6) ? '$' + (n/1e6).toFixed(1) + 'M' : (Math.abs(n) >= 1e3) ? '$' + (n/1e3).toFixed(1) + 'K' : '$' + n.toFixed(0); }
  function addr(a) { return (!a || a.length < 10) ? (a||'?') : a.slice(0,6) + '\u2026' + a.slice(-4); }
  function vis() { return !document.hidden; }

  // =====================================================================
  // PRICE CHART — Polymarket-style area chart
  // =====================================================================
  let chart, series;

  function initPrice() {
    const el = document.getElementById('price-wrap');
    chart = LightweightCharts.createChart(el, {
      width: el.clientWidth, height: el.clientHeight,
      layout: { background: { color: '#0c0c0c' }, textColor: 'rgba(255,255,255,0.3)', fontSize: 10, fontFamily: "'JetBrains Mono', monospace" },
      grid: { vertLines: { visible: false }, horzLines: { visible: false } },
      crosshair: {
        mode: 0,
        vertLine: { color: 'rgba(255,255,255,0.12)', width: 1, style: 0, labelVisible: false },
        horzLine: { visible: false, labelVisible: false },
      },
      rightPriceScale: { borderVisible: false, scaleMargins: { top: 0.08, bottom: 0.15 } },
      timeScale: { borderVisible: false, timeVisible: true, secondsVisible: false, rightOffset: 3 },
      handleScroll: { mouseWheel: true, pressedMouseMove: true },
      handleScale: { mouseWheel: true, pinch: true },
    });

    series = chart.addAreaSeries({
      lineColor: '#6366f1', lineWidth: 2,
      topColor: 'rgba(99,102,241,0.25)', bottomColor: 'rgba(99,102,241,0)',
      crosshairMarkerVisible: true,
      crosshairMarkerRadius: 4,
      crosshairMarkerBorderColor: '#6366f1',
      crosshairMarkerBackgroundColor: '#6366f1',
      crosshairMarkerBorderWidth: 0,
      priceLineVisible: false,
      lastValueVisible: true,
    });

    // Floating tooltip
    const tip = document.getElementById('price-tooltip');
    chart.subscribeCrosshairMove(param => {
      if (!param.point || !param.time || param.point.x < 0 || param.point.y < 0) {
        tip.style.display = 'none'; return;
      }
      const d = param.seriesData.get(series);
      if (!d) { tip.style.display = 'none'; return; }
      const px = d.value !== undefined ? d.value : d.close;
      const dt = new Date(param.time * 1000);
      const ts = dt.toLocaleString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
      const fmtPx = px >= 1 ? '$' + px.toLocaleString(undefined, {maximumFractionDigits: 2}) : '$' + px.toFixed(4);
      tip.innerHTML = '<div class="tt-time">' + ts + '</div><div class="tt-price" style="color:#6366f1">' + fmtPx + '</div>';
      let left = param.point.x;
      const tw = tip.offsetWidth || 100;
      if (left + tw/2 > el.clientWidth) left = el.clientWidth - tw/2;
      if (left - tw/2 < 0) left = tw/2;
      tip.style.left = left + 'px';
      tip.style.top = Math.max(0, param.point.y - 48) + 'px';
      tip.style.transform = 'translateX(-50%)';
      tip.style.display = 'block';
    });

    new ResizeObserver(() => chart.applyOptions({ width: el.clientWidth, height: el.clientHeight })).observe(el);
  }

  async function updatePrice() {
    const candles = await api(B + '/api/candles?symbol=' + coin + '&interval=5m&hours=48');
    if (!candles || candles.error || !Array.isArray(candles) || !candles.length) {
      document.getElementById('price-badge').textContent = 'no data'; return;
    }
    series.setData(candles.map(c => ({ time: Math.floor(c.t/1000), value: c.c })));
    const last = candles[candles.length-1];
    const px = last.c >= 1 ? '$' + last.c.toLocaleString(undefined,{maximumFractionDigits:2}) : '$' + last.c.toFixed(4);
    document.getElementById('price-badge').textContent = coin + ' ' + px;
  }

  // =====================================================================
  // LIQUIDATION HEATMAP — Coinglass-inspired vertical heatmap
  // =====================================================================
  let hmChart;

  function initHeatmap() {
    hmChart = echarts.init(document.getElementById('hm-panel'), null, { renderer: 'canvas' });
    new ResizeObserver(() => hmChart.resize()).observe(document.getElementById('hm-panel'));
  }

  async function updateHeatmap() {
    const data = await api(B + '/api/data/heatmap/' + coin);
    if (!data || data.error || !data.buckets || !data.buckets.length) {
      hmChart.setOption({ title: { text: 'No heatmap data', left: 'center', top: 'center', textStyle: { color: '#262626', fontSize: 12 } }, series: [] });
      return;
    }

    const buckets = data.buckets;
    const mid = data.mid_price || 0;

    // Build vertical bar-style heatmap — each bucket is a horizontal bar
    // Y = price level, bar width = liquidation magnitude, color = long (green) / short (red)
    const prices = buckets.map(b => {
      const p = b.price_mid;
      return p >= 1000 ? '$' + (p/1000).toFixed(1) + 'K' : p >= 1 ? '$' + p.toFixed(0) : '$' + p.toFixed(4);
    });
    const longVals = buckets.map(b => b.long_liq_usd || 0);
    const shortVals = buckets.map(b => -(b.short_liq_usd || 0)); // negative for left side
    const maxVal = Math.max(...buckets.map(b => Math.max(b.long_liq_usd || 0, b.short_liq_usd || 0)), 1);

    // Find current price index for markLine
    let midIdx = 0;
    let minDist = Infinity;
    buckets.forEach((b, i) => { const d = Math.abs(b.price_mid - mid); if (d < minDist) { minDist = d; midIdx = i; } });

    hmChart.setOption({
      title: null,
      tooltip: {
        trigger: 'axis', axisPointer: { type: 'shadow' },
        backgroundColor: 'rgba(12,12,12,0.95)', borderColor: '#262626', textStyle: { color: '#fafafa', fontSize: 11 },
        formatter: function(params) {
          const idx = params[0].dataIndex;
          const b = buckets[idx];
          const p = b.price_mid;
          const pStr = p >= 1 ? '$' + p.toLocaleString(undefined,{maximumFractionDigits:0}) : '$' + p.toFixed(4);
          return '<div style="font-size:11px;color:#737373;margin-bottom:4px">' + pStr + '</div>' +
            '<div style="color:#22c55e">Long Liqs: <b>' + $(b.long_liq_usd || 0) + '</b></div>' +
            '<div style="color:#ef4444">Short Liqs: <b>' + $(b.short_liq_usd || 0) + '</b></div>';
        }
      },
      grid: { left: 60, right: 16, top: 8, bottom: 24 },
      xAxis: {
        type: 'value',
        axisLine: { show: false }, axisTick: { show: false },
        axisLabel: { color: '#404040', fontSize: 9, formatter: function(v) { return $(Math.abs(v)); } },
        splitLine: { lineStyle: { color: '#141414' } },
      },
      yAxis: {
        type: 'category', data: prices,
        axisLine: { lineStyle: { color: '#1a1a1a' } },
        axisTick: { show: false },
        axisLabel: { color: '#525252', fontSize: 8 },
      },
      series: [
        {
          name: 'Long', type: 'bar', stack: 'liq', data: longVals,
          itemStyle: {
            color: function(p) {
              const ratio = Math.min(1, (p.value || 0) / maxVal);
              const r = Math.round(34 + ratio * 0), g = Math.round(80 + ratio * 117), b_ = Math.round(50 + ratio * 44);
              return 'rgb(' + r + ',' + g + ',' + b_ + ')';
            },
            borderRadius: [0, 3, 3, 0],
          },
          barMaxWidth: 12,
        },
        {
          name: 'Short', type: 'bar', stack: 'liq', data: shortVals,
          itemStyle: {
            color: function(p) {
              const ratio = Math.min(1, Math.abs(p.value || 0) / maxVal);
              const r = Math.round(127 + ratio * 112), g = Math.round(29 + ratio * 0), b_ = Math.round(29 + ratio * 0);
              return 'rgb(' + r + ',' + g + ',' + b_ + ')';
            },
            borderRadius: [3, 0, 0, 3],
          },
          barMaxWidth: 12,
        },
      ],
    });

    // Add current price markLine
    if (mid > 0) {
      hmChart.setOption({ yAxis: { axisPointer: { show: false } },
        series: [{ markLine: { silent: true, symbol: 'none',
          data: [{ yAxis: midIdx, lineStyle: { color: '#6366f1', width: 1.5, type: 'dashed' },
            label: { show: true, formatter: 'Price', color: '#6366f1', fontSize: 9, position: 'end' } }],
        }}]
      });
    }

    document.getElementById('hm-badge').textContent = buckets.length + ' levels';
  }

  // =====================================================================
  // WHALE POSITIONS — Clustered scatter with expandable explorer
  // =====================================================================
  let whaleChart;
  let whaleData = []; // parsed positions kept for expand view

  function initWhale() {
    whaleChart = echarts.init(document.getElementById('whale-panel'), null, { renderer: 'canvas' });
    new ResizeObserver(() => whaleChart.resize()).observe(document.getElementById('whale-panel'));
  }

  // --- Parse raw API positions into clean objects ---
  function parseWhales(raw) {
    return (raw || []).map(p => ({
      size: Math.abs(p.size_usd || p.notional_usd || p.sz_usd || 0),
      pnl: p.pnl_usd || p.unrealized_pnl || 0,
      entry: p.entry_px || p.entry_price || p.avg_entry || 0,
      lev: p.leverage || p.lev || 1,
      side: ((p.side || '').toLowerCase().startsWith('l') || (p.side || '').toLowerCase() === 'buy') ? 'long' : 'short',
      address: p.address || p.addr || '',
      liq: p.liq_px || 0,
    })).filter(p => p.size > 0);
  }

  // --- Grid-based clustering: merge nearby whales ---
  function clusterWhales(whales, gx, gy) {
    if (!whales.length) return [];
    const pnls = whales.map(w => w.pnl), sizes = whales.map(w => w.size);
    const pMin = Math.min(...pnls), pMax = Math.max(...pnls);
    const sMin = Math.min(...sizes), sMax = Math.max(...sizes);
    const pRange = pMax - pMin || 1, sRange = sMax - sMin || 1;
    const cells = {};
    whales.forEach(w => {
      const cx = Math.min(gx - 1, Math.floor((w.pnl - pMin) / pRange * gx));
      const cy = Math.min(gy - 1, Math.floor((w.size - sMin) / sRange * gy));
      const k = cx + '_' + cy;
      if (!cells[k]) cells[k] = [];
      cells[k].push(w);
    });
    return Object.values(cells).map(ws => {
      const longs = ws.filter(w => w.side === 'long').length;
      const totalSz = ws.reduce((s, w) => s + w.size, 0);
      return {
        pnl: ws.reduce((s, w) => s + w.pnl, 0) / ws.length,
        size: totalSz / ws.length,
        totalSize: totalSz,
        count: ws.length,
        longs: longs, shorts: ws.length - longs,
        maxPnl: Math.max(...ws.map(w => w.pnl)),
        minPnl: Math.min(...ws.map(w => w.pnl)),
        whales: ws.sort((a, b) => b.size - a.size),
      };
    });
  }

  // --- Cluster colors based on dominant side ---
  function cColor(c) {
    if (c.count === 1) return c.longs ? 'rgba(34,197,94,0.45)' : 'rgba(239,68,68,0.45)';
    const r = c.longs / c.count;
    return r > 0.65 ? 'rgba(34,197,94,0.4)' : r < 0.35 ? 'rgba(239,68,68,0.4)' : 'rgba(99,102,241,0.4)';
  }
  function cBorder(c) {
    if (c.count === 1) return c.longs ? '#22c55e' : '#ef4444';
    const r = c.longs / c.count;
    return r > 0.65 ? '#22c55e' : r < 0.35 ? '#ef4444' : '#6366f1';
  }

  // --- Rich tooltip for clusters ---
  function cTip(c) {
    let h = '<div style="min-width:180px">';
    if (c.count === 1) {
      const w = c.whales[0], pC = w.pnl >= 0 ? '#22c55e' : '#ef4444';
      h += '<div style="font-size:12px;font-weight:600;margin-bottom:4px">' + addr(w.address) + '</div>';
      h += '<div style="font-size:11px;color:#a3a3a3">Size: <b>' + $(w.size) + '</b> (' + w.lev + 'x)</div>';
      h += '<div style="font-size:11px;color:#a3a3a3">Entry: <b>$' + (w.entry >= 1 ? w.entry.toLocaleString(undefined,{maximumFractionDigits:2}) : w.entry.toFixed(4)) + '</b></div>';
      h += '<div style="font-size:11px;color:' + pC + '">PnL: <b>' + (w.pnl >= 0 ? '+' : '') + $(w.pnl) + '</b></div>';
      h += '<div style="font-size:10px;color:#525252;margin-top:2px">' + (w.side === 'long' ? 'Long' : 'Short') + '</div>';
    } else {
      h += '<div style="font-size:13px;font-weight:600;margin-bottom:6px">' + c.count + ' whale' + (c.count > 1 ? 's' : '') + '</div>';
      h += '<div style="font-size:11px"><span style="color:#22c55e">Long: ' + c.longs + '</span> &middot; <span style="color:#ef4444">Short: ' + c.shorts + '</span></div>';
      h += '<div style="font-size:11px;color:#737373;margin-top:4px">Total Size: ' + $(c.totalSize) + '</div>';
      h += '<div style="font-size:11px;color:#737373">Avg PnL: ' + (c.pnl >= 0 ? '+' : '') + $(c.pnl) + '</div>';
      if (c.minPnl !== c.maxPnl) h += '<div style="font-size:10px;color:#525252">PnL Range: ' + $(c.minPnl) + ' to ' + $(c.maxPnl) + '</div>';
      const top = c.whales.slice(0, 5);
      h += '<div style="border-top:1px solid #262626;margin-top:6px;padding-top:6px;font-size:10px">';
      top.forEach(w => {
        const pC = w.pnl >= 0 ? '#22c55e' : '#ef4444';
        h += '<div style="color:#737373;margin-bottom:2px">' + addr(w.address) + ' ' + $(w.size) + ' <span style="color:' + pC + '">' + (w.pnl >= 0 ? '+' : '') + $(w.pnl) + '</span></div>';
      });
      if (c.whales.length > 5) h += '<div style="color:#404040">+' + (c.whales.length - 5) + ' more</div>';
      h += '</div>';
    }
    return h + '</div>';
  }

  // --- Panel view: clustered scatter ---
  async function updateWhale() {
    const data = await api(B + '/api/data/whales/' + coin + '?top_n=2000');
    if (!data || data.error) {
      whaleChart.setOption({ title: { text: 'No whale data', left: 'center', top: 'center', textStyle: { color: '#262626', fontSize: 12 } }, series: [] });
      whaleData = []; return;
    }
    whaleData = parseWhales(data.positions);
    if (!whaleData.length) {
      whaleChart.setOption({ title: { text: 'No positions', left: 'center', top: 'center', textStyle: { color: '#262626', fontSize: 12 } }, series: [] });
      return;
    }

    // Cluster into ~20x15 grid cells → max ~300 cluster bubbles
    const clusters = clusterWhales(whaleData, 20, 15);
    const maxClusterSz = Math.max(...clusters.map(c => c.totalSize), 1);

    const points = clusters.map(c => ({
      value: [c.pnl, c.size],
      symbolSize: c.count === 1
        ? Math.max(8, (c.totalSize / maxClusterSz) * 30)
        : Math.max(18, Math.min(55, Math.sqrt(c.count) * 12)),
      itemStyle: { color: cColor(c), borderColor: cBorder(c), borderWidth: c.count > 1 ? 2 : 1 },
      label: {
        show: c.count > 1,
        formatter: String(c.count),
        fontSize: c.count >= 100 ? 11 : c.count >= 10 ? 10 : 9,
        color: '#fafafa', fontWeight: 600, position: 'inside',
      },
      cluster: c,
    }));

    whaleChart.setOption({
      title: null,
      tooltip: {
        trigger: 'item', confine: true,
        backgroundColor: 'rgba(12,12,12,0.95)', borderColor: '#262626', borderRadius: 8,
        textStyle: { color: '#fafafa', fontSize: 11 },
        formatter: p => p.data.cluster ? cTip(p.data.cluster) : '',
        extraCssText: 'max-height:280px;overflow-y:auto;',
      },
      grid: { left: 60, right: 16, top: 10, bottom: 32 },
      xAxis: {
        name: 'PnL', nameLocation: 'center', nameGap: 20,
        nameTextStyle: { color: '#404040', fontSize: 10 },
        axisLine: { lineStyle: { color: '#1a1a1a' } },
        axisLabel: { color: '#525252', fontSize: 9, formatter: v => $(v) },
        splitLine: { lineStyle: { color: '#141414' } },
      },
      yAxis: {
        name: 'Size', nameLocation: 'center', nameGap: 44,
        nameTextStyle: { color: '#404040', fontSize: 10 },
        axisLine: { lineStyle: { color: '#1a1a1a' } },
        axisLabel: { color: '#525252', fontSize: 9, formatter: v => $(v) },
        splitLine: { lineStyle: { color: '#141414' } },
      },
      series: [{ type: 'scatter', data: points }],
    });

    const longCount = whaleData.filter(w => w.side === 'long').length;
    document.getElementById('whale-badge').textContent = whaleData.length + ' \u00B7 ' + longCount + 'L/' + (whaleData.length - longCount) + 'S';
  }

  // --- Expanded full-screen whale explorer ---
  let whaleOverlayChart;

  function openWhaleOverlay() {
    if (!whaleData.length) return;
    document.getElementById('whale-overlay').style.display = '';

    const el = document.getElementById('whale-overlay-chart');
    whaleOverlayChart = echarts.init(el, null, { renderer: 'canvas' });

    const maxSz = Math.max(...whaleData.map(w => w.size), 1);
    const mapW = w => ({
      value: [w.pnl, w.size],
      symbolSize: Math.max(5, (w.size / maxSz) * 35),
      whale: w,
    });

    const longs = whaleData.filter(w => w.side === 'long').map(mapW);
    const shorts = whaleData.filter(w => w.side !== 'long').map(mapW);

    whaleOverlayChart.setOption({
      tooltip: {
        trigger: 'item', confine: true,
        backgroundColor: 'rgba(12,12,12,0.95)', borderColor: '#262626', borderRadius: 8,
        textStyle: { color: '#fafafa', fontSize: 11 },
        formatter: function(p) {
          const w = p.data.whale; if (!w) return '';
          const pC = w.pnl >= 0 ? '#22c55e' : '#ef4444';
          return '<div style="min-width:180px">' +
            '<div style="font-size:12px;font-weight:600;margin-bottom:4px">' + addr(w.address) + '</div>' +
            '<div style="font-size:11px;color:#a3a3a3">Size: <b>' + $(w.size) + '</b> (' + w.lev + 'x)</div>' +
            '<div style="font-size:11px;color:#a3a3a3">Entry: <b>$' + (w.entry >= 1 ? w.entry.toLocaleString(undefined,{maximumFractionDigits:2}) : w.entry.toFixed(4)) + '</b></div>' +
            '<div style="font-size:11px;color:' + pC + '">PnL: <b>' + (w.pnl >= 0 ? '+' : '') + $(w.pnl) + '</b></div>' +
            '<div style="font-size:11px;color:#a3a3a3">Liq: <b>' + (w.liq >= 1 ? '$' + w.liq.toLocaleString(undefined,{maximumFractionDigits:2}) : w.liq > 0 ? '$' + w.liq.toFixed(4) : '-') + '</b></div>' +
            '<div style="font-size:10px;color:#525252;margin-top:2px">' + (w.side === 'long' ? 'Long' : 'Short') + '</div></div>';
        },
      },
      grid: { left: 80, right: 40, top: 20, bottom: 60 },
      xAxis: {
        name: 'Unrealized PnL', nameLocation: 'center', nameGap: 36,
        nameTextStyle: { color: '#404040', fontSize: 12 },
        axisLine: { lineStyle: { color: '#1a1a1a' } },
        axisLabel: { color: '#525252', fontSize: 10, formatter: v => $(v) },
        splitLine: { lineStyle: { color: '#141414' } },
      },
      yAxis: {
        name: 'Position Size (USD)', nameLocation: 'center', nameGap: 60,
        nameTextStyle: { color: '#404040', fontSize: 12 },
        axisLine: { lineStyle: { color: '#1a1a1a' } },
        axisLabel: { color: '#525252', fontSize: 10, formatter: v => $(v) },
        splitLine: { lineStyle: { color: '#141414' } },
      },
      dataZoom: [
        { type: 'inside', xAxisIndex: 0, filterMode: 'none' },
        { type: 'inside', yAxisIndex: 0, filterMode: 'none' },
      ],
      series: [
        {
          name: 'Long', type: 'scatter', data: longs,
          itemStyle: { color: 'rgba(34,197,94,0.4)', borderColor: '#22c55e', borderWidth: 1 },
        },
        {
          name: 'Short', type: 'scatter', data: shorts,
          itemStyle: { color: 'rgba(239,68,68,0.4)', borderColor: '#ef4444', borderWidth: 1 },
        },
      ],
      legend: {
        show: true, bottom: 4,
        textStyle: { color: '#525252', fontSize: 11 },
        itemWidth: 12, itemHeight: 12,
      },
    });

    const longCount = longs.length, shortCount = shorts.length;
    const totalSz = whaleData.reduce((s, w) => s + w.size, 0);
    document.getElementById('whale-overlay-stats').textContent =
      whaleData.length + ' positions \u00B7 ' + longCount + ' Long / ' + shortCount + ' Short \u00B7 Total: ' + $(totalSz) + ' \u00B7 Scroll to zoom, drag to pan';

    new ResizeObserver(() => whaleOverlayChart && whaleOverlayChart.resize()).observe(el);
  }

  function closeWhaleOverlay() {
    document.getElementById('whale-overlay').style.display = 'none';
    if (whaleOverlayChart) { whaleOverlayChart.dispose(); whaleOverlayChart = null; }
  }

  // =====================================================================
  // ORDER FLOW
  // =====================================================================
  async function updateFlow() {
    const data = await api(B + '/api/data/orderflow/' + coin);
    const el = document.getElementById('flow-panel');
    if (!data || data.error) { el.innerHTML = '<div class="empty">No order flow data</div>'; return; }

    const w = data.windows || {};
    const tfs = ['1m', '5m', '15m', '1h'];
    let html = '';
    let netCvd = 0;

    tfs.forEach(tf => {
      const d = w[tf];
      if (!d) return;
      const bp = d.buy_pct || 50;
      const sp = 100 - bp;
      const cvd = d.cvd || 0;
      netCvd += cvd;
      const arrow = cvd >= 0 ? '\u2191' : '\u2193';
      const cls = cvd >= 0 ? 'pos' : 'neg';
      html += '<div class="flow-row">' +
        '<span class="flow-tf">' + tf + '</span>' +
        '<div class="flow-bar-wrap">' +
        '<div class="flow-buy" style="width:' + bp + '%">' + bp.toFixed(0) + '%</div>' +
        '<div class="flow-sell" style="width:' + sp + '%">' + sp.toFixed(0) + '%</div>' +
        '</div>' +
        '<span class="flow-cvd ' + cls + '">' + arrow + ' ' + $(Math.abs(cvd)) + '</span>' +
        '</div>';
    });

    // Net summary
    const netCls = netCvd >= 0 ? 'pos' : 'neg';
    const netArrow = netCvd >= 0 ? '\u2191 Net Buy' : '\u2193 Net Sell';
    html += '<div class="flow-net">' +
      '<span class="flow-net-label">Aggregate</span>' +
      '<span class="flow-cvd ' + netCls + '" style="width:auto">' + netArrow + ' ' + $(Math.abs(netCvd)) + '</span>' +
      '</div>';

    el.innerHTML = html || '<div class="empty">No windows</div>';
    document.getElementById('flow-badge').textContent = Object.keys(w).length + ' windows';
  }

  // =====================================================================
  // SMART MONEY
  // =====================================================================
  async function updateSM() {
    const data = await api(B + '/api/data/smart-money?top_n=20');
    const el = document.getElementById('sm-panel');
    if (!data || data.error || !(data.traders || []).length) { el.innerHTML = '<div class="empty">No smart money data</div>'; return; }

    const t = data.traders;
    let html = '<table class="data-table"><thead><tr><th>#</th><th>Address</th><th>PnL 24h</th><th>Equity</th><th>Pos</th></tr></thead><tbody>';
    t.forEach((tr, i) => {
      const pnl = tr.pnl_24h || 0;
      const c = pnl >= 0 ? '#22c55e' : '#ef4444';
      const s = pnl >= 0 ? '+' : '';
      html += '<tr><td style="color:#525252">' + (i+1) + '</td><td>' + addr(tr.address) + '</td>' +
        '<td style="color:' + c + '">' + s + $(pnl) + '</td>' +
        '<td>' + $(tr.equity || 0) + '</td><td>' + (tr.positions || 0) + '</td></tr>';
    });
    html += '</tbody></table>';
    el.innerHTML = html;
    document.getElementById('sm-badge').textContent = t.length + ' traders';
  }

  // =====================================================================
  // HLP VAULT — with PnL column
  // =====================================================================
  async function updateHLP() {
    if (hlpCollapsed) return;
    const data = await api(B + '/api/data/hlp/positions');
    const el = document.getElementById('hlp-panel');
    if (!data || data.error || !(data.positions || []).length) { el.innerHTML = '<div class="empty">No HLP positions</div>'; return; }

    const pos = data.positions;
    const maxSz = Math.max(...pos.map(p => p.size_usd || 0), 1);

    let html = '<table class="data-table"><thead><tr>' +
      '<th>Coin</th><th>Side</th><th>Size</th><th style="width:100px"></th><th>Lev</th><th>Entry</th><th>PnL</th>' +
      '</tr></thead><tbody>';

    pos.forEach(p => {
      const side = (p.side || 'long').toLowerCase();
      const sz = p.size_usd || 0;
      const barW = Math.max(4, (sz / maxSz) * 100);
      const pnl = p.pnl_usd || p.unrealized_pnl || 0;
      const pnlPct = p.return_pct || p.pnl_pct || 0;
      const pnlC = pnl >= 0 ? '#22c55e' : '#ef4444';
      const entry = p.entry_px || 0;
      const eStr = entry >= 1 ? '$' + entry.toLocaleString(undefined,{maximumFractionDigits:2}) : entry > 0 ? '$' + entry.toFixed(4) : '-';
      const pnlStr = pnl !== 0 ? (pnl >= 0 ? '+' : '') + $(pnl) + (pnlPct ? ' (' + pnlPct.toFixed(1) + '%)' : '') : '-';

      html += '<tr>' +
        '<td style="color:#e5e5e5;font-weight:500">' + (p.coin || '?') + '</td>' +
        '<td><span class="side-dot ' + side + '"></span>' + side.toUpperCase() + '</td>' +
        '<td>' + $(sz) + '</td>' +
        '<td><span class="bar-fill" style="width:' + barW + '%"></span></td>' +
        '<td>' + (p.leverage || 1).toFixed(0) + 'x</td>' +
        '<td>' + eStr + '</td>' +
        '<td style="color:' + pnlC + '">' + pnlStr + '</td>' +
        '</tr>';
    });

    html += '</tbody></table>';
    el.innerHTML = html;
    document.getElementById('hlp-badge').textContent = pos.length + ' positions';
  }

  // =====================================================================
  // STATS BAR
  // =====================================================================
  async function updateStats() {
    const h = await api(B + '/api/data-health');
    const dot = document.getElementById('ws-dot');
    const status = document.getElementById('stat-status');

    if (!h || h.error) {
      dot.className = 'stat-dot off'; status.textContent = 'offline'; return;
    }
    dot.className = 'stat-dot on'; status.textContent = 'online';

    // /health returns flat fields: addresses_discovered, positions_tracked, uptime_seconds
    const wallets = h.addresses_discovered || 0;
    document.getElementById('stat-wallets').textContent = wallets ? wallets.toLocaleString() : '-';
    const pos = h.positions_tracked || 0;
    document.getElementById('stat-positions').textContent = pos ? pos.toLocaleString() : '-';
    const up = h.uptime_seconds ? (h.uptime_seconds / 3600).toFixed(1) + 'h' : '-';
    document.getElementById('stat-uptime').textContent = up;
    document.getElementById('stat-updated').textContent = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
  }

  // =====================================================================
  // ORCHESTRATION
  // =====================================================================
  function refreshAll() { updatePrice(); updateHeatmap(); updateWhale(); updateFlow(); updateSM(); updateHLP(); updateStats(); }

  // Whale explorer expand/close
  document.getElementById('whale-expand').addEventListener('click', openWhaleOverlay);
  document.getElementById('whale-close').addEventListener('click', closeWhaleOverlay);
  document.addEventListener('keydown', e => {
    if (e.key === 'Escape' && document.getElementById('whale-overlay').style.display !== 'none') closeWhaleOverlay();
  });

  initPrice(); initHeatmap(); initWhale();
  refreshAll();

  setInterval(() => { if (vis()) updatePrice(); }, 10000);
  setInterval(() => { if (!vis()) return; updateHeatmap(); updateWhale(); updateFlow(); }, 30000);
  setInterval(() => { if (!vis()) return; updateSM(); updateHLP(); updateStats(); }, 60000);
})();
</script>
</body>
</html>
