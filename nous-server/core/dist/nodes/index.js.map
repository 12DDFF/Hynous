{"version":3,"sources":["../../src/constants.ts","../../src/blocks/index.ts","../../src/temporal/index.ts","../../src/nodes/index.ts"],"names":["z","nanoid"],"mappings":";;;;;;AAYO,IAAM,aAAA,GAAgB,EAAA;AAGtB,IAAM,cAAA,GAAiB,IAAA;AAevB,IAAM,UAAA,GAAa;AAAA,EACxB,SAAA;AAAA,EACA,SAAA;AAAA,EACA,UAAA;AAAA,EACA,SAAA;AAAA,EACA,OAAA;AAAA,EACA,MAAA;AAAA,EACA;AACF,CAAA;AAYO,IAAM,gBAAA,GAAmB;AAAA,EAC9B,MAAA;AAAA,EACA,YAAA;AAAA,EACA,cAAA;AAAA,EACA,YAAA;AAAA,EACA,QAAA;AAAA,EACA,WAAA;AAAA,EACA,QAAA;AAAA,EACA,OAAA;AAAA,EACA;AACF,CAAA;AAIO,IAAM,gBAAA,GAAmB;AAAA,EAC9B,SAAA;AAAA,EACA,SAAA;AAAA,EACA,cAAA;AAAA,EACA,cAAA;AAAA,EACA,eAAA;AAAA,EACA,SAAA;AAAA,EACA;AACF,CAAA;AAIO,IAAM,YAAA,GAAe;AAAA,EAC1B,YAAA;AAAA,EACA,UAAA;AAAA,EACA,MAAA;AAAA,EACA,OAAA;AAAA,EACA;AACF,CAAA;AAQO,IAAM,WAAA,GAAc;AAAA,EACzB,WAAA;AAAA,EACA,SAAA;AAAA,EACA,MAAA;AAAA,EACA,WAAA;AAAA,EACA,MAAA;AAAA,EACA,OAAA;AAAA,EACA,SAAA;AAAA,EACA,SAAA;AAAA,EACA,OAAA;AAAA,EACA;AACF,CAAA;AA0BO,IAAM,gBAAA,GAAmB;AAAA,EAC9B,SAAA;AAAA,EACA,QAAA;AAAA,EACA,YAAA;AAAA,EACA,SAAA;AAAA,EACA;AACF,CAAA;AAQO,IAAM,YAAA,GAAe;AAAA,EAC1B,YAAA;AAAA,EACA,QAAA;AAAA,EACA,WAAA;AAAA,EACA;AACF,CAAA;AAqCO,IAAM,SAAA,GAAY,CAAC,MAAA,EAAQ,IAAA,EAAM,UAAU,MAAM,CAAA;AA0BjD,IAAM,kBAAA,GAAqB,CAAC,UAAA,EAAY,UAAA,EAAY,aAAa,CAAA;AAIjE,IAAM,kBAAA,GAAqB,CAAC,YAAA,EAAc,UAAA,EAAY,aAAa,CAAA;AAkDnE,IAAM,eAAA,GAAkB;AAAA,EAC7B,SAAA,EAAW,GAAA;AAAA,EACX,cAAA,EAAgB,CAAA;AAAA,EAChB,WAAA,EAAa;AACf,CAAA;AAMO,IAAM,iBAAA,GAAoB,CAAC,SAAA,EAAW,SAAA,EAAW,MAAM,CAAA;ACnNvD,IAAM,cAAgC,CAAA,CAAE,IAAA;AAAA,EAAK,MAClD,EAAE,MAAA,CAAO;AAAA,IACP,EAAA,EAAI,CAAA,CAAE,MAAA,EAAO,CAAE,MAAM,uBAAuB,CAAA;AAAA,IAC5C,IAAA,EAAM,CAAA,CAAE,IAAA,CAAK,WAAW,CAAA;AAAA,IACxB,OAAA,EAAS,EAAE,MAAA,EAAO;AAAA,IAClB,KAAA,EAAO,CAAA,CAAE,MAAA,EAAO,CAAE,GAAA,EAAI,CAAE,GAAA,CAAI,CAAC,CAAA,CAAE,GAAA,CAAI,CAAC,CAAA,CAAE,QAAA,EAAS;AAAA,IAC/C,QAAA,EAAU,CAAA,CAAE,KAAA,CAAM,WAAW,EAAE,QAAA,EAAS;AAAA,IACxC,OAAA,EAAS,CAAA,CAAE,MAAA,EAAO,CAAE,QAAA,EAAS;AAAA,IAC7B,QAAA,EAAU,CAAA,CAAE,MAAA,EAAO,CAAE,QAAA;AAAS,GAC/B;AACH,CAAA;ACnCO,IAAM,mBAAA,GAAsBA,EAAE,MAAA,CAAO;AAAA,EAC1C,SAAA,EAAWA,CAAAA,CAAE,MAAA,EAAO,CAAE,QAAA,EAAS;AAAA,EAC/B,QAAA,EAAUA,EAAE,MAAA;AACd,CAAC,CAAA;AAkBM,IAAM,eAAA,GAAkBA,EAAE,MAAA,CAAO;AAAA,EACtC,SAAA,EAAWA,CAAAA,CAAE,MAAA,EAAO,CAAE,QAAA,EAAS;AAAA,EAC/B,UAAA,EAAYA,EAAE,MAAA,EAAO,CAAE,IAAI,CAAC,CAAA,CAAE,IAAI,CAAC,CAAA;AAAA,EACnC,MAAA,EAAQA,CAAAA,CAAE,IAAA,CAAK,kBAAkB;AACnC,CAAC,CAAA;AAoBM,IAAM,iBAAA,GAAoBA,EAAE,MAAA,CAAO;AAAA,EACxC,IAAA,EAAMA,EAAE,MAAA,EAAO;AAAA,EACf,QAAA,EAAUA,CAAAA,CAAE,MAAA,EAAO,CAAE,QAAA,EAAS;AAAA,EAC9B,IAAA,EAAMA,CAAAA,CAAE,IAAA,CAAK,kBAAkB,CAAA;AAAA,EAC/B,UAAA,EAAYA,EAAE,MAAA,EAAO,CAAE,IAAI,CAAC,CAAA,CAAE,IAAI,CAAC;AACrC,CAAC,CAAA;AAqBM,IAAM,mBAAA,GAAsBA,EAAE,MAAA,CAAO;AAAA,EAC1C,SAAA,EAAW,mBAAA;AAAA,EACX,KAAA,EAAO,gBAAgB,QAAA,EAAS;AAAA,EAChC,aAAA,EAAeA,CAAAA,CAAE,KAAA,CAAM,iBAAiB,EAAE,QAAA,EAAS;AAAA,EACnD,oBAAoBA,CAAAA,CAAE,KAAA,CAAMA,EAAE,MAAA,EAAQ,EAAE,QAAA;AAC1C,CAAC,CAAA;AAoBuCA,EAAE,MAAA,CAAO;AAAA,EAC/C,MAAA,EAAQA,EAAE,MAAA,EAAO,CAAE,IAAI,CAAC,CAAA,CAAE,IAAI,CAAC,CAAA;AAAA,EAC/B,WAAA,EAAaA,EAAE,MAAA,EAAO,CAAE,IAAI,CAAC,CAAA,CAAE,IAAI,CAAC,CAAA;AAAA,EACpC,cAAA,EAAgBA,EAAE,MAAA,EAAO,CAAE,IAAI,CAAC,CAAA,CAAE,IAAI,CAAC,CAAA;AAAA,EACvC,QAAA,EAAUA,EAAE,MAAA,EAAO,CAAE,IAAI,CAAC,CAAA,CAAE,IAAI,CAAC;AACnC,CAAC;AASM,SAAS,oBAAoB,QAAA,EAAkC;AACpE,EAAA,OAAO;AAAA,IACL,SAAA,EAAW;AAAA,MACT,SAAA,EAAA,iBAAW,IAAI,IAAA,EAAK,EAAE,WAAA,EAAY;AAAA,MAClC,UAAU,QAAA,IAAY,IAAA,CAAK,cAAA,EAAe,CAAE,iBAAgB,CAAE;AAAA;AAChE,GACF;AACF;;;AC1GO,SAAS,cAAA,GAAyB;AACvC,EAAA,OAAO,cAAA,GAAiBC,OAAO,aAAa,CAAA;AAC9C;AAmBO,IAAM,oBAAA,GAAuBD,EAAE,MAAA,CAAO;AAAA,EAC3C,MAAA,EAAQA,CAAAA,CAAE,UAAA,CAAW,YAAY,CAAA;AAAA,EACjC,KAAA,EAAOA,EAAE,MAAA,EAAO;AAAA,EAChB,UAAA,EAAYA,CAAAA,CAAE,MAAA,EAAO,CAAE,QAAA;AACzB,CAAC;AAoBM,IAAM,sBAAA,GAAyBA,EAAE,MAAA,CAAO;AAAA,EAC7C,SAAA,EAAWA,EAAE,MAAA,EAAO,CAAE,IAAI,CAAC,CAAA,CAAE,IAAI,CAAC,CAAA;AAAA,EAClC,cAAA,EAAgBA,EAAE,MAAA,EAAO,CAAE,IAAI,CAAC,CAAA,CAAE,IAAI,CAAC,CAAA;AAAA,EACvC,aAAA,EAAeA,CAAAA,CAAE,MAAA,EAAO,CAAE,QAAA,EAAS;AAAA,EACnC,cAAcA,CAAAA,CAAE,MAAA,GAAS,GAAA,EAAI,CAAE,IAAI,CAAC;AACtC,CAAC;AAKM,SAAS,6BAAA,GAAkD;AAChE,EAAA,OAAO;AAAA,IACL,WAAW,eAAA,CAAgB,SAAA;AAAA,IAC3B,gBAAgB,eAAA,CAAgB,cAAA;AAAA,IAChC,aAAA,EAAA,iBAAe,IAAI,IAAA,EAAK,EAAE,WAAA,EAAY;AAAA,IACtC,cAAc,eAAA,CAAgB;AAAA,GAChC;AACF;AAkBO,IAAM,gBAAA,GAAmBA,EAAE,MAAA,CAAO;AAAA,EACvC,MAAA,EAAQA,CAAAA,CAAE,IAAA,CAAK,YAAY,CAAA;AAAA,EAC3B,SAAA,EAAWA,CAAAA,CAAE,MAAA,EAAO,CAAE,QAAA,EAAS;AAAA,EAC/B,UAAA,EAAYA,EAAE,MAAA,EAAO,CAAE,IAAI,CAAC,CAAA,CAAE,IAAI,CAAC;AACrC,CAAC;AAgBM,IAAM,eAAA,GAAkBA,EAAE,MAAA,CAAO;AAAA,EACtC,gBAAA,EAAkBA,CAAAA,CAAE,IAAA,CAAK,iBAAiB,CAAA;AAAA,EAC1C,SAAA,EAAWA,CAAAA,CAAE,IAAA,CAAK,gBAAgB;AACpC,CAAC;AAoBM,IAAM,iBAAA,GAAoBA,EAAE,MAAA,CAAO;AAAA,EACxC,SAASA,CAAAA,CAAE,MAAA,GAAS,GAAA,EAAI,CAAE,IAAI,CAAC,CAAA;AAAA,EAC/B,YAAA,EAAcA,CAAAA,CAAE,MAAA,EAAO,CAAE,QAAA,EAAS;AAAA,EAClC,YAAA,EAAcA,CAAAA,CAAE,IAAA,CAAK,SAAS,CAAA;AAAA,EAC9B,QAAA,EAAUA,CAAAA,CAAE,MAAA,EAAO,CAAE,QAAA;AACvB,CAAC;AAKM,SAAS,oBAAA,CAAqB,WAAqB,QAAA,EAAuB;AAC/E,EAAA,OAAO;AAAA,IACL,OAAA,EAAS,CAAA;AAAA,IACT,YAAA,EAAA,iBAAc,IAAI,IAAA,EAAK,EAAE,WAAA,EAAY;AAAA,IACrC,YAAA,EAAc;AAAA,GAChB;AACF;AAoBO,IAAM,iBAAA,GAAoBA,EAAE,MAAA,CAAO;AAAA,EACxC,KAAA,EAAOA,EAAE,MAAA,EAAO,CAAE,IAAI,CAAC,CAAA,CAAE,IAAI,GAAG,CAAA;AAAA,EAChC,IAAA,EAAMA,CAAAA,CAAE,MAAA,EAAO,CAAE,QAAA,EAAS;AAAA,EAC1B,OAAA,EAASA,CAAAA,CAAE,MAAA,EAAO,CAAE,QAAA,EAAS;AAAA,EAC7B,MAAA,EAAQA,CAAAA,CAAE,KAAA,CAAM,WAAW,EAAE,QAAA;AAC/B,CAAC;AAgCM,IAAM,cAAA,GAAiBA,EAAE,MAAA,CAAO;AAAA,EACrC,EAAA,EAAIA,CAAAA,CAAE,MAAA,EAAO,CAAE,MAAM,uBAAuB,CAAA;AAAA,EAC5C,IAAA,EAAMA,CAAAA,CAAE,IAAA,CAAK,UAAU,CAAA;AAAA,EACvB,OAAA,EAASA,CAAAA,CAAE,MAAA,EAAO,CAAE,QAAA,EAAS;AAAA,EAC7B,OAAA,EAAS,iBAAA;AAAA,EACT,SAAA,EAAW,qBAAqB,QAAA,EAAS;AAAA,EACzC,QAAA,EAAU,mBAAA;AAAA,EACV,MAAA,EAAQ,sBAAA;AAAA,EACR,UAAA,EAAY,gBAAA;AAAA,EACZ,KAAA,EAAO,eAAA;AAAA,EACP,UAAA,EAAY;AACd,CAAC;AAcM,IAAM,iBAAA,GAAoB,eAAe,MAAA,CAAO;AAAA,EACrD,IAAA,EAAMA,CAAAA,CAAE,OAAA,CAAQ,SAAS,CAAA;AAAA,EACzB,OAAA,EAASA,CAAAA,CAAE,KAAA,CAAM,CAACA,EAAE,IAAA,CAAK,gBAAgB,CAAA,EAAGA,CAAAA,CAAE,MAAA,EAAO,CAAE,KAAA,CAAM,aAAa,CAAC,CAAC;AAC9E,CAAC;AAmBM,IAAM,qBAAA,GAAwBA,EAAE,MAAA,CAAO;AAAA,EAC5C,kBAAkBA,CAAAA,CAAE,MAAA,EAAO,CAAE,QAAA,GAAW,QAAA,EAAS;AAAA,EACjD,aAAA,EAAeA,CAAAA,CAAE,KAAA,CAAMA,CAAAA,CAAE,QAAQ,CAAA;AAAA,EACjC,YAAA,EAAcA,CAAAA,CAAE,MAAA,EAAO,CAAE,QAAA,EAAS;AAAA,EAClC,cAAcA,CAAAA,CAAE,KAAA,CAAMA,EAAE,MAAA,EAAQ,EAAE,QAAA,EAAS;AAAA,EAC3C,QAAA,EAAUA,CAAAA,CAAE,MAAA,EAAO,CAAE,QAAA,EAAS;AAAA,EAC9B,mBAAA,EAAqBA,EAAE,MAAA,CAAO;AAAA,IAC5B,MAAA,EAAQA,EAAE,MAAA,EAAO,CAAE,IAAI,CAAC,CAAA,CAAE,IAAI,CAAC,CAAA;AAAA,IAC/B,WAAA,EAAaA,EAAE,MAAA,EAAO,CAAE,IAAI,CAAC,CAAA,CAAE,IAAI,CAAC,CAAA;AAAA,IACpC,cAAA,EAAgBA,EAAE,MAAA,EAAO,CAAE,IAAI,CAAC,CAAA,CAAE,IAAI,CAAC,CAAA;AAAA,IACvC,QAAA,EAAUA,EAAE,MAAA,EAAO,CAAE,IAAI,CAAC,CAAA,CAAE,IAAI,CAAC;AAAA,GAClC;AACH,CAAC;AAWM,IAAM,iBAAA,GAAoB,eAAe,MAAA,CAAO;AAAA,EACrD,IAAA,EAAMA,CAAAA,CAAE,OAAA,CAAQ,SAAS,CAAA;AAAA,EACzB,OAAA,EAASA,CAAAA,CAAE,KAAA,CAAM,CAACA,EAAE,IAAA,CAAK,gBAAgB,CAAA,EAAGA,CAAAA,CAAE,MAAA,EAAO,CAAE,KAAA,CAAM,aAAa,CAAC,CAAC,CAAA;AAAA,EAC5E,gBAAA,EAAkB;AACpB,CAAC;AAaM,IAAM,sBAAA,GAAyBA,EAAE,MAAA,CAAO;AAAA,EAC7C,MAAA,EAAQA,EAAE,MAAA,EAAO;AAAA,EACjB,UAAA,EAAYA,EAAE,MAAA,EAAO,CAAE,KAAI,CAAE,QAAA,GAAW,QAAA,EAAS;AAAA,EACjD,YAAYA,CAAAA,CAAE,MAAA,GAAS,GAAA,EAAI,CAAE,IAAI,CAAC,CAAA;AAAA,EAClC,QAAA,EAAUA,CAAAA,CAAE,KAAA,CAAMA,CAAAA,CAAE,QAAQ,CAAA;AAAA,EAC5B,iBAAA,EAAmBA,EAAE,IAAA,CAAK,CAAC,WAAW,YAAA,EAAc,SAAA,EAAW,UAAU,CAAC;AAC5E,CAAC;AAUM,IAAM,kBAAA,GAAqB,eAAe,MAAA,CAAO;AAAA,EACtD,IAAA,EAAMA,CAAAA,CAAE,OAAA,CAAQ,UAAU,CAAA;AAAA,EAC1B,iBAAA,EAAmB;AACrB,CAAC;AAaM,IAAM,qBAAA,GAAwBA,EAAE,MAAA,CAAO;AAAA,EAC5C,WAAA,EAAaA,EAAE,MAAA,EAAO;AAAA,EACtB,OAAA,EAASA,EAAE,MAAA,EAAO;AAAA,EAClB,UAAUA,CAAAA,CAAE,MAAA,GAAS,GAAA,EAAI,CAAE,IAAI,CAAC,CAAA;AAAA,EAChC,SAAA,EAAWA,EAAE,OAAA,EAAQ;AAAA,EACrB,QAAA,EAAUA,CAAAA,CAAE,KAAA,CAAMA,CAAAA,CAAE,QAAQ;AAC9B,CAAC;AAUM,IAAM,iBAAA,GAAoB,eAAe,MAAA,CAAO;AAAA,EACrD,IAAA,EAAMA,CAAAA,CAAE,OAAA,CAAQ,SAAS,CAAA;AAAA,EACzB,gBAAA,EAAkB;AACpB,CAAC;AAcM,IAAM,iBAAA,GAAoBA,EAAE,MAAA,CAAO;AAAA,EACxC,YAAA,EAAcA,EAAE,IAAA,CAAK,CAAC,QAAQ,YAAA,EAAc,UAAA,EAAY,OAAA,EAAS,OAAO,CAAC,CAAA;AAAA,EACzE,eAAA,EAAiBA,CAAAA,CAAE,MAAA,EAAO,CAAE,QAAA,EAAS;AAAA,EACrC,eAAA,EAAiBA,EAAE,MAAA,EAAO,CAAE,KAAI,CAAE,QAAA,GAAW,QAAA,EAAS;AAAA,EACtD,UAAA,EAAYA,EAAE,MAAA,EAAO,CAAE,KAAI,CAAE,GAAA,CAAI,CAAC,CAAA,CAAE,QAAA,EAAS;AAAA,EAC7C,YAAA,EAAcA,CAAAA,CAAE,MAAA,EAAO,CAAE,QAAA,EAAS;AAAA,EAClC,iBAAA,EAAmBA,EAAE,IAAA,CAAK,CAAC,WAAW,YAAA,EAAc,UAAA,EAAY,QAAQ,CAAC;AAC3E,CAAC;AAWM,IAAM,aAAA,GAAgB,eAAe,MAAA,CAAO;AAAA,EACjD,IAAA,EAAMA,CAAAA,CAAE,OAAA,CAAQ,KAAK,CAAA;AAAA,EACrB,OAAA,EAASA,CAAAA,CAAE,IAAA,CAAK,YAAY,CAAA;AAAA,EAC5B,YAAA,EAAc;AAChB,CAAC;AASM,IAAM,cAAA,GAAiB,eAAe,MAAA,CAAO;AAAA,EAClD,IAAA,EAAMA,CAAAA,CAAE,OAAA,CAAQ,MAAM;AACxB,CAAC;AASM,IAAM,eAAA,GAAkB,eAAe,MAAA,CAAO;AAAA,EACnD,IAAA,EAAMA,CAAAA,CAAE,OAAA,CAAQ,OAAO;AACzB,CAAC;AAqBM,IAAM,aAAA,GAAgBA,CAAAA,CAAE,kBAAA,CAAmB,MAAA,EAAQ;AAAA,EACxD,iBAAA;AAAA,EACA,iBAAA;AAAA,EACA,kBAAA;AAAA,EACA,iBAAA;AAAA,EACA,aAAA;AAAA,EACA,cAAA;AAAA,EACA;AACF,CAAC;AAkBM,SAAS,UAAA,CACd,IAAA,EACA,OAAA,EACA,OAAA,GAA6B,EAAC,EACpB;AACV,EAAA,OAAO;AAAA,IACL,IAAI,cAAA,EAAe;AAAA,IACnB,IAAA;AAAA,IACA,SAAS,OAAA,CAAQ,OAAA;AAAA,IACjB,OAAA;AAAA,IACA,QAAA,EAAU,mBAAA,CAAoB,OAAA,CAAQ,QAAQ,CAAA;AAAA,IAC9C,QAAQ,6BAAA,EAA8B;AAAA,IACtC,UAAA,EAAY;AAAA,MACV,MAAA,EAAQ,QAAQ,MAAA,IAAU,QAAA;AAAA,MAC1B,WAAW,OAAA,CAAQ,SAAA;AAAA,MACnB,UAAA,EAAY,QAAQ,UAAA,IAAc;AAAA,KACpC;AAAA,IACA,KAAA,EAAO;AAAA,MACL,gBAAA,EAAkB,MAAA;AAAA,MAClB,SAAA,EAAW;AAAA,KACb;AAAA,IACA,UAAA,EAAY,oBAAA,CAAqB,OAAA,CAAQ,QAAA,IAAY,MAAM;AAAA,GAC7D;AACF;AAKO,SAAS,kBACd,KAAA,EACA,IAAA,EACA,OAAA,EACA,OAAA,GAA6B,EAAC,EACjB;AACb,EAAA,MAAM,IAAA,GAAO,UAAA,CAAW,SAAA,EAAW,EAAE,KAAA,EAAO,IAAA,EAAK,EAAG,EAAE,GAAG,OAAA,EAAS,OAAA,EAAS,CAAA;AAC3E,EAAA,OAAO,IAAA;AACT;AAKO,SAAS,cAAA,CACd,KAAA,EACA,IAAA,EACA,OAAA,GAA6B,EAAC,EACpB;AACV,EAAA,MAAM,OAAO,UAAA,CAAW,MAAA,EAAQ,EAAE,KAAA,EAAO,IAAA,IAAQ,OAAO,CAAA;AACxD,EAAA,OAAO,IAAA;AACT;AAKO,SAAS,aAAa,IAAA,EAA0B;AACrD,EAAA,OAAO;AAAA,IACL,GAAG,IAAA;AAAA,IACH,MAAA,EAAQ;AAAA,MACN,GAAG,IAAA,CAAK,MAAA;AAAA,MACR,aAAA,EAAA,iBAAe,IAAI,IAAA,EAAK,EAAE,WAAA,EAAY;AAAA,MACtC,YAAA,EAAc,IAAA,CAAK,MAAA,CAAO,YAAA,GAAe;AAAA;AAC3C,GACF;AACF;AAKO,SAAS,eAAA,CAAgB,MAAgB,SAAA,EAAqC;AACnF,EAAA,OAAO;AAAA,IACL,GAAG,IAAA;AAAA,IACH,KAAA,EAAO;AAAA,MACL,GAAG,IAAA,CAAK,KAAA;AAAA,MACR;AAAA;AACF,GACF;AACF","file":"index.js","sourcesContent":["/**\n * @module @nous/core/constants\n * @description All constants, enums, and configuration values\n * @version 0.1.0\n * @spec Brainstorms/Specs/storm-011/spec/constants.ts\n */\n\n// ============================================================\n// ID CONFIGURATION\n// ============================================================\n\n/** Length of nanoid for globally unique IDs */\nexport const NANOID_LENGTH = 12;\n\n/** Prefix for node IDs: \"n_\" + nanoid(12) */\nexport const NODE_ID_PREFIX = 'n_';\n\n/** Prefix for block IDs: \"b_\" + nanoid(12) */\nexport const BLOCK_ID_PREFIX = 'b_';\n\n/** Prefix for edge IDs: \"e_\" + nanoid(12) */\nexport const EDGE_ID_PREFIX = 'e_';\n\n/** Prefix for edit record IDs: \"edit_\" + nanoid(12) */\nexport const EDIT_ID_PREFIX = 'edit_';\n\n// ============================================================\n// NODE TYPES\n// ============================================================\n\nexport const NODE_TYPES = [\n  'concept',\n  'episode',\n  'document',\n  'section',\n  'chunk',\n  'note',\n  'raw',\n] as const;\n\nexport type NodeType = (typeof NODE_TYPES)[number];\n\nexport const SEMANTIC_LAYER_TYPES: NodeType[] = ['concept', 'note', 'chunk'];\nexport const EPISODE_LAYER_TYPES: NodeType[] = ['episode', 'document', 'section'];\nexport const ARCHIVE_LAYER_TYPES: NodeType[] = ['raw'];\n\n// ============================================================\n// SUBTYPES\n// ============================================================\n\nexport const CONCEPT_SUBTYPES = [\n  'fact',\n  'definition',\n  'relationship',\n  'preference',\n  'belief',\n  'procedure',\n  'entity',\n  'event',\n  'insight',\n] as const;\n\nexport type ConceptSubtype = (typeof CONCEPT_SUBTYPES)[number] | `custom:${string}`;\n\nexport const EPISODE_SUBTYPES = [\n  'lecture',\n  'meeting',\n  'conversation',\n  'note_session',\n  'document_read',\n  'thought',\n  'external_event',\n] as const;\n\nexport type EpisodeSubtype = (typeof EPISODE_SUBTYPES)[number] | `custom:${string}`;\n\nexport const RAW_SUBTYPES = [\n  'transcript',\n  'document',\n  'note',\n  'image',\n  'audio_recording',\n] as const;\n\nexport type RawSubtype = (typeof RAW_SUBTYPES)[number];\n\n// ============================================================\n// BLOCK TYPES\n// ============================================================\n\nexport const BLOCK_TYPES = [\n  'paragraph',\n  'heading',\n  'list',\n  'list_item',\n  'code',\n  'quote',\n  'callout',\n  'divider',\n  'table',\n  'image',\n] as const;\n\nexport type BlockType = (typeof BLOCK_TYPES)[number];\n\n// ============================================================\n// EDGE TYPES\n// ============================================================\n\nexport const EDGE_TYPES = [\n  'relates_to',\n  'part_of',\n  'mentioned_in',\n  'causes',\n  'precedes',\n  'contradicts',\n  'supersedes',\n  'derived_from',\n  'similar_to',\n] as const;\n\nexport type EdgeType = (typeof EDGE_TYPES)[number];\n\n// ============================================================\n// LIFECYCLE STATES\n// ============================================================\n\nexport const LIFECYCLE_STATES = [\n  'working',\n  'active',\n  'superseded',\n  'dormant',\n  'archived',\n] as const;\n\nexport type LifecycleState = (typeof LIFECYCLE_STATES)[number];\n\n// ============================================================\n// SOURCE TYPES\n// ============================================================\n\nexport const SOURCE_TYPES = [\n  'extraction',\n  'manual',\n  'inference',\n  'import',\n] as const;\n\nexport type SourceType = (typeof SOURCE_TYPES)[number];\n\n// ============================================================\n// CONTENT SOURCES\n// ============================================================\n\nexport const CONTENT_SOURCES = [\n  'import',\n  'user_note',\n  'chat_extraction',\n  'fact',\n  'document',\n  'transcript',\n] as const;\n\nexport type ContentSource = (typeof CONTENT_SOURCES)[number];\n\n// ============================================================\n// EDIT SYSTEM\n// ============================================================\n\nexport const EDIT_TARGET_METHODS = [\n  'block_id',\n  'heading',\n  'position',\n  'search',\n  'full',\n] as const;\n\nexport type EditTargetMethod = (typeof EDIT_TARGET_METHODS)[number];\n\nexport const EDIT_ACTIONS = ['replace', 'insert', 'append', 'delete'] as const;\n\nexport type EditAction = (typeof EDIT_ACTIONS)[number];\n\nexport const MODIFIERS = ['user', 'ai', 'system', 'sync'] as const;\n\nexport type Modifier = (typeof MODIFIERS)[number];\n\nexport const EDIT_HISTORY_RETENTION = {\n  maxEdits: 100,\n  maxAgeDays: 30,\n  undoWindowHours: 24,\n  pruneSchedule: 'daily',\n} as const;\n\n// ============================================================\n// TEMPORAL\n// ============================================================\n\nexport const TEMPORAL_GRANULARITIES = [\n  'minute',\n  'hour',\n  'day',\n  'week',\n  'month',\n  'year',\n] as const;\n\nexport type TemporalGranularity = (typeof TEMPORAL_GRANULARITIES)[number];\n\nexport const EVENT_TIME_SOURCES = ['explicit', 'inferred', 'user_stated'] as const;\n\nexport type EventTimeSource = (typeof EVENT_TIME_SOURCES)[number];\n\nexport const CONTENT_TIME_TYPES = ['historical', 'relative', 'approximate'] as const;\n\nexport type ContentTimeType = (typeof CONTENT_TIME_TYPES)[number];\n\n// ============================================================\n// PROCESSING PATHS\n// ============================================================\n\nexport const INPUT_TYPES = [\n  'DOCUMENT',\n  'TRANSCRIPT',\n  'CONVERSATION',\n  'NOTE',\n  'IMPORT',\n] as const;\n\nexport type InputType = (typeof INPUT_TYPES)[number];\n\nexport const INPUT_SIZES = ['tiny', 'small', 'medium', 'large', 'huge'] as const;\n\nexport type InputSize = (typeof INPUT_SIZES)[number];\n\nexport const PROCESSING_PATHS = [\n  'fast',\n  'standard',\n  'progressive',\n  'conversation',\n] as const;\n\nexport type ProcessingPath = (typeof PROCESSING_PATHS)[number];\n\nexport const SIZE_THRESHOLDS = {\n  tiny: { min: 0, max: 50 },\n  small: { min: 50, max: 500 },\n  medium: { min: 500, max: 5000 },\n  large: { min: 5000, max: 25000 },\n  huge: { min: 25000, max: Infinity },\n} as const;\n\n// ============================================================\n// BLOCK DECISION THRESHOLDS\n// ============================================================\n\nexport const BLOCK_LENGTH_THRESHOLD = 1000;\nexport const BLOCK_LIST_THRESHOLD = 3;\n\n// ============================================================\n// NEURAL DEFAULTS\n// ============================================================\n\nexport const NEURAL_DEFAULTS = {\n  stability: 0.5,\n  retrievability: 1.0,\n  accessCount: 0,\n} as const;\n\n// ============================================================\n// EXTRACTION DEPTH\n// ============================================================\n\nexport const EXTRACTION_DEPTHS = ['summary', 'section', 'full'] as const;\n\nexport type ExtractionDepth = (typeof EXTRACTION_DEPTHS)[number];\n\n// ============================================================\n// REGEX PATTERNS\n// ============================================================\n\nexport const HEADING_PATTERN = /^#{1,6}\\s/m;\nexport const LIST_ITEM_PATTERN = /^[-*]\\s/gm;\n","/**\n * @module @nous/core/blocks\n * @description Block structure for long-form content with stable IDs\n * @version 0.1.0\n * @spec Brainstorms/Specs/storm-011/spec/block-schema.ts\n *\n * Blocks enable:\n * - Semantic anchor editing (target by heading, block ID)\n * - Stable references during sync\n * - Structured content preservation\n */\n\nimport { z } from 'zod';\nimport { nanoid } from 'nanoid';\nimport {\n  NANOID_LENGTH,\n  BLOCK_ID_PREFIX,\n  BLOCK_TYPES,\n  BLOCK_LENGTH_THRESHOLD,\n  BLOCK_LIST_THRESHOLD,\n  HEADING_PATTERN,\n  LIST_ITEM_PATTERN,\n  type BlockType,\n  type ContentSource,\n} from '../constants';\n\n// ============================================================\n// ID GENERATION\n// ============================================================\n\n/**\n * Generates a globally unique block ID.\n * Format: \"b_\" + 12-character nanoid\n */\nexport function generateBlockId(): string {\n  return BLOCK_ID_PREFIX + nanoid(NANOID_LENGTH);\n}\n\n// ============================================================\n// BLOCK INTERFACE\n// ============================================================\n\n/**\n * A structural block within a node's content.\n */\nexport interface Block {\n  /** Globally unique block ID. Format: \"b_\" + nanoid(12) */\n  id: string;\n  /** Block type determines rendering and behavior */\n  type: BlockType;\n  /** The actual content of this block */\n  content: string;\n  /** Heading level (1-6). Only used for 'heading' type blocks. */\n  level?: number;\n  /** Child blocks for nested content. */\n  children?: Block[];\n  /** When this block was created (ISO 8601) */\n  created: string;\n  /** When this block was last modified (ISO 8601) */\n  modified: string;\n}\n\nexport const BlockSchema: z.ZodType<Block> = z.lazy(() =>\n  z.object({\n    id: z.string().regex(/^b_[a-zA-Z0-9_-]{12}$/),\n    type: z.enum(BLOCK_TYPES),\n    content: z.string(),\n    level: z.number().int().min(1).max(6).optional(),\n    children: z.array(BlockSchema).optional(),\n    created: z.string().datetime(),\n    modified: z.string().datetime(),\n  })\n);\n\n// ============================================================\n// BLOCK DECISION FUNCTIONS\n// ============================================================\n\n/**\n * Determines if content should use block structure.\n *\n * Rules (from storm-011 v4):\n * 1. Length > 1000 chars → YES\n * 2. Has markdown headings → YES\n * 3. Has 3+ list items → YES\n * 4. Source is 'import' or 'user_note' → YES\n * 5. Source is 'chat_extraction' or 'fact' → NO\n * 6. Default → NO\n */\nexport function shouldUseBlocks(content: string, source: ContentSource): boolean {\n  // Rule 1: Length threshold\n  if (content.length > BLOCK_LENGTH_THRESHOLD) {\n    return true;\n  }\n\n  // Rule 2: Has natural structure (headings)\n  if (hasHeadings(content)) {\n    return true;\n  }\n\n  // Rule 3: Has natural structure (multiple lists)\n  if (hasMultipleLists(content)) {\n    return true;\n  }\n\n  // Rule 4: Source types that always use blocks\n  if (source === 'import' || source === 'user_note') {\n    return true;\n  }\n\n  // Rule 5: Source types that never use blocks\n  if (source === 'chat_extraction' || source === 'fact') {\n    return false;\n  }\n\n  // Default: no blocks\n  return false;\n}\n\n/**\n * Checks if content contains markdown headings.\n */\nexport function hasHeadings(content: string): boolean {\n  return HEADING_PATTERN.test(content);\n}\n\n/**\n * Checks if content has multiple list items.\n */\nexport function hasMultipleLists(content: string): boolean {\n  const matches = content.match(LIST_ITEM_PATTERN) || [];\n  return matches.length >= BLOCK_LIST_THRESHOLD;\n}\n\n// ============================================================\n// BLOCK CREATION\n// ============================================================\n\n/**\n * Creates a new block with generated ID and timestamps.\n */\nexport function createBlock(\n  type: BlockType,\n  content: string,\n  options: { level?: number; children?: Block[] } = {}\n): Block {\n  const now = new Date().toISOString();\n  return {\n    id: generateBlockId(),\n    type,\n    content,\n    level: options.level,\n    children: options.children,\n    created: now,\n    modified: now,\n  };\n}\n\n// ============================================================\n// BLOCK PARSING\n// ============================================================\n\n/**\n * Parses markdown content into block structure.\n */\nexport function parseIntoBlocks(body: string): Block[] {\n  const blocks: Block[] = [];\n  const lines = body.split('\\n');\n\n  let currentParagraph: string[] = [];\n\n  const flushParagraph = (): void => {\n    if (currentParagraph.length > 0) {\n      const content = currentParagraph.join('\\n').trim();\n      if (content) {\n        blocks.push(createBlock('paragraph', content));\n      }\n      currentParagraph = [];\n    }\n  };\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    if (line === undefined) continue;\n\n    // Heading detection\n    const headingMatch = line.match(/^(#{1,6})\\s+(.+)$/);\n    if (headingMatch && headingMatch[1] && headingMatch[2]) {\n      flushParagraph();\n      blocks.push(\n        createBlock('heading', headingMatch[2], {\n          level: headingMatch[1].length,\n        })\n      );\n      continue;\n    }\n\n    // Code block detection\n    if (line.startsWith('```')) {\n      flushParagraph();\n      const codeLines: string[] = [];\n      i++; // Move past opening ```\n      while (i < lines.length) {\n        const codeLine = lines[i];\n        if (codeLine === undefined || codeLine.startsWith('```')) break;\n        codeLines.push(codeLine);\n        i++;\n      }\n      blocks.push(createBlock('code', codeLines.join('\\n')));\n      continue;\n    }\n\n    // Quote detection\n    if (line.startsWith('> ')) {\n      flushParagraph();\n      const quoteContent = line.slice(2);\n      blocks.push(createBlock('quote', quoteContent));\n      continue;\n    }\n\n    // List detection\n    const listMatch = line.match(/^[-*]\\s+(.+)$/);\n    if (listMatch && listMatch[1]) {\n      flushParagraph();\n\n      // Collect all consecutive list items\n      const listItems: Block[] = [];\n      while (i < lines.length) {\n        const currentLine = lines[i];\n        if (currentLine === undefined) break;\n        const itemMatch = currentLine.match(/^[-*]\\s+(.+)$/);\n        if (!itemMatch || !itemMatch[1]) break;\n        listItems.push(createBlock('list_item', itemMatch[1]));\n        i++;\n      }\n      i--; // Back up one since loop will increment\n\n      blocks.push(createBlock('list', '', { children: listItems }));\n      continue;\n    }\n\n    // Divider detection\n    if (line.match(/^[-*_]{3,}$/)) {\n      flushParagraph();\n      blocks.push(createBlock('divider', ''));\n      continue;\n    }\n\n    // Empty line ends paragraph\n    if (line.trim() === '') {\n      flushParagraph();\n      continue;\n    }\n\n    // Regular content → accumulate in paragraph\n    currentParagraph.push(line);\n  }\n\n  // Flush any remaining paragraph\n  flushParagraph();\n\n  return blocks;\n}\n\n// ============================================================\n// BODY DERIVATION\n// ============================================================\n\n/**\n * Derives markdown body from block structure.\n * This is the inverse of parseIntoBlocks.\n */\nexport function deriveBody(blocks: Block[]): string {\n  return blocks.map((block) => blockToMarkdown(block)).join('\\n\\n');\n}\n\n/**\n * Converts a single block to markdown.\n */\nfunction blockToMarkdown(block: Block): string {\n  switch (block.type) {\n    case 'heading':\n      return '#'.repeat(block.level || 1) + ' ' + block.content;\n\n    case 'paragraph':\n      return block.content;\n\n    case 'list':\n      return (block.children || []).map((child) => '- ' + child.content).join('\\n');\n\n    case 'list_item':\n      return '- ' + block.content;\n\n    case 'quote':\n      return '> ' + block.content;\n\n    case 'code':\n      return '```\\n' + block.content + '\\n```';\n\n    case 'callout':\n      return '> [!note]\\n> ' + block.content;\n\n    case 'divider':\n      return '---';\n\n    case 'table':\n      return block.content;\n\n    case 'image':\n      return block.content;\n\n    default:\n      return block.content;\n  }\n}\n\n// ============================================================\n// BLOCK UTILITIES\n// ============================================================\n\n/**\n * Finds a block by ID within a block tree.\n */\nexport function findBlockById(blocks: Block[], blockId: string): Block | undefined {\n  for (const block of blocks) {\n    if (block.id === blockId) {\n      return block;\n    }\n    if (block.children) {\n      const found = findBlockById(block.children, blockId);\n      if (found) return found;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Finds a block by heading text.\n */\nexport function findBlockByHeading(\n  blocks: Block[],\n  heading: string,\n  level?: number\n): Block | undefined {\n  for (const block of blocks) {\n    if (block.type === 'heading') {\n      const matchesText = block.content.toLowerCase() === heading.toLowerCase();\n      const matchesLevel = level === undefined || block.level === level;\n      if (matchesText && matchesLevel) {\n        return block;\n      }\n    }\n    if (block.children) {\n      const found = findBlockByHeading(block.children, heading, level);\n      if (found) return found;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Gets all block IDs in a block tree.\n */\nexport function getAllBlockIds(blocks: Block[]): string[] {\n  const ids: string[] = [];\n  for (const block of blocks) {\n    ids.push(block.id);\n    if (block.children) {\n      ids.push(...getAllBlockIds(block.children));\n    }\n  }\n  return ids;\n}\n\n/**\n * Updates a block's modified timestamp.\n */\nexport function touchBlock(block: Block): Block {\n  return {\n    ...block,\n    modified: new Date().toISOString(),\n  };\n}\n\n/**\n * Counts total number of blocks including nested children.\n */\nexport function countBlocks(blocks: Block[]): number {\n  let count = 0;\n  for (const block of blocks) {\n    count++;\n    if (block.children) {\n      count += countBlocks(block.children);\n    }\n  }\n  return count;\n}\n\n// ============================================================\n// RE-EXPORTS\n// ============================================================\n\nexport type { BlockType, ContentSource };\n","/**\n * @module @nous/core/temporal\n * @description Four-type temporal model for time handling\n * @version 0.1.0\n * @spec Brainstorms/Specs/storm-011/spec/temporal-model.ts\n *\n * Nous distinguishes FOUR types of time:\n * 1. Ingestion time - When user added content to Nous\n * 2. Event time - When the event actually happened\n * 3. Content times - Times mentioned IN the content\n * 4. Reference patterns - How user typically recalls it\n */\n\nimport { z } from 'zod';\nimport {\n  EVENT_TIME_SOURCES,\n  CONTENT_TIME_TYPES,\n  type EventTimeSource,\n  type ContentTimeType,\n  type TemporalGranularity,\n} from '../constants';\n\n// ============================================================\n// INGESTION TIME\n// ============================================================\n\n/**\n * When the user added this content to Nous.\n * This is always known with certainty.\n */\nexport interface IngestionTime {\n  /** When content was added (ISO 8601) */\n  timestamp: string;\n  /** User's timezone when they added it */\n  timezone: string;\n}\n\nexport const IngestionTimeSchema = z.object({\n  timestamp: z.string().datetime(),\n  timezone: z.string(),\n});\n\n// ============================================================\n// EVENT TIME\n// ============================================================\n\n/**\n * When the event actually happened (if different from ingestion).\n */\nexport interface EventTime {\n  /** When the event occurred (ISO 8601) */\n  timestamp: string;\n  /** Confidence in this timestamp (0-1) */\n  confidence: number;\n  /** How this time was determined */\n  source: EventTimeSource;\n}\n\nexport const EventTimeSchema = z.object({\n  timestamp: z.string().datetime(),\n  confidence: z.number().min(0).max(1),\n  source: z.enum(EVENT_TIME_SOURCES),\n});\n\n// ============================================================\n// CONTENT TIME\n// ============================================================\n\n/**\n * A time mentioned WITHIN the content itself.\n */\nexport interface ContentTime {\n  /** Original text mentioning time */\n  text: string;\n  /** Resolved timestamp (ISO 8601) */\n  resolved: string;\n  /** Type of time reference */\n  type: ContentTimeType;\n  /** Confidence in the resolution (0-1) */\n  confidence: number;\n}\n\nexport const ContentTimeSchema = z.object({\n  text: z.string(),\n  resolved: z.string().datetime(),\n  type: z.enum(CONTENT_TIME_TYPES),\n  confidence: z.number().min(0).max(1),\n});\n\n// ============================================================\n// TEMPORAL MODEL\n// ============================================================\n\n/**\n * Complete temporal model for a node.\n * Implements the four-type system from storm-011 v2.\n */\nexport interface TemporalModel {\n  /** When user added this to Nous. ALWAYS present. */\n  ingestion: IngestionTime;\n  /** When the event happened. Present for episodes and time-anchored content. */\n  event?: EventTime;\n  /** Times mentioned IN the content. Extracted during processing. */\n  content_times?: ContentTime[];\n  /** How user typically refers to this. Built from access patterns. */\n  reference_patterns?: string[];\n}\n\nexport const TemporalModelSchema = z.object({\n  ingestion: IngestionTimeSchema,\n  event: EventTimeSchema.optional(),\n  content_times: z.array(ContentTimeSchema).optional(),\n  reference_patterns: z.array(z.string()).optional(),\n});\n\n// ============================================================\n// TEMPORAL CONFIDENCE\n// ============================================================\n\n/**\n * Three-factor temporal confidence from storm-004.\n */\nexport interface TemporalConfidence {\n  /** Confidence in time source */\n  source: number;\n  /** Confidence in granularity */\n  granularity: number;\n  /** Confidence in interpretation */\n  interpretation: number;\n  /** Combined score: source × granularity × interpretation */\n  combined: number;\n}\n\nexport const TemporalConfidenceSchema = z.object({\n  source: z.number().min(0).max(1),\n  granularity: z.number().min(0).max(1),\n  interpretation: z.number().min(0).max(1),\n  combined: z.number().min(0).max(1),\n});\n\n// ============================================================\n// FACTORY FUNCTIONS\n// ============================================================\n\n/**\n * Creates a basic temporal model for new content.\n */\nexport function createTemporalModel(timezone?: string): TemporalModel {\n  return {\n    ingestion: {\n      timestamp: new Date().toISOString(),\n      timezone: timezone ?? Intl.DateTimeFormat().resolvedOptions().timeZone,\n    },\n  };\n}\n\n/**\n * Adds event time to a temporal model.\n */\nexport function addEventTime(\n  temporal: TemporalModel,\n  eventTimestamp: string | Date,\n  source: EventTimeSource,\n  confidence: number = 1.0\n): TemporalModel {\n  return {\n    ...temporal,\n    event: {\n      timestamp:\n        typeof eventTimestamp === 'string'\n          ? eventTimestamp\n          : eventTimestamp.toISOString(),\n      source,\n      confidence,\n    },\n  };\n}\n\n/**\n * Adds a content time reference.\n */\nexport function addContentTime(\n  temporal: TemporalModel,\n  contentTime: ContentTime\n): TemporalModel {\n  return {\n    ...temporal,\n    content_times: [...(temporal.content_times ?? []), contentTime],\n  };\n}\n\n/**\n * Adds a reference pattern.\n */\nexport function addReferencePattern(\n  temporal: TemporalModel,\n  pattern: string\n): TemporalModel {\n  const existing = temporal.reference_patterns ?? [];\n  if (existing.includes(pattern)) {\n    return temporal;\n  }\n  return {\n    ...temporal,\n    reference_patterns: [...existing, pattern],\n  };\n}\n\n/**\n * Calculates combined temporal confidence.\n */\nexport function calculateTemporalConfidence(\n  source: number,\n  granularity: number,\n  interpretation: number\n): TemporalConfidence {\n  return {\n    source,\n    granularity,\n    interpretation,\n    combined: source * granularity * interpretation,\n  };\n}\n\n// ============================================================\n// QUERY HELPERS\n// ============================================================\n\nexport type TimeQueryType = 'ingestion' | 'event' | 'content' | 'any';\n\n/**\n * Checks if a temporal model matches a time range query.\n */\nexport function matchesTimeRange(\n  temporal: TemporalModel,\n  start: string,\n  end: string,\n  queryType: TimeQueryType = 'any'\n): boolean {\n  const startDate = new Date(start);\n  const endDate = new Date(end);\n\n  const inRange = (timestamp: string): boolean => {\n    const date = new Date(timestamp);\n    return date >= startDate && date <= endDate;\n  };\n\n  // Check ingestion time\n  if (queryType === 'ingestion' || queryType === 'any') {\n    if (inRange(temporal.ingestion.timestamp)) {\n      return true;\n    }\n  }\n\n  // Check event time\n  if (queryType === 'event' || queryType === 'any') {\n    if (temporal.event && inRange(temporal.event.timestamp)) {\n      return true;\n    }\n  }\n\n  // Check content times\n  if (queryType === 'content' || queryType === 'any') {\n    if (temporal.content_times) {\n      for (const ct of temporal.content_times) {\n        if (inRange(ct.resolved)) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Gets the \"primary\" timestamp for a node.\n * Prefers event time if available, falls back to ingestion.\n */\nexport function getPrimaryTimestamp(temporal: TemporalModel): string {\n  return temporal.event?.timestamp ?? temporal.ingestion.timestamp;\n}\n\n/**\n * Checks if reference patterns match a query.\n */\nexport function matchesReferencePattern(\n  temporal: TemporalModel,\n  query: string\n): boolean {\n  if (!temporal.reference_patterns) {\n    return false;\n  }\n\n  const queryLower = query.toLowerCase();\n  return temporal.reference_patterns.some((pattern) => {\n    const patternLower = pattern.toLowerCase();\n    return queryLower.includes(patternLower) || patternLower.includes(queryLower);\n  });\n}\n\n// ============================================================\n// RE-EXPORTS\n// ============================================================\n\nexport type { EventTimeSource, ContentTimeType, TemporalGranularity };\n","/**\n * @module @nous/core/nodes\n * @description Node types, schemas, and creation utilities - Universal Node Schema (UNS)\n * @version 0.1.0\n * @spec Brainstorms/Specs/storm-011/spec/node-schema.ts\n *\n * This module defines the core data structures for all nodes in Nous.\n * Every other infrastructure component depends on these interfaces.\n */\n\nimport { z } from 'zod';\nimport { nanoid } from 'nanoid';\nimport {\n  NANOID_LENGTH,\n  NODE_ID_PREFIX,\n  NODE_TYPES,\n  CONCEPT_SUBTYPES,\n  EPISODE_SUBTYPES,\n  RAW_SUBTYPES,\n  LIFECYCLE_STATES,\n  SOURCE_TYPES,\n  EXTRACTION_DEPTHS,\n  MODIFIERS,\n  NEURAL_DEFAULTS,\n  type NodeType,\n  type ConceptSubtype,\n  type EpisodeSubtype,\n  type RawSubtype,\n  type LifecycleState,\n  type SourceType,\n  type ExtractionDepth,\n  type Modifier,\n} from '../constants';\nimport { type Block, BlockSchema } from '../blocks';\nimport {\n  type TemporalModel,\n  TemporalModelSchema,\n  createTemporalModel,\n} from '../temporal';\n\n// ============================================================\n// ID GENERATION\n// ============================================================\n\n/**\n * Generates a globally unique node ID.\n * Format: \"n_\" + 12-character nanoid\n */\nexport function generateNodeId(): string {\n  return NODE_ID_PREFIX + nanoid(NANOID_LENGTH);\n}\n\n// ============================================================\n// EMBEDDING (Placeholder for storm-016)\n// ============================================================\n\n/**\n * Embedding field structure.\n * Actual embedding logic defined in storm-016.\n */\nexport interface EmbeddingField {\n  /** Dense vector representation */\n  vector: Float32Array;\n  /** Model that generated the embedding */\n  model: string;\n  /** When embedding was generated (ISO 8601) */\n  created_at: string;\n}\n\nexport const EmbeddingFieldSchema = z.object({\n  vector: z.instanceof(Float32Array),\n  model: z.string(),\n  created_at: z.string().datetime(),\n});\n\n// ============================================================\n// NEURAL PROPERTIES\n// ============================================================\n\n/**\n * Neural properties for SSA activation and decay.\n */\nexport interface NeuralProperties {\n  /** Stability: How well-established this memory is (0-1) */\n  stability: number;\n  /** Retrievability: Current ability to recall (0-1) */\n  retrievability: number;\n  /** Last time this node was accessed (ISO 8601) */\n  last_accessed: string;\n  /** Total number of times accessed */\n  access_count: number;\n}\n\nexport const NeuralPropertiesSchema = z.object({\n  stability: z.number().min(0).max(1),\n  retrievability: z.number().min(0).max(1),\n  last_accessed: z.string().datetime(),\n  access_count: z.number().int().min(0),\n});\n\n/**\n * Creates default neural properties for a new node.\n */\nexport function createDefaultNeuralProperties(): NeuralProperties {\n  return {\n    stability: NEURAL_DEFAULTS.stability,\n    retrievability: NEURAL_DEFAULTS.retrievability,\n    last_accessed: new Date().toISOString(),\n    access_count: NEURAL_DEFAULTS.accessCount,\n  };\n}\n\n// ============================================================\n// PROVENANCE\n// ============================================================\n\n/**\n * Tracks where content came from.\n */\nexport interface Provenance {\n  /** How this node was created */\n  source: SourceType;\n  /** Parent node ID (episode, document, etc.) */\n  parent_id?: string;\n  /** Confidence in the extraction/creation (0-1) */\n  confidence: number;\n}\n\nexport const ProvenanceSchema = z.object({\n  source: z.enum(SOURCE_TYPES),\n  parent_id: z.string().optional(),\n  confidence: z.number().min(0).max(1),\n});\n\n// ============================================================\n// NODE STATE\n// ============================================================\n\n/**\n * Current state of the node.\n */\nexport interface NodeState {\n  /** How deeply this node has been extracted */\n  extraction_depth: ExtractionDepth;\n  /** Current lifecycle state */\n  lifecycle: LifecycleState;\n}\n\nexport const NodeStateSchema = z.object({\n  extraction_depth: z.enum(EXTRACTION_DEPTHS),\n  lifecycle: z.enum(LIFECYCLE_STATES),\n});\n\n// ============================================================\n// VERSIONING\n// ============================================================\n\n/**\n * Version tracking for conflict detection.\n */\nexport interface NodeVersion {\n  /** Increments on every edit */\n  version: number;\n  /** When last modified (ISO 8601) */\n  lastModified: string;\n  /** Who made the last modification */\n  lastModifier: Modifier;\n  /** Content hash for validation (optional) */\n  checksum?: string;\n}\n\nexport const NodeVersionSchema = z.object({\n  version: z.number().int().min(1),\n  lastModified: z.string().datetime(),\n  lastModifier: z.enum(MODIFIERS),\n  checksum: z.string().optional(),\n});\n\n/**\n * Creates initial versioning for a new node.\n */\nexport function createInitialVersion(modifier: Modifier = 'system'): NodeVersion {\n  return {\n    version: 1,\n    lastModified: new Date().toISOString(),\n    lastModifier: modifier,\n  };\n}\n\n// ============================================================\n// NODE CONTENT\n// ============================================================\n\n/**\n * Content structure for nodes.\n */\nexport interface NodeContent {\n  /** Short title/label */\n  title: string;\n  /** Main content body */\n  body?: string;\n  /** AI-generated summary */\n  summary?: string;\n  /** Structured content blocks (optional) */\n  blocks?: Block[];\n}\n\nexport const NodeContentSchema = z.object({\n  title: z.string().min(1).max(200),\n  body: z.string().optional(),\n  summary: z.string().optional(),\n  blocks: z.array(BlockSchema).optional(),\n});\n\n// ============================================================\n// BASE NODE INTERFACE\n// ============================================================\n\n/**\n * Universal Node Schema (UNS) - Base interface all nodes extend.\n */\nexport interface NousNode {\n  /** Globally unique identifier */\n  id: string;\n  /** Node type determines behavior and storage layer */\n  type: NodeType;\n  /** Type-specific subtype */\n  subtype?: string;\n  /** The actual content of the node */\n  content: NodeContent;\n  /** Vector embedding for semantic search */\n  embedding?: EmbeddingField;\n  /** Four-type temporal model */\n  temporal: TemporalModel;\n  /** Properties for SSA and decay */\n  neural: NeuralProperties;\n  /** Where this content came from */\n  provenance: Provenance;\n  /** Current node state */\n  state: NodeState;\n  /** Version tracking for editing and sync */\n  versioning: NodeVersion;\n}\n\nexport const NousNodeSchema = z.object({\n  id: z.string().regex(/^n_[a-zA-Z0-9_-]{12}$/),\n  type: z.enum(NODE_TYPES),\n  subtype: z.string().optional(),\n  content: NodeContentSchema,\n  embedding: EmbeddingFieldSchema.optional(),\n  temporal: TemporalModelSchema,\n  neural: NeuralPropertiesSchema,\n  provenance: ProvenanceSchema,\n  state: NodeStateSchema,\n  versioning: NodeVersionSchema,\n});\n\n// ============================================================\n// TYPE-SPECIFIC EXTENSIONS\n// ============================================================\n\n/**\n * Concept Node - Atomic piece of knowledge.\n */\nexport interface ConceptNode extends NousNode {\n  type: 'concept';\n  subtype: ConceptSubtype;\n}\n\nexport const ConceptNodeSchema = NousNodeSchema.extend({\n  type: z.literal('concept'),\n  subtype: z.union([z.enum(CONCEPT_SUBTYPES), z.string().regex(/^custom:.+$/)]),\n});\n\n/**\n * Episode-specific metadata.\n */\nexport interface EpisodeMetadata {\n  duration_minutes?: number;\n  concept_links: string[];\n  archive_link?: string;\n  participants?: string[];\n  location?: string;\n  temporal_confidence: {\n    source: number;\n    granularity: number;\n    interpretation: number;\n    combined: number;\n  };\n}\n\nexport const EpisodeMetadataSchema = z.object({\n  duration_minutes: z.number().positive().optional(),\n  concept_links: z.array(z.string()),\n  archive_link: z.string().optional(),\n  participants: z.array(z.string()).optional(),\n  location: z.string().optional(),\n  temporal_confidence: z.object({\n    source: z.number().min(0).max(1),\n    granularity: z.number().min(0).max(1),\n    interpretation: z.number().min(0).max(1),\n    combined: z.number().min(0).max(1),\n  }),\n});\n\n/**\n * Episode Node - Time-anchored event container.\n */\nexport interface EpisodeNode extends NousNode {\n  type: 'episode';\n  subtype: EpisodeSubtype;\n  episode_specific: EpisodeMetadata;\n}\n\nexport const EpisodeNodeSchema = NousNodeSchema.extend({\n  type: z.literal('episode'),\n  subtype: z.union([z.enum(EPISODE_SUBTYPES), z.string().regex(/^custom:.+$/)]),\n  episode_specific: EpisodeMetadataSchema,\n});\n\n/**\n * Document-specific metadata.\n */\nexport interface DocumentMetadata {\n  format: string;\n  page_count?: number;\n  word_count: number;\n  sections: string[];\n  extraction_status: 'minimal' | 'structural' | 'partial' | 'complete';\n}\n\nexport const DocumentMetadataSchema = z.object({\n  format: z.string(),\n  page_count: z.number().int().positive().optional(),\n  word_count: z.number().int().min(0),\n  sections: z.array(z.string()),\n  extraction_status: z.enum(['minimal', 'structural', 'partial', 'complete']),\n});\n\n/**\n * Document Node - Container for large inputs.\n */\nexport interface DocumentNode extends NousNode {\n  type: 'document';\n  document_specific: DocumentMetadata;\n}\n\nexport const DocumentNodeSchema = NousNodeSchema.extend({\n  type: z.literal('document'),\n  document_specific: DocumentMetadataSchema,\n});\n\n/**\n * Section-specific metadata.\n */\nexport interface SectionMetadata {\n  document_id: string;\n  heading: string;\n  position: number;\n  extracted: boolean;\n  concepts: string[];\n}\n\nexport const SectionMetadataSchema = z.object({\n  document_id: z.string(),\n  heading: z.string(),\n  position: z.number().int().min(0),\n  extracted: z.boolean(),\n  concepts: z.array(z.string()),\n});\n\n/**\n * Section Node - Hierarchical part of a document.\n */\nexport interface SectionNode extends NousNode {\n  type: 'section';\n  section_specific: SectionMetadata;\n}\n\nexport const SectionNodeSchema = NousNodeSchema.extend({\n  type: z.literal('section'),\n  section_specific: SectionMetadataSchema,\n});\n\n/**\n * Raw-specific metadata.\n */\nexport interface RawMetadata {\n  content_type: 'text' | 'transcript' | 'document' | 'image' | 'audio';\n  original_format?: string;\n  file_size_bytes?: number;\n  word_count?: number;\n  episode_link?: string;\n  extraction_status: 'pending' | 'processing' | 'complete' | 'failed';\n}\n\nexport const RawMetadataSchema = z.object({\n  content_type: z.enum(['text', 'transcript', 'document', 'image', 'audio']),\n  original_format: z.string().optional(),\n  file_size_bytes: z.number().int().positive().optional(),\n  word_count: z.number().int().min(0).optional(),\n  episode_link: z.string().optional(),\n  extraction_status: z.enum(['pending', 'processing', 'complete', 'failed']),\n});\n\n/**\n * Raw Node - Full verbatim archive content.\n */\nexport interface RawNode extends NousNode {\n  type: 'raw';\n  subtype: RawSubtype;\n  raw_specific: RawMetadata;\n}\n\nexport const RawNodeSchema = NousNodeSchema.extend({\n  type: z.literal('raw'),\n  subtype: z.enum(RAW_SUBTYPES),\n  raw_specific: RawMetadataSchema,\n});\n\n/**\n * Note Node - User-created note.\n */\nexport interface NoteNode extends NousNode {\n  type: 'note';\n}\n\nexport const NoteNodeSchema = NousNodeSchema.extend({\n  type: z.literal('note'),\n});\n\n/**\n * Chunk Node - Semantic unit extracted from content.\n */\nexport interface ChunkNode extends NousNode {\n  type: 'chunk';\n}\n\nexport const ChunkNodeSchema = NousNodeSchema.extend({\n  type: z.literal('chunk'),\n});\n\n// ============================================================\n// UNION TYPE\n// ============================================================\n\n/**\n * Union of all node types.\n */\nexport type AnyNode =\n  | ConceptNode\n  | EpisodeNode\n  | DocumentNode\n  | SectionNode\n  | RawNode\n  | NoteNode\n  | ChunkNode;\n\n/**\n * Schema that validates any node type.\n */\nexport const AnyNodeSchema = z.discriminatedUnion('type', [\n  ConceptNodeSchema,\n  EpisodeNodeSchema,\n  DocumentNodeSchema,\n  SectionNodeSchema,\n  RawNodeSchema,\n  NoteNodeSchema,\n  ChunkNodeSchema,\n]);\n\n// ============================================================\n// FACTORY FUNCTIONS\n// ============================================================\n\nexport interface CreateNodeOptions {\n  subtype?: string;\n  source?: SourceType;\n  confidence?: number;\n  parent_id?: string;\n  modifier?: Modifier;\n  timezone?: string;\n}\n\n/**\n * Creates a new node with default values.\n */\nexport function createNode(\n  type: NodeType,\n  content: NodeContent,\n  options: CreateNodeOptions = {}\n): NousNode {\n  return {\n    id: generateNodeId(),\n    type,\n    subtype: options.subtype,\n    content,\n    temporal: createTemporalModel(options.timezone),\n    neural: createDefaultNeuralProperties(),\n    provenance: {\n      source: options.source ?? 'manual',\n      parent_id: options.parent_id,\n      confidence: options.confidence ?? 1.0,\n    },\n    state: {\n      extraction_depth: 'full',\n      lifecycle: 'working',\n    },\n    versioning: createInitialVersion(options.modifier ?? 'user'),\n  };\n}\n\n/**\n * Creates a concept node.\n */\nexport function createConceptNode(\n  title: string,\n  body: string,\n  subtype: ConceptSubtype,\n  options: CreateNodeOptions = {}\n): ConceptNode {\n  const base = createNode('concept', { title, body }, { ...options, subtype });\n  return base as ConceptNode;\n}\n\n/**\n * Creates a note node.\n */\nexport function createNoteNode(\n  title: string,\n  body: string,\n  options: CreateNodeOptions = {}\n): NoteNode {\n  const base = createNode('note', { title, body }, options);\n  return base as NoteNode;\n}\n\n/**\n * Updates a node's access tracking (for SSA/decay).\n */\nexport function recordAccess(node: NousNode): NousNode {\n  return {\n    ...node,\n    neural: {\n      ...node.neural,\n      last_accessed: new Date().toISOString(),\n      access_count: node.neural.access_count + 1,\n    },\n  };\n}\n\n/**\n * Updates a node's lifecycle state.\n */\nexport function updateLifecycle(node: NousNode, lifecycle: LifecycleState): NousNode {\n  return {\n    ...node,\n    state: {\n      ...node.state,\n      lifecycle,\n    },\n  };\n}\n\n// ============================================================\n// RE-EXPORTS\n// ============================================================\n\nexport type {\n  NodeType,\n  ConceptSubtype,\n  EpisodeSubtype,\n  RawSubtype,\n  LifecycleState,\n  SourceType,\n  ExtractionDepth,\n  Modifier,\n  Block,\n  TemporalModel,\n};\n"]}