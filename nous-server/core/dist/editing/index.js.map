{"version":3,"sources":["../../src/constants.ts","../../src/blocks/index.ts","../../src/editing/index.ts"],"names":["nanoid","z"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * @module @nous/core/constants\n * @description All constants, enums, and configuration values\n * @version 0.1.0\n * @spec Brainstorms/Specs/storm-011/spec/constants.ts\n */\n\n// ============================================================\n// ID CONFIGURATION\n// ============================================================\n\n/** Length of nanoid for globally unique IDs */\nexport const NANOID_LENGTH = 12;\n\n/** Prefix for node IDs: \"n_\" + nanoid(12) */\nexport const NODE_ID_PREFIX = 'n_';\n\n/** Prefix for block IDs: \"b_\" + nanoid(12) */\nexport const BLOCK_ID_PREFIX = 'b_';\n\n/** Prefix for edge IDs: \"e_\" + nanoid(12) */\nexport const EDGE_ID_PREFIX = 'e_';\n\n/** Prefix for edit record IDs: \"edit_\" + nanoid(12) */\nexport const EDIT_ID_PREFIX = 'edit_';\n\n// ============================================================\n// NODE TYPES\n// ============================================================\n\nexport const NODE_TYPES = [\n  'concept',\n  'episode',\n  'document',\n  'section',\n  'chunk',\n  'note',\n  'raw',\n] as const;\n\nexport type NodeType = (typeof NODE_TYPES)[number];\n\nexport const SEMANTIC_LAYER_TYPES: NodeType[] = ['concept', 'note', 'chunk'];\nexport const EPISODE_LAYER_TYPES: NodeType[] = ['episode', 'document', 'section'];\nexport const ARCHIVE_LAYER_TYPES: NodeType[] = ['raw'];\n\n// ============================================================\n// SUBTYPES\n// ============================================================\n\nexport const CONCEPT_SUBTYPES = [\n  'fact',\n  'definition',\n  'relationship',\n  'preference',\n  'belief',\n  'procedure',\n  'entity',\n  'event',\n  'insight',\n] as const;\n\nexport type ConceptSubtype = (typeof CONCEPT_SUBTYPES)[number] | `custom:${string}`;\n\nexport const EPISODE_SUBTYPES = [\n  'lecture',\n  'meeting',\n  'conversation',\n  'note_session',\n  'document_read',\n  'thought',\n  'external_event',\n] as const;\n\nexport type EpisodeSubtype = (typeof EPISODE_SUBTYPES)[number] | `custom:${string}`;\n\nexport const RAW_SUBTYPES = [\n  'transcript',\n  'document',\n  'note',\n  'image',\n  'audio_recording',\n] as const;\n\nexport type RawSubtype = (typeof RAW_SUBTYPES)[number];\n\n// ============================================================\n// BLOCK TYPES\n// ============================================================\n\nexport const BLOCK_TYPES = [\n  'paragraph',\n  'heading',\n  'list',\n  'list_item',\n  'code',\n  'quote',\n  'callout',\n  'divider',\n  'table',\n  'image',\n] as const;\n\nexport type BlockType = (typeof BLOCK_TYPES)[number];\n\n// ============================================================\n// EDGE TYPES\n// ============================================================\n\nexport const EDGE_TYPES = [\n  'relates_to',\n  'part_of',\n  'mentioned_in',\n  'causes',\n  'precedes',\n  'contradicts',\n  'supersedes',\n  'derived_from',\n  'similar_to',\n] as const;\n\nexport type EdgeType = (typeof EDGE_TYPES)[number];\n\n// ============================================================\n// LIFECYCLE STATES\n// ============================================================\n\nexport const LIFECYCLE_STATES = [\n  'working',\n  'active',\n  'superseded',\n  'dormant',\n  'archived',\n] as const;\n\nexport type LifecycleState = (typeof LIFECYCLE_STATES)[number];\n\n// ============================================================\n// SOURCE TYPES\n// ============================================================\n\nexport const SOURCE_TYPES = [\n  'extraction',\n  'manual',\n  'inference',\n  'import',\n] as const;\n\nexport type SourceType = (typeof SOURCE_TYPES)[number];\n\n// ============================================================\n// CONTENT SOURCES\n// ============================================================\n\nexport const CONTENT_SOURCES = [\n  'import',\n  'user_note',\n  'chat_extraction',\n  'fact',\n  'document',\n  'transcript',\n] as const;\n\nexport type ContentSource = (typeof CONTENT_SOURCES)[number];\n\n// ============================================================\n// EDIT SYSTEM\n// ============================================================\n\nexport const EDIT_TARGET_METHODS = [\n  'block_id',\n  'heading',\n  'position',\n  'search',\n  'full',\n] as const;\n\nexport type EditTargetMethod = (typeof EDIT_TARGET_METHODS)[number];\n\nexport const EDIT_ACTIONS = ['replace', 'insert', 'append', 'delete'] as const;\n\nexport type EditAction = (typeof EDIT_ACTIONS)[number];\n\nexport const MODIFIERS = ['user', 'ai', 'system', 'sync'] as const;\n\nexport type Modifier = (typeof MODIFIERS)[number];\n\nexport const EDIT_HISTORY_RETENTION = {\n  maxEdits: 100,\n  maxAgeDays: 30,\n  undoWindowHours: 24,\n  pruneSchedule: 'daily',\n} as const;\n\n// ============================================================\n// TEMPORAL\n// ============================================================\n\nexport const TEMPORAL_GRANULARITIES = [\n  'minute',\n  'hour',\n  'day',\n  'week',\n  'month',\n  'year',\n] as const;\n\nexport type TemporalGranularity = (typeof TEMPORAL_GRANULARITIES)[number];\n\nexport const EVENT_TIME_SOURCES = ['explicit', 'inferred', 'user_stated'] as const;\n\nexport type EventTimeSource = (typeof EVENT_TIME_SOURCES)[number];\n\nexport const CONTENT_TIME_TYPES = ['historical', 'relative', 'approximate'] as const;\n\nexport type ContentTimeType = (typeof CONTENT_TIME_TYPES)[number];\n\n// ============================================================\n// PROCESSING PATHS\n// ============================================================\n\nexport const INPUT_TYPES = [\n  'DOCUMENT',\n  'TRANSCRIPT',\n  'CONVERSATION',\n  'NOTE',\n  'IMPORT',\n] as const;\n\nexport type InputType = (typeof INPUT_TYPES)[number];\n\nexport const INPUT_SIZES = ['tiny', 'small', 'medium', 'large', 'huge'] as const;\n\nexport type InputSize = (typeof INPUT_SIZES)[number];\n\nexport const PROCESSING_PATHS = [\n  'fast',\n  'standard',\n  'progressive',\n  'conversation',\n] as const;\n\nexport type ProcessingPath = (typeof PROCESSING_PATHS)[number];\n\nexport const SIZE_THRESHOLDS = {\n  tiny: { min: 0, max: 50 },\n  small: { min: 50, max: 500 },\n  medium: { min: 500, max: 5000 },\n  large: { min: 5000, max: 25000 },\n  huge: { min: 25000, max: Infinity },\n} as const;\n\n// ============================================================\n// BLOCK DECISION THRESHOLDS\n// ============================================================\n\nexport const BLOCK_LENGTH_THRESHOLD = 1000;\nexport const BLOCK_LIST_THRESHOLD = 3;\n\n// ============================================================\n// NEURAL DEFAULTS\n// ============================================================\n\nexport const NEURAL_DEFAULTS = {\n  stability: 0.5,\n  retrievability: 1.0,\n  accessCount: 0,\n} as const;\n\n// ============================================================\n// EXTRACTION DEPTH\n// ============================================================\n\nexport const EXTRACTION_DEPTHS = ['summary', 'section', 'full'] as const;\n\nexport type ExtractionDepth = (typeof EXTRACTION_DEPTHS)[number];\n\n// ============================================================\n// REGEX PATTERNS\n// ============================================================\n\nexport const HEADING_PATTERN = /^#{1,6}\\s/m;\nexport const LIST_ITEM_PATTERN = /^[-*]\\s/gm;\n","/**\n * @module @nous/core/blocks\n * @description Block structure for long-form content with stable IDs\n * @version 0.1.0\n * @spec Brainstorms/Specs/storm-011/spec/block-schema.ts\n *\n * Blocks enable:\n * - Semantic anchor editing (target by heading, block ID)\n * - Stable references during sync\n * - Structured content preservation\n */\n\nimport { z } from 'zod';\nimport { nanoid } from 'nanoid';\nimport {\n  NANOID_LENGTH,\n  BLOCK_ID_PREFIX,\n  BLOCK_TYPES,\n  BLOCK_LENGTH_THRESHOLD,\n  BLOCK_LIST_THRESHOLD,\n  HEADING_PATTERN,\n  LIST_ITEM_PATTERN,\n  type BlockType,\n  type ContentSource,\n} from '../constants';\n\n// ============================================================\n// ID GENERATION\n// ============================================================\n\n/**\n * Generates a globally unique block ID.\n * Format: \"b_\" + 12-character nanoid\n */\nexport function generateBlockId(): string {\n  return BLOCK_ID_PREFIX + nanoid(NANOID_LENGTH);\n}\n\n// ============================================================\n// BLOCK INTERFACE\n// ============================================================\n\n/**\n * A structural block within a node's content.\n */\nexport interface Block {\n  /** Globally unique block ID. Format: \"b_\" + nanoid(12) */\n  id: string;\n  /** Block type determines rendering and behavior */\n  type: BlockType;\n  /** The actual content of this block */\n  content: string;\n  /** Heading level (1-6). Only used for 'heading' type blocks. */\n  level?: number;\n  /** Child blocks for nested content. */\n  children?: Block[];\n  /** When this block was created (ISO 8601) */\n  created: string;\n  /** When this block was last modified (ISO 8601) */\n  modified: string;\n}\n\nexport const BlockSchema: z.ZodType<Block> = z.lazy(() =>\n  z.object({\n    id: z.string().regex(/^b_[a-zA-Z0-9_-]{12}$/),\n    type: z.enum(BLOCK_TYPES),\n    content: z.string(),\n    level: z.number().int().min(1).max(6).optional(),\n    children: z.array(BlockSchema).optional(),\n    created: z.string().datetime(),\n    modified: z.string().datetime(),\n  })\n);\n\n// ============================================================\n// BLOCK DECISION FUNCTIONS\n// ============================================================\n\n/**\n * Determines if content should use block structure.\n *\n * Rules (from storm-011 v4):\n * 1. Length > 1000 chars → YES\n * 2. Has markdown headings → YES\n * 3. Has 3+ list items → YES\n * 4. Source is 'import' or 'user_note' → YES\n * 5. Source is 'chat_extraction' or 'fact' → NO\n * 6. Default → NO\n */\nexport function shouldUseBlocks(content: string, source: ContentSource): boolean {\n  // Rule 1: Length threshold\n  if (content.length > BLOCK_LENGTH_THRESHOLD) {\n    return true;\n  }\n\n  // Rule 2: Has natural structure (headings)\n  if (hasHeadings(content)) {\n    return true;\n  }\n\n  // Rule 3: Has natural structure (multiple lists)\n  if (hasMultipleLists(content)) {\n    return true;\n  }\n\n  // Rule 4: Source types that always use blocks\n  if (source === 'import' || source === 'user_note') {\n    return true;\n  }\n\n  // Rule 5: Source types that never use blocks\n  if (source === 'chat_extraction' || source === 'fact') {\n    return false;\n  }\n\n  // Default: no blocks\n  return false;\n}\n\n/**\n * Checks if content contains markdown headings.\n */\nexport function hasHeadings(content: string): boolean {\n  return HEADING_PATTERN.test(content);\n}\n\n/**\n * Checks if content has multiple list items.\n */\nexport function hasMultipleLists(content: string): boolean {\n  const matches = content.match(LIST_ITEM_PATTERN) || [];\n  return matches.length >= BLOCK_LIST_THRESHOLD;\n}\n\n// ============================================================\n// BLOCK CREATION\n// ============================================================\n\n/**\n * Creates a new block with generated ID and timestamps.\n */\nexport function createBlock(\n  type: BlockType,\n  content: string,\n  options: { level?: number; children?: Block[] } = {}\n): Block {\n  const now = new Date().toISOString();\n  return {\n    id: generateBlockId(),\n    type,\n    content,\n    level: options.level,\n    children: options.children,\n    created: now,\n    modified: now,\n  };\n}\n\n// ============================================================\n// BLOCK PARSING\n// ============================================================\n\n/**\n * Parses markdown content into block structure.\n */\nexport function parseIntoBlocks(body: string): Block[] {\n  const blocks: Block[] = [];\n  const lines = body.split('\\n');\n\n  let currentParagraph: string[] = [];\n\n  const flushParagraph = (): void => {\n    if (currentParagraph.length > 0) {\n      const content = currentParagraph.join('\\n').trim();\n      if (content) {\n        blocks.push(createBlock('paragraph', content));\n      }\n      currentParagraph = [];\n    }\n  };\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    if (line === undefined) continue;\n\n    // Heading detection\n    const headingMatch = line.match(/^(#{1,6})\\s+(.+)$/);\n    if (headingMatch && headingMatch[1] && headingMatch[2]) {\n      flushParagraph();\n      blocks.push(\n        createBlock('heading', headingMatch[2], {\n          level: headingMatch[1].length,\n        })\n      );\n      continue;\n    }\n\n    // Code block detection\n    if (line.startsWith('```')) {\n      flushParagraph();\n      const codeLines: string[] = [];\n      i++; // Move past opening ```\n      while (i < lines.length) {\n        const codeLine = lines[i];\n        if (codeLine === undefined || codeLine.startsWith('```')) break;\n        codeLines.push(codeLine);\n        i++;\n      }\n      blocks.push(createBlock('code', codeLines.join('\\n')));\n      continue;\n    }\n\n    // Quote detection\n    if (line.startsWith('> ')) {\n      flushParagraph();\n      const quoteContent = line.slice(2);\n      blocks.push(createBlock('quote', quoteContent));\n      continue;\n    }\n\n    // List detection\n    const listMatch = line.match(/^[-*]\\s+(.+)$/);\n    if (listMatch && listMatch[1]) {\n      flushParagraph();\n\n      // Collect all consecutive list items\n      const listItems: Block[] = [];\n      while (i < lines.length) {\n        const currentLine = lines[i];\n        if (currentLine === undefined) break;\n        const itemMatch = currentLine.match(/^[-*]\\s+(.+)$/);\n        if (!itemMatch || !itemMatch[1]) break;\n        listItems.push(createBlock('list_item', itemMatch[1]));\n        i++;\n      }\n      i--; // Back up one since loop will increment\n\n      blocks.push(createBlock('list', '', { children: listItems }));\n      continue;\n    }\n\n    // Divider detection\n    if (line.match(/^[-*_]{3,}$/)) {\n      flushParagraph();\n      blocks.push(createBlock('divider', ''));\n      continue;\n    }\n\n    // Empty line ends paragraph\n    if (line.trim() === '') {\n      flushParagraph();\n      continue;\n    }\n\n    // Regular content → accumulate in paragraph\n    currentParagraph.push(line);\n  }\n\n  // Flush any remaining paragraph\n  flushParagraph();\n\n  return blocks;\n}\n\n// ============================================================\n// BODY DERIVATION\n// ============================================================\n\n/**\n * Derives markdown body from block structure.\n * This is the inverse of parseIntoBlocks.\n */\nexport function deriveBody(blocks: Block[]): string {\n  return blocks.map((block) => blockToMarkdown(block)).join('\\n\\n');\n}\n\n/**\n * Converts a single block to markdown.\n */\nfunction blockToMarkdown(block: Block): string {\n  switch (block.type) {\n    case 'heading':\n      return '#'.repeat(block.level || 1) + ' ' + block.content;\n\n    case 'paragraph':\n      return block.content;\n\n    case 'list':\n      return (block.children || []).map((child) => '- ' + child.content).join('\\n');\n\n    case 'list_item':\n      return '- ' + block.content;\n\n    case 'quote':\n      return '> ' + block.content;\n\n    case 'code':\n      return '```\\n' + block.content + '\\n```';\n\n    case 'callout':\n      return '> [!note]\\n> ' + block.content;\n\n    case 'divider':\n      return '---';\n\n    case 'table':\n      return block.content;\n\n    case 'image':\n      return block.content;\n\n    default:\n      return block.content;\n  }\n}\n\n// ============================================================\n// BLOCK UTILITIES\n// ============================================================\n\n/**\n * Finds a block by ID within a block tree.\n */\nexport function findBlockById(blocks: Block[], blockId: string): Block | undefined {\n  for (const block of blocks) {\n    if (block.id === blockId) {\n      return block;\n    }\n    if (block.children) {\n      const found = findBlockById(block.children, blockId);\n      if (found) return found;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Finds a block by heading text.\n */\nexport function findBlockByHeading(\n  blocks: Block[],\n  heading: string,\n  level?: number\n): Block | undefined {\n  for (const block of blocks) {\n    if (block.type === 'heading') {\n      const matchesText = block.content.toLowerCase() === heading.toLowerCase();\n      const matchesLevel = level === undefined || block.level === level;\n      if (matchesText && matchesLevel) {\n        return block;\n      }\n    }\n    if (block.children) {\n      const found = findBlockByHeading(block.children, heading, level);\n      if (found) return found;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Gets all block IDs in a block tree.\n */\nexport function getAllBlockIds(blocks: Block[]): string[] {\n  const ids: string[] = [];\n  for (const block of blocks) {\n    ids.push(block.id);\n    if (block.children) {\n      ids.push(...getAllBlockIds(block.children));\n    }\n  }\n  return ids;\n}\n\n/**\n * Updates a block's modified timestamp.\n */\nexport function touchBlock(block: Block): Block {\n  return {\n    ...block,\n    modified: new Date().toISOString(),\n  };\n}\n\n/**\n * Counts total number of blocks including nested children.\n */\nexport function countBlocks(blocks: Block[]): number {\n  let count = 0;\n  for (const block of blocks) {\n    count++;\n    if (block.children) {\n      count += countBlocks(block.children);\n    }\n  }\n  return count;\n}\n\n// ============================================================\n// RE-EXPORTS\n// ============================================================\n\nexport type { BlockType, ContentSource };\n","/**\n * @module @nous/core/editing\n * @description Semantic anchor editing, versioning, and history\n * @version 0.1.0\n * @spec Brainstorms/Specs/storm-011/spec/edit-system.ts\n *\n * This system enables:\n * - Targeted editing by heading, block ID, or position (not brittle string matching)\n * - Version tracking for conflict detection\n * - Edit history for undo support\n * - Auto-merge when changes don't overlap\n */\n\nimport { z } from 'zod';\nimport { nanoid } from 'nanoid';\nimport {\n  NANOID_LENGTH,\n  EDIT_ID_PREFIX,\n  EDIT_TARGET_METHODS,\n  EDIT_ACTIONS,\n  MODIFIERS,\n  EDIT_HISTORY_RETENTION,\n  type EditTargetMethod,\n  type EditAction,\n  type Modifier,\n} from '../constants';\nimport { type Block, findBlockById, findBlockByHeading } from '../blocks';\nimport { type NousNode, type NodeContent } from '../nodes';\n\n// ============================================================\n// ID GENERATION\n// ============================================================\n\n/**\n * Generates a unique edit record ID.\n * Format: \"edit_\" + nanoid(12)\n */\nexport function generateEditId(): string {\n  return EDIT_ID_PREFIX + nanoid(NANOID_LENGTH);\n}\n\n// ============================================================\n// EDIT TARGET\n// ============================================================\n\n/**\n * Specifies WHERE in a node to apply an edit.\n * Supports multiple targeting methods for resilience.\n */\nexport interface EditTarget {\n  /**\n   * Targeting method.\n   * - block_id: Target specific block by stable ID\n   * - heading: Target by heading text\n   * - position: Target by position (start/end/before/after)\n   * - search: Fuzzy search fallback\n   * - full: Replace entire content\n   */\n  method: EditTargetMethod;\n  /** For block_id method: the block ID to target */\n  blockId?: string;\n  /** For heading method: the heading text to match */\n  heading?: string;\n  /** For heading method: only match specific heading level */\n  headingLevel?: number;\n  /** For position method: where relative to target */\n  position?: 'start' | 'end' | 'before' | 'after';\n  /** For position method: block ID or heading to position relative to */\n  relativeTo?: string;\n  /** For search method: pattern to find (fuzzy) */\n  searchPattern?: string;\n  /** For search method: chars of context to include */\n  searchContext?: number;\n}\n\nexport const EditTargetSchema = z.object({\n  method: z.enum(EDIT_TARGET_METHODS),\n  blockId: z.string().optional(),\n  heading: z.string().optional(),\n  headingLevel: z.number().int().min(1).max(6).optional(),\n  position: z.enum(['start', 'end', 'before', 'after']).optional(),\n  relativeTo: z.string().optional(),\n  searchPattern: z.string().optional(),\n  searchContext: z.number().int().positive().optional(),\n});\n\n// ============================================================\n// EDIT OPERATION\n// ============================================================\n\n/**\n * A single edit operation.\n */\nexport interface EditOperation {\n  /** Where to apply the edit */\n  target: EditTarget;\n  /** What action to take */\n  action: EditAction;\n  /** New content (for replace/insert/append) */\n  content?: string;\n}\n\nexport const EditOperationSchema = z.object({\n  target: EditTargetSchema,\n  action: z.enum(EDIT_ACTIONS),\n  content: z.string().optional(),\n});\n\n// ============================================================\n// EDIT REQUEST\n// ============================================================\n\n/**\n * A request to edit a node, including version check.\n */\nexport interface EditRequest {\n  /** Node to edit */\n  nodeId: string;\n  /**\n   * Version when AI/user last viewed the node.\n   * Edit fails if this doesn't match current version.\n   */\n  expectedVersion: number;\n  /** The edit operation to apply */\n  operation: EditOperation;\n  /** How to handle version conflicts */\n  conflictResolution?: 'abort' | 'retry' | 'merge' | 'force';\n}\n\nexport const EditRequestSchema = z.object({\n  nodeId: z.string(),\n  expectedVersion: z.number().int().min(1),\n  operation: EditOperationSchema,\n  conflictResolution: z.enum(['abort', 'retry', 'merge', 'force']).optional(),\n});\n\n// ============================================================\n// EDIT RESULT\n// ============================================================\n\n/**\n * Result of an edit operation.\n */\nexport interface EditResult {\n  /** Whether edit succeeded */\n  success: boolean;\n  /** New version number (if success) */\n  newVersion?: number;\n  /** Edit record ID (for undo) */\n  editId?: string;\n  /** Error details (if failed) */\n  error?: ConflictError;\n}\n\nexport const EditResultSchema = z.object({\n  success: z.boolean(),\n  newVersion: z.number().int().min(1).optional(),\n  editId: z.string().optional(),\n  error: z.lazy(() => ConflictErrorSchema).optional(),\n});\n\n/**\n * Conflict error details.\n */\nexport interface ConflictError {\n  type: 'VERSION_MISMATCH' | 'BLOCK_NOT_FOUND' | 'HEADING_NOT_FOUND' | 'SEARCH_NOT_FOUND';\n  expectedVersion: number;\n  actualVersion: number;\n  changedBy: Modifier;\n  changedAt: string;\n  /** What changed (for smart merge) */\n  diff?: {\n    blocksAdded: string[];\n    blocksModified: string[];\n    blocksDeleted: string[];\n  };\n}\n\nexport const ConflictErrorSchema = z.object({\n  type: z.enum(['VERSION_MISMATCH', 'BLOCK_NOT_FOUND', 'HEADING_NOT_FOUND', 'SEARCH_NOT_FOUND']),\n  expectedVersion: z.number(),\n  actualVersion: z.number(),\n  changedBy: z.enum(MODIFIERS),\n  changedAt: z.string().datetime(),\n  diff: z\n    .object({\n      blocksAdded: z.array(z.string()),\n      blocksModified: z.array(z.string()),\n      blocksDeleted: z.array(z.string()),\n    })\n    .optional(),\n});\n\n// ============================================================\n// EDIT HISTORY\n// ============================================================\n\n/**\n * A single change within an edit.\n */\nexport interface Change {\n  /** JSON path to the change (e.g., 'content.blocks.b_003.content') */\n  path: string;\n  /** Value before change */\n  before: unknown;\n  /** Value after change */\n  after: unknown;\n}\n\nexport const ChangeSchema = z.object({\n  path: z.string(),\n  before: z.unknown(),\n  after: z.unknown(),\n});\n\n/**\n * A recorded edit for history/undo.\n */\nexport interface EditRecord {\n  /** Unique edit ID */\n  id: string;\n  /** Node this edit applies to */\n  nodeId: string;\n  /** When edit occurred */\n  timestamp: string;\n  /** Who made the edit */\n  actor: Modifier;\n  /** For AI: which operation/request ID */\n  actorId?: string;\n  /** Version before edit */\n  fromVersion: number;\n  /** Version after edit */\n  toVersion: number;\n  /** The operation that was applied */\n  operation: EditOperation;\n  /** Detailed changes */\n  changes: Change[];\n  /** Whether this edit can be undone */\n  undoable: boolean;\n  /** When undo window expires */\n  undoExpires: string;\n  /** How to reverse this edit */\n  reverseOperation: EditOperation;\n  /** Edit IDs this depends on */\n  dependsOn: string[];\n  /** Edit IDs that depend on this */\n  dependents: string[];\n}\n\nexport const EditRecordSchema = z.object({\n  id: z.string(),\n  nodeId: z.string(),\n  timestamp: z.string().datetime(),\n  actor: z.enum(MODIFIERS),\n  actorId: z.string().optional(),\n  fromVersion: z.number().int(),\n  toVersion: z.number().int(),\n  operation: EditOperationSchema,\n  changes: z.array(ChangeSchema),\n  undoable: z.boolean(),\n  undoExpires: z.string().datetime(),\n  reverseOperation: EditOperationSchema,\n  dependsOn: z.array(z.string()),\n  dependents: z.array(z.string()),\n});\n\n/**\n * Edit history collection for a node.\n * Stored SEPARATELY from the node (lazy loaded).\n */\nexport interface EditHistoryCollection {\n  /** Node ID this history belongs to */\n  nodeId: string;\n  /** Edit records, newest first */\n  edits: EditRecord[];\n  /** Retention policy */\n  retention: RetentionPolicy;\n}\n\nexport interface RetentionPolicy {\n  maxEdits: number;\n  maxAgeDays: number;\n  undoWindowHours: number;\n}\n\nexport const RetentionPolicySchema = z.object({\n  maxEdits: z.number().int().positive(),\n  maxAgeDays: z.number().int().positive(),\n  undoWindowHours: z.number().int().positive(),\n});\n\nexport const EditHistoryCollectionSchema = z.object({\n  nodeId: z.string(),\n  edits: z.array(EditRecordSchema),\n  retention: RetentionPolicySchema,\n});\n\n// ============================================================\n// DEFAULT RETENTION POLICY\n// ============================================================\n\n/**\n * Creates a default retention policy.\n */\nexport function createDefaultRetentionPolicy(): RetentionPolicy {\n  return {\n    maxEdits: EDIT_HISTORY_RETENTION.maxEdits,\n    maxAgeDays: EDIT_HISTORY_RETENTION.maxAgeDays,\n    undoWindowHours: EDIT_HISTORY_RETENTION.undoWindowHours,\n  };\n}\n\n/**\n * Creates a new edit history collection for a node.\n */\nexport function createEditHistoryCollection(nodeId: string): EditHistoryCollection {\n  return {\n    nodeId,\n    edits: [],\n    retention: createDefaultRetentionPolicy(),\n  };\n}\n\n// ============================================================\n// TARGET VALIDATION\n// ============================================================\n\nexport interface TargetValidationResult {\n  valid: boolean;\n  errorType?: ConflictError['type'];\n  targetBlock?: Block;\n}\n\n/**\n * Validates that an edit target exists in the content.\n */\nexport function validateTarget(\n  content: NodeContent,\n  target: EditTarget\n): TargetValidationResult {\n  switch (target.method) {\n    case 'full':\n      return { valid: true };\n\n    case 'block_id':\n      if (!content.blocks || !target.blockId) {\n        return { valid: false, errorType: 'BLOCK_NOT_FOUND' };\n      }\n      const blockById = findBlockById(content.blocks, target.blockId);\n      return blockById\n        ? { valid: true, targetBlock: blockById }\n        : { valid: false, errorType: 'BLOCK_NOT_FOUND' };\n\n    case 'heading':\n      if (!content.blocks || !target.heading) {\n        return { valid: false, errorType: 'HEADING_NOT_FOUND' };\n      }\n      const headingBlock = findBlockByHeading(\n        content.blocks,\n        target.heading,\n        target.headingLevel\n      );\n      return headingBlock\n        ? { valid: true, targetBlock: headingBlock }\n        : { valid: false, errorType: 'HEADING_NOT_FOUND' };\n\n    case 'position':\n      return { valid: true }; // Position is always valid\n\n    case 'search':\n      if (!target.searchPattern) {\n        return { valid: false, errorType: 'SEARCH_NOT_FOUND' };\n      }\n      const body = content.body ?? '';\n      const found = body.toLowerCase().includes(target.searchPattern.toLowerCase());\n      return found ? { valid: true } : { valid: false, errorType: 'SEARCH_NOT_FOUND' };\n\n    default:\n      return { valid: false, errorType: 'BLOCK_NOT_FOUND' };\n  }\n}\n\n// ============================================================\n// APPLY EDIT\n// ============================================================\n\n/**\n * Applies an edit operation to content.\n * Returns new content (does not mutate).\n */\nexport function applyEdit(content: NodeContent, operation: EditOperation): NodeContent {\n  const newContent = JSON.parse(JSON.stringify(content)) as NodeContent;\n\n  switch (operation.target.method) {\n    case 'full':\n      if (operation.action === 'replace') {\n        newContent.body = operation.content;\n      } else if (operation.action === 'append') {\n        newContent.body = (newContent.body ?? '') + '\\n' + (operation.content ?? '');\n      }\n      break;\n\n    case 'block_id':\n      if (newContent.blocks && operation.target.blockId) {\n        applyBlockEdit(newContent.blocks, operation.target.blockId, operation);\n      }\n      break;\n\n    case 'heading':\n      if (newContent.blocks && operation.target.heading) {\n        const block = findBlockByHeading(\n          newContent.blocks,\n          operation.target.heading,\n          operation.target.headingLevel\n        );\n        if (block) {\n          applyBlockEdit(newContent.blocks, block.id, operation);\n        }\n      }\n      break;\n\n    case 'position':\n      applyPositionEdit(newContent, operation);\n      break;\n\n    case 'search':\n      applySearchEdit(newContent, operation);\n      break;\n  }\n\n  return newContent;\n}\n\n/**\n * Applies edit to a specific block.\n */\nfunction applyBlockEdit(\n  blocks: Block[],\n  blockId: string,\n  operation: EditOperation\n): boolean {\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i];\n    if (!block) continue;\n\n    if (block.id === blockId) {\n      const now = new Date().toISOString();\n      switch (operation.action) {\n        case 'replace':\n          blocks[i] = {\n            id: block.id,\n            type: block.type,\n            content: operation.content ?? '',\n            level: block.level,\n            children: block.children,\n            created: block.created,\n            modified: now,\n          };\n          return true;\n        case 'append':\n          blocks[i] = {\n            id: block.id,\n            type: block.type,\n            content: block.content + '\\n' + (operation.content ?? ''),\n            level: block.level,\n            children: block.children,\n            created: block.created,\n            modified: now,\n          };\n          return true;\n        case 'insert':\n          // Insert after this block\n          if (operation.content) {\n            const newBlock: Block = {\n              id: 'b_' + nanoid(NANOID_LENGTH),\n              type: 'paragraph',\n              content: operation.content,\n              created: now,\n              modified: now,\n            };\n            blocks.splice(i + 1, 0, newBlock);\n          }\n          return true;\n        case 'delete':\n          blocks.splice(i, 1);\n          return true;\n      }\n    }\n    // Check children recursively\n    if (block.children) {\n      const found = applyBlockEdit(block.children, blockId, operation);\n      if (found) return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Applies a position-based edit.\n */\nfunction applyPositionEdit(content: NodeContent, operation: EditOperation): void {\n  const { position } = operation.target;\n\n  if (position === 'start') {\n    content.body = (operation.content ?? '') + '\\n' + (content.body ?? '');\n  } else if (position === 'end') {\n    content.body = (content.body ?? '') + '\\n' + (operation.content ?? '');\n  }\n  // 'before' and 'after' would need relativeTo to be implemented\n}\n\n/**\n * Applies a search-based edit.\n */\nfunction applySearchEdit(content: NodeContent, operation: EditOperation): void {\n  if (!operation.target.searchPattern || !content.body) return;\n\n  const pattern = operation.target.searchPattern;\n\n  switch (operation.action) {\n    case 'replace':\n      content.body = content.body.replace(\n        new RegExp(escapeRegex(pattern), 'gi'),\n        operation.content ?? ''\n      );\n      break;\n    case 'append':\n      // Append after the found pattern\n      content.body = content.body.replace(\n        new RegExp(escapeRegex(pattern), 'gi'),\n        (match) => match + (operation.content ?? '')\n      );\n      break;\n    case 'delete':\n      content.body = content.body.replace(new RegExp(escapeRegex(pattern), 'gi'), '');\n      break;\n  }\n}\n\n/**\n * Escapes special regex characters.\n */\nfunction escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\n// ============================================================\n// CHECKSUM\n// ============================================================\n\n/**\n * Computes a checksum for content.\n */\nexport function computeChecksum(content: NodeContent): string {\n  const str = JSON.stringify(content);\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  return Math.abs(hash).toString(16).padStart(8, '0');\n}\n\n// ============================================================\n// CHANGE COMPUTATION\n// ============================================================\n\n/**\n * Computes detailed changes between before/after content.\n */\nexport function computeChanges(before: NodeContent, after: NodeContent): Change[] {\n  const changes: Change[] = [];\n\n  if (before.title !== after.title) {\n    changes.push({ path: 'content.title', before: before.title, after: after.title });\n  }\n  if (before.body !== after.body) {\n    changes.push({ path: 'content.body', before: before.body, after: after.body });\n  }\n  if (before.summary !== after.summary) {\n    changes.push({ path: 'content.summary', before: before.summary, after: after.summary });\n  }\n\n  // Block changes - compare stringified for now\n  const beforeBlocks = JSON.stringify(before.blocks ?? []);\n  const afterBlocks = JSON.stringify(after.blocks ?? []);\n  if (beforeBlocks !== afterBlocks) {\n    changes.push({ path: 'content.blocks', before: before.blocks, after: after.blocks });\n  }\n\n  return changes;\n}\n\n/**\n * Computes the reverse operation for undo.\n */\nexport function computeReverseOperation(\n  operation: EditOperation,\n  beforeContent: NodeContent\n): EditOperation {\n  switch (operation.action) {\n    case 'replace':\n      return {\n        target: operation.target,\n        action: 'replace',\n        content:\n          operation.target.method === 'full'\n            ? beforeContent.body\n            : getTargetContent(beforeContent, operation.target),\n      };\n    case 'append':\n      // Reverse of append is to remove what was appended\n      return {\n        target: operation.target,\n        action: 'replace',\n        content: getTargetContent(beforeContent, operation.target),\n      };\n    case 'insert':\n      return {\n        target: operation.target,\n        action: 'delete',\n      };\n    case 'delete':\n      return {\n        target: operation.target,\n        action: 'insert',\n        content: getTargetContent(beforeContent, operation.target),\n      };\n    default:\n      return {\n        target: { method: 'full' },\n        action: 'replace',\n        content: beforeContent.body,\n      };\n  }\n}\n\n/**\n * Gets content at a specific target location.\n */\nfunction getTargetContent(content: NodeContent, target: EditTarget): string | undefined {\n  switch (target.method) {\n    case 'full':\n      return content.body;\n    case 'block_id':\n      if (content.blocks && target.blockId) {\n        const block = findBlockById(content.blocks, target.blockId);\n        return block?.content;\n      }\n      return undefined;\n    case 'heading':\n      if (content.blocks && target.heading) {\n        const block = findBlockByHeading(content.blocks, target.heading, target.headingLevel);\n        return block?.content;\n      }\n      return undefined;\n    default:\n      return content.body;\n  }\n}\n\n// ============================================================\n// SAFE EDIT FUNCTION\n// ============================================================\n\nexport interface SafeEditOptions {\n  actor?: Modifier;\n  actorId?: string;\n}\n\nexport interface SafeEditResult {\n  result: EditResult;\n  updatedNode?: NousNode;\n  editRecord?: EditRecord;\n}\n\n/**\n * Applies an edit with version checking.\n *\n * Flow:\n * 1. Check version matches expected\n * 2. Validate target exists\n * 3. Apply edit\n * 4. Increment version\n * 5. Create edit record\n */\nexport function safeEdit(\n  node: NousNode,\n  request: EditRequest,\n  options: SafeEditOptions = {}\n): SafeEditResult {\n  const actor = options.actor ?? 'user';\n  const now = new Date().toISOString();\n\n  // 1. Check version\n  if (node.versioning.version !== request.expectedVersion) {\n    return {\n      result: {\n        success: false,\n        error: {\n          type: 'VERSION_MISMATCH',\n          expectedVersion: request.expectedVersion,\n          actualVersion: node.versioning.version,\n          changedBy: node.versioning.lastModifier,\n          changedAt: node.versioning.lastModified,\n        },\n      },\n    };\n  }\n\n  // 2. Validate target exists\n  const targetValidation = validateTarget(node.content, request.operation.target);\n  if (!targetValidation.valid) {\n    return {\n      result: {\n        success: false,\n        error: {\n          type: targetValidation.errorType!,\n          expectedVersion: request.expectedVersion,\n          actualVersion: node.versioning.version,\n          changedBy: node.versioning.lastModifier,\n          changedAt: node.versioning.lastModified,\n        },\n      },\n    };\n  }\n\n  // 3. Apply edit\n  const beforeContent = JSON.parse(JSON.stringify(node.content)) as NodeContent;\n  const updatedContent = applyEdit(node.content, request.operation);\n\n  // 4. Update versioning\n  const newVersion = node.versioning.version + 1;\n  const updatedNode: NousNode = {\n    ...node,\n    content: updatedContent,\n    versioning: {\n      version: newVersion,\n      lastModified: now,\n      lastModifier: actor,\n      checksum: computeChecksum(updatedContent),\n    },\n  };\n\n  // 5. Create edit record\n  const editId = generateEditId();\n  const editRecord: EditRecord = {\n    id: editId,\n    nodeId: node.id,\n    timestamp: now,\n    actor,\n    actorId: options.actorId,\n    fromVersion: node.versioning.version,\n    toVersion: newVersion,\n    operation: request.operation,\n    changes: computeChanges(beforeContent, updatedContent),\n    undoable: true,\n    undoExpires: new Date(\n      Date.now() + EDIT_HISTORY_RETENTION.undoWindowHours * 60 * 60 * 1000\n    ).toISOString(),\n    reverseOperation: computeReverseOperation(request.operation, beforeContent),\n    dependsOn: [],\n    dependents: [],\n  };\n\n  return {\n    result: {\n      success: true,\n      newVersion,\n      editId,\n    },\n    updatedNode,\n    editRecord,\n  };\n}\n\n// ============================================================\n// AUTO-MERGE\n// ============================================================\n\n/**\n * Checks if conflicting edits can be auto-merged.\n * Safe when changes don't overlap.\n */\nexport function canAutoMerge(\n  _baseContent: NodeContent,\n  theirChanges: EditOperation[],\n  ourChange: EditOperation\n): boolean {\n  const theirBlocks = theirChanges.flatMap((c) => getAffectedBlocks(c));\n  const ourBlocks = getAffectedBlocks(ourChange);\n\n  // If either side edits the full content, cannot merge\n  if (theirBlocks.includes('__full__') || ourBlocks.includes('__full__')) {\n    return false;\n  }\n\n  // No overlap = safe to merge\n  const overlap = theirBlocks.filter((b) => ourBlocks.includes(b));\n  return overlap.length === 0;\n}\n\n/**\n * Gets block IDs affected by an edit operation.\n */\nexport function getAffectedBlocks(operation: EditOperation): string[] {\n  if (operation.target.method === 'block_id' && operation.target.blockId) {\n    return [operation.target.blockId];\n  }\n  if (operation.target.method === 'full') {\n    return ['__full__'];\n  }\n  return [];\n}\n\n// ============================================================\n// UNDO\n// ============================================================\n\n/**\n * Result of an undo operation.\n */\nexport interface UndoResult {\n  success: boolean;\n  reason?: string;\n  dependents?: string[];\n  options?: ('undo_all' | 'force_undo')[];\n}\n\n/**\n * Checks if an edit can be undone.\n */\nexport function canUndo(record: EditRecord): { canUndo: boolean; reason?: string } {\n  if (!record.undoable) {\n    return { canUndo: false, reason: 'Edit not undoable' };\n  }\n\n  if (new Date() > new Date(record.undoExpires)) {\n    return { canUndo: false, reason: 'Undo window expired' };\n  }\n\n  if (record.dependents.length > 0) {\n    return { canUndo: false, reason: 'Has dependent edits' };\n  }\n\n  return { canUndo: true };\n}\n\n/**\n * Creates an edit request to undo a previous edit.\n */\nexport function createUndoRequest(record: EditRecord, currentVersion: number): EditRequest {\n  return {\n    nodeId: record.nodeId,\n    expectedVersion: currentVersion,\n    operation: record.reverseOperation,\n    conflictResolution: 'abort',\n  };\n}\n\n// ============================================================\n// PRUNING\n// ============================================================\n\n/**\n * Prunes old edit history based on retention policy.\n */\nexport function pruneEditHistory(history: EditHistoryCollection): EditHistoryCollection {\n  const cutoffDate = new Date();\n  cutoffDate.setDate(cutoffDate.getDate() - history.retention.maxAgeDays);\n  const cutoff = cutoffDate.toISOString();\n\n  // Remove old edits\n  let edits = history.edits.filter((edit) => {\n    const tooOld = edit.timestamp < cutoff;\n    const undoExpired = new Date() > new Date(edit.undoExpires);\n    return !(tooOld && undoExpired);\n  });\n\n  // Trim to max edits (keep newest)\n  if (edits.length > history.retention.maxEdits) {\n    edits = edits.slice(0, history.retention.maxEdits);\n  }\n\n  return {\n    ...history,\n    edits,\n  };\n}\n\n/**\n * Adds an edit record to history.\n */\nexport function addToHistory(\n  history: EditHistoryCollection,\n  record: EditRecord\n): EditHistoryCollection {\n  return {\n    ...history,\n    edits: [record, ...history.edits],\n  };\n}\n\n/**\n * Gets an edit record by ID from history.\n */\nexport function getEditById(\n  history: EditHistoryCollection,\n  editId: string\n): EditRecord | undefined {\n  return history.edits.find((e) => e.id === editId);\n}\n\n/**\n * Marks an edit as having a dependent.\n */\nexport function addDependent(\n  history: EditHistoryCollection,\n  editId: string,\n  dependentId: string\n): EditHistoryCollection {\n  return {\n    ...history,\n    edits: history.edits.map((e) =>\n      e.id === editId ? { ...e, dependents: [...e.dependents, dependentId] } : e\n    ),\n  };\n}\n\n// ============================================================\n// VALIDATION\n// ============================================================\n\n/**\n * Validates an edit operation.\n */\nexport function validateEditOperation(operation: unknown): operation is EditOperation {\n  return EditOperationSchema.safeParse(operation).success;\n}\n\n/**\n * Validates an edit request.\n */\nexport function validateEditRequest(request: unknown): request is EditRequest {\n  return EditRequestSchema.safeParse(request).success;\n}\n\n// ============================================================\n// RE-EXPORTS\n// ============================================================\n\nexport type { EditTargetMethod, EditAction, Modifier };\n"]}