{"version":3,"sources":["../../src/tps/index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/**\n * @module @nous/core/tps\n * @description Temporal Parsing System (TPS) for natural language time queries\n * @version 0.1.0\n * @spec Brainstorms/Specs/storm-004/spec/temporal-parsing.ts\n *\n * Converts natural language time expressions into precise, searchable\n * constraints with confidence scores.\n *\n * Expression types:\n * - explicit_absolute: \"January 15, 2024\"\n * - explicit_relative: \"last week\", \"3 days ago\"\n * - fuzzy_period: \"around summer\", \"a while back\"\n * - duration: \"during the meeting\"\n * - none: No temporal expression found\n */\n\nimport { z } from 'zod';\nimport { type TemporalGranularity } from '../constants';\n\n// ============================================================\n// EXPRESSION TYPES\n// ============================================================\n\nexport const EXPRESSION_TYPES = [\n  'explicit_absolute',\n  'explicit_relative',\n  'fuzzy_period',\n  'duration',\n  'none',\n] as const;\n\nexport type ExpressionType = (typeof EXPRESSION_TYPES)[number];\n\n// ============================================================\n// TIME SOURCES\n// ============================================================\n\nexport const TIME_SOURCES = [\n  'user_explicit',\n  'calendar_sync',\n  'file_timestamp',\n  'content_extraction',\n  'context_inference',\n  'unknown',\n] as const;\n\nexport type TimeSource = (typeof TIME_SOURCES)[number];\n\n// ============================================================\n// CONFIDENCE VALUES\n// ============================================================\n\n/**\n * Source confidence values based on how time was obtained.\n */\nexport const SOURCE_CONFIDENCE: Record<TimeSource, number> = {\n  user_explicit: 1.0,\n  calendar_sync: 0.95,\n  file_timestamp: 0.9,\n  content_extraction: 0.7,\n  context_inference: 0.5,\n  unknown: 0.3,\n};\n\n/**\n * Granularity confidence values based on precision level.\n */\nexport const GRANULARITY_CONFIDENCE: Record<TemporalGranularity, number> = {\n  minute: 1.0,\n  hour: 0.9,\n  day: 0.8,\n  week: 0.6,\n  month: 0.4,\n  year: 0.2,\n};\n\n/**\n * Expression type interpretation confidence.\n */\nexport const INTERPRETATION_CONFIDENCE: Record<ExpressionType, number> = {\n  explicit_absolute: 1.0,\n  explicit_relative: 0.95,\n  fuzzy_period: 0.6,\n  duration: 0.8,\n  none: 1.0,\n};\n\n// ============================================================\n// CONFIDENCE FACTORS\n// ============================================================\n\n/**\n * Three-factor temporal confidence scoring.\n */\nexport interface ConfidenceFactors {\n  /** How we got this time (0-1) */\n  source: number;\n  /** How precise the time is (0-1) */\n  granularity: number;\n  /** How sure about parsing (0-1) */\n  interpretation: number;\n}\n\nexport const ConfidenceFactorsSchema = z.object({\n  source: z.number().min(0).max(1),\n  granularity: z.number().min(0).max(1),\n  interpretation: z.number().min(0).max(1),\n});\n\n/**\n * Calculates combined temporal confidence.\n * Formula: source × granularity × interpretation\n */\nexport function computeConfidenceScore(factors: ConfidenceFactors): number {\n  return factors.source * factors.granularity * factors.interpretation;\n}\n\n/**\n * Gets source confidence for a time source.\n */\nexport function getSourceConfidence(source: TimeSource): number {\n  return SOURCE_CONFIDENCE[source];\n}\n\n/**\n * Gets granularity confidence for a precision level.\n */\nexport function getGranularityConfidence(granularity: TemporalGranularity): number {\n  return GRANULARITY_CONFIDENCE[granularity];\n}\n\n/**\n * Gets interpretation confidence for an expression type.\n */\nexport function getInterpretationConfidence(type: ExpressionType): number {\n  return INTERPRETATION_CONFIDENCE[type];\n}\n\n// ============================================================\n// TPS INPUT / OUTPUT\n// ============================================================\n\n/**\n * Input to the Temporal Parsing System.\n */\nexport interface TPSInput {\n  /** Full query text */\n  query: string;\n  /** When the query was made (ISO 8601) */\n  referenceTimestamp: string;\n  /** User's timezone (IANA format) */\n  userTimezone: string;\n}\n\nexport const TPSInputSchema = z.object({\n  query: z.string().min(1),\n  referenceTimestamp: z.string().datetime(),\n  userTimezone: z.string().min(1),\n});\n\n/**\n * Temporal constraint extracted from a query.\n */\nexport interface TemporalConstraint {\n  /** Start of search range (ISO 8601 UTC) */\n  rangeStart: string;\n  /** End of search range (ISO 8601 UTC) */\n  rangeEnd: string;\n  /** Confidence in this range (0-1) */\n  rangeConfidence: number;\n  /** Type of expression parsed */\n  expressionType: ExpressionType;\n  /** Original text that was parsed */\n  originalExpression: string;\n}\n\nexport const TemporalConstraintSchema = z.object({\n  rangeStart: z.string().datetime(),\n  rangeEnd: z.string().datetime(),\n  rangeConfidence: z.number().min(0).max(1),\n  expressionType: z.enum(EXPRESSION_TYPES),\n  originalExpression: z.string(),\n});\n\n/**\n * Output from the Temporal Parsing System.\n */\nexport interface TPSOutput {\n  /** Parsed temporal constraint (null if no time in query) */\n  temporalConstraint: TemporalConstraint | null;\n  /** Non-temporal parts of the query */\n  entitiesExtracted: string[];\n  /** Overall parsing confidence (0-1) */\n  parsingConfidence: number;\n}\n\nexport const TPSOutputSchema = z.object({\n  temporalConstraint: TemporalConstraintSchema.nullable(),\n  entitiesExtracted: z.array(z.string()),\n  parsingConfidence: z.number().min(0).max(1),\n});\n\n// ============================================================\n// SEASONS\n// ============================================================\n\nexport interface SeasonRange {\n  startMonth: number; // 1-12\n  startDay: number;\n  endMonth: number;\n  endDay: number;\n}\n\n/**\n * Northern Hemisphere season definitions.\n */\nexport const SEASONS: Record<string, SeasonRange> = {\n  spring: { startMonth: 3, startDay: 1, endMonth: 5, endDay: 31 },\n  summer: { startMonth: 6, startDay: 1, endMonth: 8, endDay: 31 },\n  fall: { startMonth: 9, startDay: 1, endMonth: 11, endDay: 30 },\n  autumn: { startMonth: 9, startDay: 1, endMonth: 11, endDay: 30 },\n  winter: { startMonth: 12, startDay: 1, endMonth: 2, endDay: 28 },\n};\n\n/**\n * Detects if a query contains a season reference.\n */\nexport function detectSeason(query: string): string | null {\n  const lowerQuery = query.toLowerCase();\n  for (const season of Object.keys(SEASONS)) {\n    if (lowerQuery.includes(season)) {\n      return season;\n    }\n  }\n  return null;\n}\n\n/**\n * Gets the date range for a season in a given year.\n */\nexport function getSeasonRange(\n  season: string,\n  year: number\n): { start: Date; end: Date } | null {\n  const range = SEASONS[season.toLowerCase()];\n  if (!range) {\n    return null;\n  }\n\n  // Handle winter which spans years\n  if (season.toLowerCase() === 'winter') {\n    return {\n      start: new Date(Date.UTC(year, range.startMonth - 1, range.startDay)),\n      end: new Date(Date.UTC(year + 1, range.endMonth - 1, range.endDay)),\n    };\n  }\n\n  return {\n    start: new Date(Date.UTC(year, range.startMonth - 1, range.startDay)),\n    end: new Date(Date.UTC(year, range.endMonth - 1, range.endDay)),\n  };\n}\n\n// ============================================================\n// TEMPORAL PARSING\n// ============================================================\n\n/**\n * Relative time patterns with their calculations.\n */\nconst RELATIVE_PATTERNS: {\n  pattern: RegExp;\n  calculate: (match: RegExpMatchArray, ref: Date) => { start: Date; end: Date };\n}[] = [\n  {\n    pattern: /yesterday/i,\n    calculate: (_, ref) => {\n      const start = new Date(ref);\n      start.setDate(start.getDate() - 1);\n      start.setHours(0, 0, 0, 0);\n      const end = new Date(start);\n      end.setHours(23, 59, 59, 999);\n      return { start, end };\n    },\n  },\n  {\n    pattern: /today/i,\n    calculate: (_, ref) => {\n      const start = new Date(ref);\n      start.setHours(0, 0, 0, 0);\n      const end = new Date(start);\n      end.setHours(23, 59, 59, 999);\n      return { start, end };\n    },\n  },\n  {\n    pattern: /last\\s+week/i,\n    calculate: (_, ref) => {\n      const end = new Date(ref);\n      end.setDate(end.getDate() - 1);\n      const start = new Date(end);\n      start.setDate(start.getDate() - 6);\n      start.setHours(0, 0, 0, 0);\n      end.setHours(23, 59, 59, 999);\n      return { start, end };\n    },\n  },\n  {\n    pattern: /last\\s+month/i,\n    calculate: (_, ref) => {\n      const start = new Date(ref);\n      start.setMonth(start.getMonth() - 1, 1);\n      start.setHours(0, 0, 0, 0);\n      const end = new Date(start);\n      end.setMonth(end.getMonth() + 1, 0);\n      end.setHours(23, 59, 59, 999);\n      return { start, end };\n    },\n  },\n  {\n    pattern: /(\\d+)\\s+days?\\s+ago/i,\n    calculate: (match, ref) => {\n      const days = parseInt(match[1] ?? '1', 10);\n      const start = new Date(ref);\n      start.setDate(start.getDate() - days);\n      start.setHours(0, 0, 0, 0);\n      const end = new Date(start);\n      end.setHours(23, 59, 59, 999);\n      return { start, end };\n    },\n  },\n  {\n    pattern: /(\\d+)\\s+weeks?\\s+ago/i,\n    calculate: (match, ref) => {\n      const weeks = parseInt(match[1] ?? '1', 10);\n      const end = new Date(ref);\n      end.setDate(end.getDate() - weeks * 7);\n      const start = new Date(end);\n      start.setDate(start.getDate() - 6);\n      start.setHours(0, 0, 0, 0);\n      end.setHours(23, 59, 59, 999);\n      return { start, end };\n    },\n  },\n  {\n    pattern: /(\\d+)\\s+months?\\s+ago/i,\n    calculate: (match, ref) => {\n      const months = parseInt(match[1] ?? '1', 10);\n      const start = new Date(ref);\n      start.setMonth(start.getMonth() - months, 1);\n      start.setHours(0, 0, 0, 0);\n      const end = new Date(start);\n      end.setMonth(end.getMonth() + 1, 0);\n      end.setHours(23, 59, 59, 999);\n      return { start, end };\n    },\n  },\n];\n\n/**\n * Month names for parsing.\n */\nconst MONTHS: Record<string, number> = {\n  january: 0,\n  february: 1,\n  march: 2,\n  april: 3,\n  may: 4,\n  june: 5,\n  july: 6,\n  august: 7,\n  september: 8,\n  october: 9,\n  november: 10,\n  december: 11,\n  jan: 0,\n  feb: 1,\n  mar: 2,\n  apr: 3,\n  jun: 5,\n  jul: 6,\n  aug: 7,\n  sep: 8,\n  sept: 8,\n  oct: 9,\n  nov: 10,\n  dec: 11,\n};\n\n/**\n * Parses relative time expressions.\n */\nexport function parseRelativeTime(\n  query: string,\n  referenceDate: Date\n): { start: Date; end: Date; expression: string } | null {\n  for (const { pattern, calculate } of RELATIVE_PATTERNS) {\n    const match = query.match(pattern);\n    if (match) {\n      const { start, end } = calculate(match, referenceDate);\n      return { start, end, expression: match[0] };\n    }\n  }\n  return null;\n}\n\n/**\n * Parses absolute month references (e.g., \"September\", \"in September 2024\").\n */\nexport function parseAbsoluteMonth(\n  query: string,\n  referenceDate: Date\n): { start: Date; end: Date; expression: string } | null {\n  // Match \"in [Month]\" or just \"[Month]\" with optional year\n  const monthPattern =\n    /(?:in\\s+)?(january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|jun|jul|aug|sep|sept|oct|nov|dec)(?:\\s+(\\d{4}))?/i;\n  const match = query.match(monthPattern);\n\n  if (match && match[1]) {\n    const monthName = match[1].toLowerCase();\n    const month = MONTHS[monthName];\n\n    // If month is not recognized, return null\n    if (month === undefined) {\n      return null;\n    }\n\n    const year = match[2] ? parseInt(match[2], 10) : undefined;\n\n    let targetYear = year ?? referenceDate.getFullYear();\n\n    // If no year specified and the month is in the future, use last year\n    if (!year) {\n      const refMonth = referenceDate.getMonth();\n      if (month > refMonth) {\n        targetYear -= 1;\n      }\n    }\n\n    const start = new Date(Date.UTC(targetYear, month, 1, 0, 0, 0, 0));\n    const end = new Date(Date.UTC(targetYear, month + 1, 0, 23, 59, 59, 999));\n\n    return { start, end, expression: match[0] };\n  }\n\n  return null;\n}\n\n/**\n * Parses fuzzy time expressions.\n */\nexport function parseFuzzyTime(\n  query: string,\n  referenceDate: Date\n): { start: Date; end: Date; expression: string; confidence: number } | null {\n  const lowerQuery = query.toLowerCase();\n\n  // \"recently\" - last 7 days\n  if (lowerQuery.includes('recently')) {\n    const end = new Date(referenceDate);\n    const start = new Date(referenceDate);\n    start.setDate(start.getDate() - 7);\n    start.setHours(0, 0, 0, 0);\n    end.setHours(23, 59, 59, 999);\n    return { start, end, expression: 'recently', confidence: 0.7 };\n  }\n\n  // \"a while back\" - 1-6 months ago\n  if (lowerQuery.includes('a while back') || lowerQuery.includes('a while ago')) {\n    const end = new Date(referenceDate);\n    end.setMonth(end.getMonth() - 1);\n    const start = new Date(referenceDate);\n    start.setMonth(start.getMonth() - 6);\n    start.setHours(0, 0, 0, 0);\n    end.setHours(23, 59, 59, 999);\n    return { start, end, expression: 'a while back', confidence: 0.4 };\n  }\n\n  // \"a few months ago\" - 2-4 months ago\n  if (lowerQuery.includes('a few months ago')) {\n    const end = new Date(referenceDate);\n    end.setMonth(end.getMonth() - 2);\n    const start = new Date(referenceDate);\n    start.setMonth(start.getMonth() - 4);\n    start.setHours(0, 0, 0, 0);\n    end.setHours(23, 59, 59, 999);\n    return { start, end, expression: 'a few months ago', confidence: 0.5 };\n  }\n\n  // Season detection\n  const season = detectSeason(query);\n  if (season) {\n    let targetYear = referenceDate.getFullYear();\n    const range = getSeasonRange(season, targetYear);\n\n    if (range) {\n      // If the season end is in the future, use last year\n      if (range.end > referenceDate) {\n        const lastYearRange = getSeasonRange(season, targetYear - 1);\n        if (lastYearRange) {\n          return {\n            start: lastYearRange.start,\n            end: lastYearRange.end,\n            expression: season,\n            confidence: 0.6,\n          };\n        }\n      }\n      return { start: range.start, end: range.end, expression: season, confidence: 0.6 };\n    }\n  }\n\n  return null;\n}\n\n/**\n * Main TPS parsing function.\n * Parses a query to extract temporal constraints.\n */\nexport function parseTemporalExpression(input: TPSInput): TPSOutput {\n  const referenceDate = new Date(input.referenceTimestamp);\n  const query = input.query;\n\n  // Try relative time first\n  const relative = parseRelativeTime(query, referenceDate);\n  if (relative) {\n    return {\n      temporalConstraint: {\n        rangeStart: relative.start.toISOString(),\n        rangeEnd: relative.end.toISOString(),\n        rangeConfidence: 0.95,\n        expressionType: 'explicit_relative',\n        originalExpression: relative.expression,\n      },\n      entitiesExtracted: extractNonTemporalEntities(query, relative.expression),\n      parsingConfidence: 0.95,\n    };\n  }\n\n  // Try absolute month\n  const absolute = parseAbsoluteMonth(query, referenceDate);\n  if (absolute) {\n    return {\n      temporalConstraint: {\n        rangeStart: absolute.start.toISOString(),\n        rangeEnd: absolute.end.toISOString(),\n        rangeConfidence: 1.0,\n        expressionType: 'explicit_absolute',\n        originalExpression: absolute.expression,\n      },\n      entitiesExtracted: extractNonTemporalEntities(query, absolute.expression),\n      parsingConfidence: 1.0,\n    };\n  }\n\n  // Try fuzzy time\n  const fuzzy = parseFuzzyTime(query, referenceDate);\n  if (fuzzy) {\n    return {\n      temporalConstraint: {\n        rangeStart: fuzzy.start.toISOString(),\n        rangeEnd: fuzzy.end.toISOString(),\n        rangeConfidence: fuzzy.confidence,\n        expressionType: 'fuzzy_period',\n        originalExpression: fuzzy.expression,\n      },\n      entitiesExtracted: extractNonTemporalEntities(query, fuzzy.expression),\n      parsingConfidence: fuzzy.confidence,\n    };\n  }\n\n  // No temporal expression found\n  return {\n    temporalConstraint: null,\n    entitiesExtracted: extractNonTemporalEntities(query, ''),\n    parsingConfidence: 1.0,\n  };\n}\n\n/**\n * Extracts non-temporal entities from a query.\n * Simple word extraction - more sophisticated NER would be added later.\n */\nfunction extractNonTemporalEntities(query: string, temporalPart: string): string[] {\n  // Remove the temporal part\n  let remaining = query.replace(temporalPart, '').trim();\n\n  // Remove common query words\n  const stopWords = [\n    'what',\n    'when',\n    'where',\n    'who',\n    'how',\n    'did',\n    'do',\n    'does',\n    'the',\n    'a',\n    'an',\n    'in',\n    'on',\n    'at',\n    'to',\n    'for',\n    'of',\n    'with',\n    'about',\n    'i',\n    'me',\n    'my',\n    'we',\n    'our',\n    'learn',\n    'learned',\n    'teach',\n    'taught',\n  ];\n\n  const words = remaining\n    .toLowerCase()\n    .replace(/[^\\w\\s]/g, '')\n    .split(/\\s+/)\n    .filter((word) => word.length > 2 && !stopWords.includes(word));\n\n  // Remove duplicates\n  return [...new Set(words)];\n}\n\n// ============================================================\n// QUERY STEP BUDGETS (from spec)\n// ============================================================\n\nexport const QUERY_STEP_BUDGETS = {\n  temporalParsing: 5,\n  entityExtraction: 3,\n  episodeFilter: 10,\n  semanticFilter: 30,\n  confidenceAggregate: 2,\n  resultAssembly: 3,\n  phase2Handoff: 2,\n} as const;\n\nexport const PHASE_1_BUDGET_MS = 55;\n\n/**\n * Checks if the total latency is within Phase 1 budget.\n */\nexport function isWithinBudget(latencyMs: number): boolean {\n  return latencyMs <= PHASE_1_BUDGET_MS;\n}\n\n// ============================================================\n// VALIDATION\n// ============================================================\n\n/**\n * Validates TPS input.\n */\nexport function validateTPSInput(input: unknown): input is TPSInput {\n  return TPSInputSchema.safeParse(input).success;\n}\n\n/**\n * Validates TPS output.\n */\nexport function validateTPSOutput(output: unknown): output is TPSOutput {\n  return TPSOutputSchema.safeParse(output).success;\n}\n\n/**\n * Validates a temporal constraint.\n */\nexport function validateTemporalConstraint(\n  constraint: unknown\n): constraint is TemporalConstraint {\n  return TemporalConstraintSchema.safeParse(constraint).success;\n}\n\n// ============================================================\n// RE-EXPORTS\n// ============================================================\n\nexport type { TemporalGranularity };\n"]}