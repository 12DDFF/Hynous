{"version":3,"sources":["../../src/sections/index.ts","../../src/params/index.ts","../../src/embeddings/index.ts","../../src/ssa/index.ts"],"names":["z"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * @module @nous/core/sections\n * @description Memory section definitions — the bias layer that gives different\n * memory types different retrieval weights, decay curves, and encoding rules.\n *\n * Sections are a STATIC LOOKUP based on node subtype, not a stored field.\n * All nodes remain in one table. All queries still search all nodes.\n * Sections influence HOW results are scored, not WHICH results appear.\n *\n * See: revisions/memory-sections/executive-summary.md\n */\n\nimport { z } from 'zod';\nimport type { RerankingWeights } from '../params/index.js';\n\n// ============================================================\n// SECTION ENUM\n// ============================================================\n\n/**\n * The four memory sections, inspired by brain regions.\n *\n * EPISODIC  (Hippocampus)  — What happened: trades, summaries, events\n * SIGNALS   (Sensory cortex) — What to watch: signals, watchpoints\n * KNOWLEDGE (Neocortex)    — What I've learned: lessons, theses, curiosity\n * PROCEDURAL (Cerebellum)  — How to act: playbooks, outcome analysis\n */\nexport const MEMORY_SECTIONS = ['EPISODIC', 'SIGNALS', 'KNOWLEDGE', 'PROCEDURAL'] as const;\nexport type MemorySection = (typeof MEMORY_SECTIONS)[number];\n\n// ============================================================\n// SUBTYPE → SECTION MAPPING\n// ============================================================\n\n/**\n * Static mapping from custom subtype to memory section.\n *\n * This is the SINGLE SOURCE OF TRUTH for section membership.\n * Both TypeScript runtime and Python config mirror this mapping.\n *\n * If a subtype is not in this map, it defaults to KNOWLEDGE.\n */\nexport const SUBTYPE_TO_SECTION: Record<string, MemorySection> = {\n  // EPISODIC — What happened\n  'custom:trade_entry': 'EPISODIC',\n  'custom:trade_close': 'EPISODIC',\n  'custom:trade_modify': 'EPISODIC',\n  'custom:trade': 'EPISODIC',          // Legacy subtype, rarely used\n  'custom:turn_summary': 'EPISODIC',\n  'custom:session_summary': 'EPISODIC',\n  'custom:market_event': 'EPISODIC',\n\n  // SIGNALS — What to watch\n  'custom:signal': 'SIGNALS',\n  'custom:watchpoint': 'SIGNALS',\n\n  // KNOWLEDGE — What I've learned\n  'custom:lesson': 'KNOWLEDGE',\n  'custom:thesis': 'KNOWLEDGE',\n  'custom:curiosity': 'KNOWLEDGE',\n\n  // PROCEDURAL — How to act\n  'custom:playbook': 'PROCEDURAL',\n  'custom:missed_opportunity': 'PROCEDURAL',\n  'custom:good_pass': 'PROCEDURAL',\n};\n\n/**\n * Get the memory section for a node's subtype.\n * Returns KNOWLEDGE as default for unknown subtypes.\n */\nexport function getSectionForSubtype(subtype: string | null | undefined): MemorySection {\n  if (!subtype) return 'KNOWLEDGE';\n  return SUBTYPE_TO_SECTION[subtype] ?? 'KNOWLEDGE';\n}\n\n// ============================================================\n// SECTION PROFILE TYPES\n// ============================================================\n\n/**\n * Decay configuration per section.\n * Controls how fast memories in this section fade and transition lifecycle states.\n */\nexport interface SectionDecayConfig {\n  /** Initial stability in days for new nodes (before any access-based growth) */\n  initial_stability_days: number;\n  /** Multiplier applied to stability on each recall (FSRS growth) */\n  growth_rate: number;\n  /** Retrievability above this = ACTIVE */\n  active_threshold: number;\n  /** Retrievability above this = WEAK (below = DORMANT) */\n  weak_threshold: number;\n  /** Maximum stability in days (cap) */\n  max_stability_days: number;\n}\n\n/**\n * Encoding configuration per section.\n * Controls how strongly new memories encode based on stakes/salience.\n */\nexport interface SectionEncodingConfig {\n  /** Base difficulty for FSRS (0-1, higher = harder to recall = decays faster) */\n  base_difficulty: number;\n  /** Whether this section supports salience modulation (Issue 4) */\n  salience_enabled: boolean;\n  /** Maximum stability multiplier from salience (e.g., 2.0 = up to 2x base) */\n  max_salience_multiplier: number;\n}\n\n/**\n * Complete section profile — all parameters that define a section's behavior.\n */\nexport interface SectionProfile {\n  /** Human-readable section name */\n  name: string;\n  /** Section identifier */\n  section: MemorySection;\n  /** Per-section reranking weights for SSA (Issue 1) */\n  reranking_weights: RerankingWeights;\n  /** Per-section FSRS decay configuration (Issue 2) */\n  decay: SectionDecayConfig;\n  /** Per-section encoding configuration (Issue 4) */\n  encoding: SectionEncodingConfig;\n  /** Role in consolidation pipeline: 'source', 'target', or 'both' (Issue 3) */\n  consolidation_role: 'source' | 'target' | 'both' | 'none';\n  /** Intent boost multiplier when this section matches query intent (Issue 6) */\n  intent_boost: number;\n}\n\n// ============================================================\n// DEFAULT SECTION PROFILES\n// ============================================================\n\n/**\n * Default section profiles.\n *\n * These are the COMPILE-TIME DEFAULTS used by @nous/core.\n * Python-side YAML config can override individual parameters.\n *\n * Weight values are placeholders in this foundation guide.\n * Issues 1, 2, 4, and 6 will finalize the exact values.\n * The STRUCTURE is what matters here — the values will be tuned.\n */\nexport const SECTION_PROFILES: Record<MemorySection, SectionProfile> = {\n  EPISODIC: {\n    name: 'Episodic',\n    section: 'EPISODIC',\n    reranking_weights: {\n      semantic: 0.20,\n      keyword: 0.15,\n      graph: 0.15,\n      recency: 0.30,\n      authority: 0.10,\n      affinity: 0.10,\n    },\n    decay: {\n      initial_stability_days: 14,\n      growth_rate: 2.0,\n      active_threshold: 0.5,\n      weak_threshold: 0.1,\n      max_stability_days: 180,\n    },\n    encoding: {\n      base_difficulty: 0.3,\n      salience_enabled: true,\n      max_salience_multiplier: 2.0,\n    },\n    consolidation_role: 'source',\n    intent_boost: 1.3,\n  },\n\n  SIGNALS: {\n    name: 'Signals',\n    section: 'SIGNALS',\n    reranking_weights: {\n      semantic: 0.15,\n      keyword: 0.10,\n      graph: 0.10,\n      recency: 0.45,\n      authority: 0.10,\n      affinity: 0.10,\n    },\n    decay: {\n      initial_stability_days: 2,\n      growth_rate: 1.5,\n      active_threshold: 0.5,\n      weak_threshold: 0.15,\n      max_stability_days: 30,\n    },\n    encoding: {\n      base_difficulty: 0.2,\n      salience_enabled: false,\n      max_salience_multiplier: 1.0,\n    },\n    consolidation_role: 'source',\n    intent_boost: 1.3,\n  },\n\n  KNOWLEDGE: {\n    name: 'Knowledge',\n    section: 'KNOWLEDGE',\n    reranking_weights: {\n      semantic: 0.35,\n      keyword: 0.15,\n      graph: 0.20,\n      recency: 0.05,\n      authority: 0.20,\n      affinity: 0.05,\n    },\n    decay: {\n      initial_stability_days: 60,\n      growth_rate: 3.0,\n      active_threshold: 0.4,\n      weak_threshold: 0.05,\n      max_stability_days: 365,\n    },\n    encoding: {\n      base_difficulty: 0.4,\n      salience_enabled: true,\n      max_salience_multiplier: 2.0,\n    },\n    consolidation_role: 'target',\n    intent_boost: 1.3,\n  },\n\n  PROCEDURAL: {\n    name: 'Procedural',\n    section: 'PROCEDURAL',\n    reranking_weights: {\n      semantic: 0.25,\n      keyword: 0.25,\n      graph: 0.20,\n      recency: 0.05,\n      authority: 0.15,\n      affinity: 0.10,\n    },\n    decay: {\n      initial_stability_days: 120,\n      growth_rate: 3.5,\n      active_threshold: 0.3,\n      weak_threshold: 0.03,\n      max_stability_days: 365,\n    },\n    encoding: {\n      base_difficulty: 0.5,\n      salience_enabled: true,\n      max_salience_multiplier: 3.0,\n    },\n    consolidation_role: 'target',\n    intent_boost: 1.3,\n  },\n};\n\n// ============================================================\n// ZOD VALIDATION\n// ============================================================\n\nexport const SectionDecayConfigSchema = z.object({\n  initial_stability_days: z.number().positive(),\n  growth_rate: z.number().positive(),\n  active_threshold: z.number().min(0).max(1),\n  weak_threshold: z.number().min(0).max(1),\n  max_stability_days: z.number().positive(),\n});\n\nexport const SectionEncodingConfigSchema = z.object({\n  base_difficulty: z.number().min(0).max(1),\n  salience_enabled: z.boolean(),\n  max_salience_multiplier: z.number().min(1),\n});\n\n// Named SectionRerankingWeightsSchema to avoid collision with params/RerankingWeightsSchema\nexport const SectionRerankingWeightsSchema = z.object({\n  semantic: z.number().min(0).max(1),\n  keyword: z.number().min(0).max(1),\n  graph: z.number().min(0).max(1),\n  recency: z.number().min(0).max(1),\n  authority: z.number().min(0).max(1),\n  affinity: z.number().min(0).max(1),\n}).refine(\n  (w) => Math.abs(w.semantic + w.keyword + w.graph + w.recency + w.authority + w.affinity - 1.0) < 0.01,\n  { message: 'Reranking weights must sum to 1.0' }\n);\n\n/**\n * Validate all section profiles at import time.\n * Throws if any profile has invalid parameters.\n */\nexport function validateSectionProfiles(): void {\n  for (const [section, profile] of Object.entries(SECTION_PROFILES)) {\n    SectionDecayConfigSchema.parse(profile.decay);\n    SectionEncodingConfigSchema.parse(profile.encoding);\n    SectionRerankingWeightsSchema.parse(profile.reranking_weights);\n    if (profile.decay.weak_threshold >= profile.decay.active_threshold) {\n      throw new Error(`Section ${section}: weak_threshold must be < active_threshold`);\n    }\n  }\n}\n\n// Run validation on module load (fail fast if profiles are invalid)\nvalidateSectionProfiles();\n\n// ============================================================\n// PER-SUBTYPE INITIAL STABILITY OVERRIDES\n// ============================================================\n\n/**\n * Per-subtype initial stability overrides (in days).\n * These take priority over section defaults for specific subtypes\n * that need different stability within their section.\n *\n * Example: trade_entry (21d) vs turn_summary (7d) — both EPISODIC\n * but trade records should persist longer than conversation summaries.\n */\nexport const SUBTYPE_INITIAL_STABILITY: Record<string, number> = {\n  // EPISODIC section (default: 14 days)\n  'custom:trade_entry': 21,       // Trade records should persist\n  'custom:trade_close': 21,       // Outcomes are valuable\n  'custom:trade_modify': 14,      // Position adjustments — section default\n  'custom:trade': 14,             // Legacy — section default\n  'custom:turn_summary': 7,       // Compressed exchanges — fast decay\n  'custom:session_summary': 14,   // Session digests — section default\n  'custom:market_event': 10,      // External events — medium\n\n  // SIGNALS section (default: 2 days)\n  'custom:signal': 2,             // Market signals — very fast decay\n  'custom:watchpoint': 5,         // Watchpoints persist slightly longer (user-set)\n\n  // KNOWLEDGE section (default: 60 days)\n  'custom:lesson': 90,            // Hard-won lessons — very durable\n  'custom:thesis': 30,            // Theses have time-bound validity\n  'custom:curiosity': 14,         // Curiosity items are exploratory\n\n  // PROCEDURAL section (default: 120 days)\n  'custom:playbook': 180,         // Validated playbooks — nearly permanent\n  'custom:missed_opportunity': 30, // Regret items — medium persistence\n  'custom:good_pass': 30,         // Good passes — medium persistence\n};\n\n/**\n * Get initial stability for a specific subtype.\n * Falls back to section default, then to 21 days (global fallback).\n */\nexport function getInitialStabilityForSubtype(subtype: string | null | undefined): number {\n  if (subtype && subtype in SUBTYPE_INITIAL_STABILITY) {\n    return SUBTYPE_INITIAL_STABILITY[subtype]!;\n  }\n  const section = getSectionForSubtype(subtype);\n  return SECTION_PROFILES[section].decay.initial_stability_days;\n}\n","/**\n * @module @nous/core/params\n * @description Canonical algorithm parameters for Nous - the single source of truth\n * @version 1.0.0\n * @spec Brainstorms/Specs/Phase-2-Data-Representation/storm-028\n *\n * This module implements storm-028: Algorithm Parameters & Thresholds.\n *\n * storm-028 is the AUTHORITATIVE SOURCE for all algorithm parameters.\n * Other storms should reference this module for values:\n * - storm-005 (Retrieval): Use reranking weights, SSA parameters\n * - storm-007 (Forgetting): Use decay parameters\n * - storm-008 (Classification): Use confidence thresholds\n * - storm-012 (Adaptive Limits): Use budget parameters\n */\n\nimport { z } from 'zod';\nimport { getSectionForSubtype, SECTION_PROFILES, type SectionDecayConfig } from '../sections/index.js';\n\n// ============================================================\n// ALGORITHM NODE TYPES\n// ============================================================\n\n/**\n * Node types for algorithm behavior.\n * These are behavioral categories used for stability/difficulty,\n * distinct from storm-011's structural node types.\n */\nexport const ALGORITHM_NODE_TYPES = [\n  'person',\n  'fact',\n  'concept',\n  'event',\n  'note',\n  'document',\n  'preference',\n] as const;\n\nexport type AlgorithmNodeType = (typeof ALGORITHM_NODE_TYPES)[number];\n\n// ============================================================\n// RERANKING WEIGHTS\n// ============================================================\n\n/**\n * Reranking weight configuration.\n * All weights must sum to 1.0.\n */\nexport interface RerankingWeights {\n  semantic: number;   // 0.30 - Vector similarity\n  keyword: number;    // 0.15 - BM25 keyword match\n  graph: number;      // 0.20 - Spreading activation\n  recency: number;    // 0.15 - Time-based decay\n  authority: number;  // 0.10 - Inbound edge count\n  affinity: number;   // 0.10 - User interaction history\n}\n\nexport const RerankingWeightsSchema = z.object({\n  semantic: z.number().min(0).max(1),\n  keyword: z.number().min(0).max(1),\n  graph: z.number().min(0).max(1),\n  recency: z.number().min(0).max(1),\n  authority: z.number().min(0).max(1),\n  affinity: z.number().min(0).max(1),\n}).refine(\n  (w) => Math.abs(w.semantic + w.keyword + w.graph + w.recency + w.authority + w.affinity - 1.0) < 0.001,\n  { message: 'Reranking weights must sum to 1.0' }\n);\n\n/**\n * Default reranking weights.\n */\nexport const RERANKING_WEIGHTS: RerankingWeights = {\n  semantic: 0.30,\n  keyword: 0.15,\n  graph: 0.20,\n  recency: 0.15,\n  authority: 0.10,\n  affinity: 0.10,\n};\n\n/**\n * Reranking behavior configuration.\n */\nexport interface RerankingConfig {\n  recency_half_life_days: number;\n  authority_cap_multiple: number;\n  affinity_saturation: number;\n  new_content_boost_days: number;\n  new_content_boost_value: number;\n}\n\nexport const RerankingConfigSchema = z.object({\n  recency_half_life_days: z.number().positive(),\n  authority_cap_multiple: z.number().positive(),\n  affinity_saturation: z.number().positive(),\n  new_content_boost_days: z.number().int().nonnegative(),\n  new_content_boost_value: z.number().min(0).max(1),\n});\n\nexport const RERANKING_CONFIG: RerankingConfig = {\n  recency_half_life_days: 30,\n  authority_cap_multiple: 2.0,\n  affinity_saturation: 10,\n  new_content_boost_days: 7,\n  new_content_boost_value: 0.2,\n};\n\n/**\n * Per-signal score breakdown.\n */\nexport interface ScoreBreakdown {\n  semantic: number;\n  keyword: number;\n  graph: number;\n  recency: number;\n  authority: number;\n  affinity: number;\n}\n\nexport const ScoreBreakdownSchema = z.object({\n  semantic: z.number().min(0).max(1),\n  keyword: z.number().min(0).max(1),\n  graph: z.number().min(0).max(1),\n  recency: z.number().min(0).max(1),\n  authority: z.number().min(0).max(1),\n  affinity: z.number().min(0).max(1),\n});\n\n/**\n * Scored node input for reranking.\n */\nexport interface ScoredNode {\n  id: string;\n  semantic_score?: number;\n  bm25_score?: number;\n  graph_score?: number;\n  last_accessed: Date;\n  created_at: Date;\n  access_count: number;\n  inbound_edge_count: number;\n  subtype?: string;  // e.g. 'custom:lesson' — used for per-section reranking (Issue 1)\n}\n\nexport const ScoredNodeSchema = z.object({\n  id: z.string(),\n  semantic_score: z.number().min(0).max(1).optional(),\n  bm25_score: z.number().nonnegative().optional(),\n  graph_score: z.number().min(0).max(1).optional(),\n  last_accessed: z.date(),\n  created_at: z.date(),\n  access_count: z.number().int().nonnegative(),\n  inbound_edge_count: z.number().int().nonnegative(),\n  subtype: z.string().optional(),\n});\n\n/**\n * Graph metrics for reranking context.\n */\nexport interface GraphMetrics {\n  total_nodes: number;\n  total_edges: number;\n  density: number;\n  avg_inbound_edges: number;\n  avg_outbound_edges: number;\n}\n\nexport const GraphMetricsSchema = z.object({\n  total_nodes: z.number().int().nonnegative(),\n  total_edges: z.number().int().nonnegative(),\n  density: z.number().min(0).max(1),\n  avg_inbound_edges: z.number().nonnegative(),\n  avg_outbound_edges: z.number().nonnegative(),\n});\n\n/**\n * Ranked node result.\n */\nexport interface RankedNode {\n  node: ScoredNode;\n  score: number;\n  breakdown: ScoreBreakdown;\n  primary_signal: keyof ScoreBreakdown;\n}\n\n// ============================================================\n// DECAY CONFIGURATION\n// ============================================================\n\n/**\n * Decay behavior configuration (FSRS-inspired).\n */\nexport interface DecayConfig {\n  growth_rate: number;            // 2.5 - Stability multiplier on access\n  max_stability_days: number;     // 365 - Cap at 1 year\n  active_threshold: number;       // 0.5 - R > 0.5 = ACTIVE\n  weak_threshold: number;         // 0.1 - R 0.1-0.5 = WEAK, R < 0.1 = DORMANT\n  dormant_days: number;           // 60 - Days at R < 0.1 before dormant status\n  compress_days: number;          // 120 - Days before compression eligible\n  archive_days: number;           // 240 - Days before archive eligible\n  cascade_factor: number;         // 0.8 - Edge weakening on dormant\n  edge_floor: number;             // 0.1 - Minimum edge strength\n}\n\nexport const DecayConfigSchema = z.object({\n  growth_rate: z.number().positive(),\n  max_stability_days: z.number().int().positive(),\n  active_threshold: z.number().min(0).max(1),\n  weak_threshold: z.number().min(0).max(1),\n  dormant_days: z.number().int().nonnegative(),\n  compress_days: z.number().int().nonnegative(),\n  archive_days: z.number().int().nonnegative(),\n  cascade_factor: z.number().min(0).max(1),\n  edge_floor: z.number().min(0).max(1),\n});\n\nexport const DECAY_CONFIG: DecayConfig = {\n  growth_rate: 2.5,\n  max_stability_days: 365,\n  active_threshold: 0.5,\n  weak_threshold: 0.1,\n  dormant_days: 60,\n  compress_days: 120,\n  archive_days: 240,\n  cascade_factor: 0.8,\n  edge_floor: 0.1,\n};\n\n/**\n * Initial stability per algorithm node type (days).\n */\nexport const INITIAL_STABILITY: Record<AlgorithmNodeType, number> = {\n  person: 14,\n  fact: 7,\n  concept: 21,\n  event: 10,\n  note: 30,\n  document: 7,\n  preference: 45,\n};\n\n/**\n * Initial difficulty per algorithm node type (0-1).\n */\nexport const INITIAL_DIFFICULTY: Record<AlgorithmNodeType, number> = {\n  person: 0.2,\n  fact: 0.3,\n  concept: 0.4,\n  event: 0.3,\n  note: 0.2,\n  document: 0.5,\n  preference: 0.1,\n};\n\n/**\n * Decay-based lifecycle states for memory retrieval.\n * NOTE: These are distinct from storm-011's content lifecycle states.\n * These states are used by the forgetting model (storm-007) for decay calculations.\n */\nexport const DECAY_LIFECYCLE_STATES = ['ACTIVE', 'WEAK', 'DORMANT', 'COMPRESS', 'ARCHIVE'] as const;\nexport type DecayLifecycleState = (typeof DECAY_LIFECYCLE_STATES)[number];\n\n// ============================================================\n// SSA PARAMETERS\n// ============================================================\n\n/**\n * SSA aggregation modes.\n */\nexport type SSAAggregation = 'sum' | 'max';\n\n/**\n * Spreading activation parameters.\n */\nexport interface SSAParams {\n  initial_activation: number;   // 1.0 - Seeds start at full\n  hop_decay: number;            // 0.80 - 20% loss per hop\n  min_threshold: number;        // 0.01 - Stop spreading below 1%\n  max_hops: number;             // 3 - Hard limit\n  max_nodes: number;            // 500 - Breadth limit\n  aggregation: SSAAggregation;  // 'sum' - Allow path reinforcement\n}\n\nexport const SSAParamsSchema = z.object({\n  initial_activation: z.number().min(0).max(1),\n  hop_decay: z.number().min(0).max(1),\n  min_threshold: z.number().min(0).max(1),\n  max_hops: z.number().int().positive(),\n  max_nodes: z.number().int().positive(),\n  aggregation: z.enum(['sum', 'max']),\n});\n\nexport const SSA_PARAMS: SSAParams = {\n  initial_activation: 1.0,\n  hop_decay: 0.80,\n  min_threshold: 0.01,\n  max_hops: 3,\n  max_nodes: 500,\n  aggregation: 'sum',\n};\n\n/**\n * Edge weights for SSA.\n * NOTE: These reference storm-031's edge weights but are defined here\n * as the canonical SSA values.\n */\nexport interface SSAEdgeWeights {\n  same_entity: number;\n  part_of: number;\n  caused_by: number;\n  mentioned_together: number;\n  related_to: number;\n  similar_to: number;\n  user_linked: number;\n  temporal_adjacent: number;\n  generalizes: number;  // Knowledge generalized from episodes (consolidation — Issue 3)\n  applied_to: number;   // Playbook applied to trade entry (procedural — Issue 5)\n}\n\nexport const SSAEdgeWeightsSchema = z.object({\n  same_entity: z.number().min(0).max(1),\n  part_of: z.number().min(0).max(1),\n  caused_by: z.number().min(0).max(1),\n  mentioned_together: z.number().min(0).max(1),\n  related_to: z.number().min(0).max(1),\n  similar_to: z.number().min(0).max(1),\n  user_linked: z.number().min(0).max(1),\n  temporal_adjacent: z.number().min(0).max(1),\n  generalizes: z.number().min(0).max(1),\n  applied_to: z.number().min(0).max(1),\n});\n\nexport const SSA_EDGE_WEIGHTS: SSAEdgeWeights = {\n  same_entity: 0.95,\n  part_of: 0.85,\n  caused_by: 0.80,\n  applied_to: 0.75,     // Playbook applied to trade entry (procedural — Issue 5)\n  generalizes: 0.70,    // Knowledge generalized from episodes (consolidation — Issue 3)\n  mentioned_together: 0.60,\n  related_to: 0.50,\n  similar_to: 0.45,\n  user_linked: 0.90,\n  temporal_adjacent: 0.40,\n};\n\n/**\n * Activated node result from SSA.\n */\nexport interface ActivatedNode {\n  id: string;\n  activation: number;\n  path: string[];\n}\n\nexport const ActivatedNodeSchema = z.object({\n  id: z.string(),\n  activation: z.number().min(0).max(1),\n  path: z.array(z.string()),\n});\n\n// ============================================================\n// CONFIDENCE THRESHOLDS\n// ============================================================\n\n/**\n * Confidence threshold categories.\n */\nexport interface ConfidenceThresholds {\n  retrieval: {\n    high: number;     // 0.70 - Answer directly\n    medium: number;   // 0.45 - May need context\n    low: number;      // 0.45 - Below this, clarify\n  };\n  classification: {\n    clear_lookup: number;    // 0.85 - Definitely a simple lookup\n    clear_reasoning: number; // 0.85 - Definitely needs reasoning\n    ambiguous_floor: number; // 0.50 - Below this is REASONING\n  };\n  extraction: {\n    auto_store: number;    // 0.85 - Store without asking\n    confirm_store: number; // 0.60 - Ask user to confirm\n  };\n  contradiction: {\n    definite: number;  // 0.85 - Flag for user\n    possible: number;  // 0.60 - Note internally\n  };\n}\n\nexport const ConfidenceThresholdsSchema = z.object({\n  retrieval: z.object({\n    high: z.number().min(0).max(1),\n    medium: z.number().min(0).max(1),\n    low: z.number().min(0).max(1),\n  }),\n  classification: z.object({\n    clear_lookup: z.number().min(0).max(1),\n    clear_reasoning: z.number().min(0).max(1),\n    ambiguous_floor: z.number().min(0).max(1),\n  }),\n  extraction: z.object({\n    auto_store: z.number().min(0).max(1),\n    confirm_store: z.number().min(0).max(1),\n  }),\n  contradiction: z.object({\n    definite: z.number().min(0).max(1),\n    possible: z.number().min(0).max(1),\n  }),\n});\n\nexport const CONFIDENCE_THRESHOLDS: ConfidenceThresholds = {\n  retrieval: {\n    high: 0.70,\n    medium: 0.45,\n    low: 0.45,\n  },\n  classification: {\n    clear_lookup: 0.85,\n    clear_reasoning: 0.85,\n    ambiguous_floor: 0.50,\n  },\n  extraction: {\n    auto_store: 0.85,\n    confirm_store: 0.60,\n  },\n  contradiction: {\n    definite: 0.85,\n    possible: 0.60,\n  },\n};\n\n/**\n * Confidence levels.\n */\nexport const CONFIDENCE_LEVELS = ['HIGH', 'MEDIUM', 'LOW'] as const;\nexport type ConfidenceLevel = (typeof CONFIDENCE_LEVELS)[number];\n\n/**\n * Retrieval Confidence System weights.\n */\nexport interface RCSWeights {\n  match_quality: number;     // 0.40\n  distinctiveness: number;   // 0.35\n  completeness: number;      // 0.25\n}\n\nexport const RCSWeightsSchema = z.object({\n  match_quality: z.number().min(0).max(1),\n  distinctiveness: z.number().min(0).max(1),\n  completeness: z.number().min(0).max(1),\n});\n\nexport const RCS_WEIGHTS: RCSWeights = {\n  match_quality: 0.40,\n  distinctiveness: 0.35,\n  completeness: 0.25,\n};\n\n/**\n * Retrieval confidence result.\n */\nexport interface RetrievalConfidenceResult {\n  score: number;\n  level: ConfidenceLevel;\n  breakdown: { mq: number; dt: number; cm: number };\n  flags: string[];\n}\n\nexport const RetrievalConfidenceResultSchema = z.object({\n  score: z.number().min(0).max(1),\n  level: z.enum(CONFIDENCE_LEVELS),\n  breakdown: z.object({\n    mq: z.number().min(0).max(1),\n    dt: z.number().min(0).max(1),\n    cm: z.number().min(0).max(1),\n  }),\n  flags: z.array(z.string()),\n});\n\n/**\n * Contradiction detection levels.\n */\nexport const CONTRADICTION_LEVELS = ['definite', 'possible', 'none'] as const;\nexport type ContradictionLevel = (typeof CONTRADICTION_LEVELS)[number];\n\n/**\n * Contradiction detection result.\n */\nexport interface ContradictionResult {\n  level: ContradictionLevel;\n  score: number;\n  action: 'flag_user' | 'note_internal' | 'safe_to_store';\n  explanation: string;\n}\n\nexport const ContradictionResultSchema = z.object({\n  level: z.enum(CONTRADICTION_LEVELS),\n  score: z.number().min(0).max(1),\n  action: z.enum(['flag_user', 'note_internal', 'safe_to_store']),\n  explanation: z.string(),\n});\n\n// ============================================================\n// ADAPTIVE LIMITS\n// ============================================================\n\n/**\n * Budget configuration per operation.\n */\nexport interface BudgetConfig {\n  time_ms: number;\n  max_nodes: number;\n  max_api_calls: number;\n}\n\nexport const BudgetConfigSchema = z.object({\n  time_ms: z.number().nonnegative(),\n  max_nodes: z.number().int().nonnegative(),\n  max_api_calls: z.number().int().nonnegative(),\n});\n\nexport const OPERATION_BUDGETS: Record<string, BudgetConfig> = {\n  simple_lookup: { time_ms: 50, max_nodes: 100, max_api_calls: 0 },\n  standard_query: { time_ms: 100, max_nodes: 500, max_api_calls: 0 },\n  complex_query: { time_ms: 200, max_nodes: 1000, max_api_calls: 0 },\n  phase2_reasoning: { time_ms: 3000, max_nodes: 500, max_api_calls: 5 },\n  deep_search: { time_ms: 500, max_nodes: 2000, max_api_calls: 0 },\n  serendipity: { time_ms: 200, max_nodes: 200, max_api_calls: 0 },\n};\n\n/**\n * Quality target per query type.\n */\nexport interface QualityTarget {\n  confidence: number;\n  min_coverage: number;\n}\n\nexport const QualityTargetSchema = z.object({\n  confidence: z.number().min(0).max(1),\n  min_coverage: z.number().min(0).max(1),\n});\n\nexport const QUALITY_TARGETS: Record<string, QualityTarget> = {\n  LOOKUP: { confidence: 0.80, min_coverage: 0.60 },\n  REASONING: { confidence: 0.70, min_coverage: 0.70 },\n  EXPLORATORY: { confidence: 0.50, min_coverage: 0.40 },\n  TEMPORAL: { confidence: 0.75, min_coverage: 0.65 },\n};\n\n/**\n * Quality score weights.\n */\nexport interface QualityWeights {\n  coverage: number;\n  match_quality: number;\n  convergence: number;\n}\n\nexport const QualityWeightsSchema = z.object({\n  coverage: z.number().min(0).max(1),\n  match_quality: z.number().min(0).max(1),\n  convergence: z.number().min(0).max(1),\n});\n\nexport const QUALITY_WEIGHTS: QualityWeights = {\n  coverage: 0.35,\n  match_quality: 0.45,\n  convergence: 0.20,\n};\n\n/**\n * Cold start threshold (node count).\n */\nexport const COLD_START_THRESHOLD = 200;\n\n/**\n * Adaptive limits configuration.\n */\nexport interface AdaptiveLimits {\n  entry_points: number;\n  max_hops: number;\n  max_nodes: number;\n}\n\nexport const AdaptiveLimitsSchema = z.object({\n  entry_points: z.number().int().positive(),\n  max_hops: z.number().int().positive(),\n  max_nodes: z.number().int().positive(),\n});\n\nexport const COLD_START_LIMITS: AdaptiveLimits = {\n  entry_points: 2,\n  max_hops: 3,\n  max_nodes: 50,\n};\n\n/**\n * Query types for adaptive limits.\n */\nexport const QUERY_TYPES = ['simple', 'standard', 'complex'] as const;\nexport type QueryType = (typeof QUERY_TYPES)[number];\n\n/**\n * Termination result.\n */\nexport interface TerminationResult {\n  terminate: boolean;\n  reason: string;\n}\n\nexport const TerminationResultSchema = z.object({\n  terminate: z.boolean(),\n  reason: z.string(),\n});\n\n// ============================================================\n// BM25 CONFIGURATION\n// ============================================================\n\n/**\n * Stemmer types.\n */\nexport type StemmerType = 'porter' | 'snowball' | 'none';\n\n/**\n * BM25 core configuration.\n */\nexport interface BM25Config {\n  k1: number;                     // 1.2 - Term frequency saturation\n  b: number;                      // 0.75 - Document length normalization\n  min_term_length: number;        // 2\n  max_term_length: number;        // 50\n  max_doc_frequency_ratio: number; // 0.95\n  stemmer: StemmerType;\n  preserve_original: boolean;\n}\n\nexport const BM25ConfigSchema = z.object({\n  k1: z.number().positive(),\n  b: z.number().min(0).max(1),\n  min_term_length: z.number().int().positive(),\n  max_term_length: z.number().int().positive(),\n  max_doc_frequency_ratio: z.number().min(0).max(1),\n  stemmer: z.enum(['porter', 'snowball', 'none']),\n  preserve_original: z.boolean(),\n});\n\nexport const BM25_CONFIG: BM25Config = {\n  k1: 1.2,\n  b: 0.75,\n  min_term_length: 2,\n  max_term_length: 50,\n  max_doc_frequency_ratio: 0.95,\n  stemmer: 'porter',\n  preserve_original: true,\n};\n\n/**\n * Field types for boosting.\n */\nexport type FieldType = 'title' | 'tags' | 'headers' | 'body' | 'metadata';\n\n/**\n * Field boost configuration.\n */\nexport interface FieldBoost {\n  field: FieldType;\n  boost: number;\n}\n\nexport const FieldBoostSchema = z.object({\n  field: z.enum(['title', 'tags', 'headers', 'body', 'metadata']),\n  boost: z.number().positive(),\n});\n\nexport const FIELD_BOOSTS: FieldBoost[] = [\n  { field: 'title', boost: 3.0 },\n  { field: 'tags', boost: 2.5 },\n  { field: 'headers', boost: 2.0 },\n  { field: 'body', boost: 1.0 },\n  { field: 'metadata', boost: 0.5 },\n];\n\n/**\n * Stopwords behavior.\n */\nexport type StopwordsBehavior = 'remove_from_query' | 'remove_from_both' | 'keep_for_phrases';\n\n/**\n * Stopwords configuration.\n */\nexport interface StopwordsConfig {\n  language: string;\n  default_list: string[];\n  custom_additions: string[];\n  behavior: StopwordsBehavior;\n}\n\nexport const StopwordsConfigSchema = z.object({\n  language: z.string(),\n  default_list: z.array(z.string()),\n  custom_additions: z.array(z.string()),\n  behavior: z.enum(['remove_from_query', 'remove_from_both', 'keep_for_phrases']),\n});\n\nexport const STOPWORDS_CONFIG: StopwordsConfig = {\n  language: 'en',\n  default_list: [\n    'a', 'an', 'the',\n    'and', 'or', 'but',\n    'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'from', 'as',\n    'is', 'was', 'are', 'were', 'been', 'be',\n    'have', 'has', 'had',\n    'do', 'does', 'did',\n    'will', 'would', 'could', 'should', 'may', 'might', 'must', 'shall', 'can',\n    'this', 'that', 'these', 'those',\n    'i', 'you', 'he', 'she', 'it', 'we', 'they',\n    'what', 'which', 'who', 'whom', 'whose', 'where', 'when', 'why', 'how',\n  ],\n  custom_additions: [\n    'note', 'notes',\n    'idea', 'ideas',\n    'thought', 'thoughts',\n    'todo', 'item', 'entry',\n  ],\n  behavior: 'remove_from_query',\n};\n\n// ============================================================\n// MASTER ALGORITHM PARAMS\n// ============================================================\n\n/**\n * Master algorithm parameters aggregation.\n */\nexport interface AlgorithmParams {\n  reranking: {\n    weights: RerankingWeights;\n    config: RerankingConfig;\n  };\n  decay: {\n    config: DecayConfig;\n    initial_stability: Record<AlgorithmNodeType, number>;\n    initial_difficulty: Record<AlgorithmNodeType, number>;\n  };\n  ssa: {\n    params: SSAParams;\n    edge_weights: SSAEdgeWeights;\n  };\n  confidence: {\n    thresholds: ConfidenceThresholds;\n    rcs_weights: RCSWeights;\n  };\n  adaptive: {\n    budgets: Record<string, BudgetConfig>;\n    quality_targets: Record<string, QualityTarget>;\n    quality_weights: QualityWeights;\n    cold_start_threshold: number;\n    cold_start_limits: AdaptiveLimits;\n  };\n  bm25: {\n    config: BM25Config;\n    field_boosts: FieldBoost[];\n    stopwords: StopwordsConfig;\n  };\n}\n\n/**\n * The canonical algorithm parameters object.\n * This is THE single source of truth for all algorithm parameters.\n */\nexport const ALGORITHM_PARAMS: AlgorithmParams = {\n  reranking: {\n    weights: RERANKING_WEIGHTS,\n    config: RERANKING_CONFIG,\n  },\n  decay: {\n    config: DECAY_CONFIG,\n    initial_stability: INITIAL_STABILITY,\n    initial_difficulty: INITIAL_DIFFICULTY,\n  },\n  ssa: {\n    params: SSA_PARAMS,\n    edge_weights: SSA_EDGE_WEIGHTS,\n  },\n  confidence: {\n    thresholds: CONFIDENCE_THRESHOLDS,\n    rcs_weights: RCS_WEIGHTS,\n  },\n  adaptive: {\n    budgets: OPERATION_BUDGETS,\n    quality_targets: QUALITY_TARGETS,\n    quality_weights: QUALITY_WEIGHTS,\n    cold_start_threshold: COLD_START_THRESHOLD,\n    cold_start_limits: COLD_START_LIMITS,\n  },\n  bm25: {\n    config: BM25_CONFIG,\n    field_boosts: FIELD_BOOSTS,\n    stopwords: STOPWORDS_CONFIG,\n  },\n};\n\n// ============================================================\n// HELPER FUNCTIONS\n// ============================================================\n\n/**\n * Calculates days between two dates.\n */\nfunction daysBetween(start: Date, end: Date): number {\n  return Math.floor((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));\n}\n\n// ============================================================\n// RERANKING FUNCTIONS\n// ============================================================\n\n/**\n * Gets semantic score from node.\n */\nexport function semanticScore(node: ScoredNode): number {\n  return node.semantic_score ?? 0;\n}\n\n/**\n * Normalizes BM25 score against batch max.\n */\nexport function keywordScore(node: ScoredNode, maxBM25: number, candidateCount: number): number {\n  if (maxBM25 === 0) return 0.5;\n  if (candidateCount === 1) return 1.0;\n  return (node.bm25_score ?? 0) / maxBM25;\n}\n\n/**\n * Gets graph score from node.\n */\nexport function graphScore(node: ScoredNode): number {\n  return node.graph_score ?? 0;\n}\n\n/**\n * Calculates recency score using exponential decay.\n */\nexport function recencyScore(lastAccessed: Date, now: Date = new Date()): number {\n  const daysSince = daysBetween(lastAccessed, now);\n  return Math.exp(-daysSince / RERANKING_CONFIG.recency_half_life_days);\n}\n\n/**\n * Calculates authority score based on inbound edges.\n */\nexport function authorityScore(inboundEdges: number, avgInbound: number): number {\n  if (avgInbound === 0) return 0.5;\n  const ratio = inboundEdges / avgInbound;\n  return Math.min(ratio / RERANKING_CONFIG.authority_cap_multiple, 1.0);\n}\n\n/**\n * Calculates affinity score based on interaction history.\n */\nexport function affinityScore(\n  accessCount: number,\n  createdAt: Date,\n  lastAccessed: Date,\n  now: Date = new Date()\n): number {\n  const recency = recencyScore(lastAccessed, now);\n  const interactionScore = Math.tanh(accessCount / RERANKING_CONFIG.affinity_saturation) * recency;\n\n  const ageDays = daysBetween(createdAt, now);\n  const newContentBoost = ageDays < RERANKING_CONFIG.new_content_boost_days\n    ? RERANKING_CONFIG.new_content_boost_value\n    : 0;\n\n  return Math.min(interactionScore + newContentBoost, 1.0);\n}\n\n/**\n * Reranks candidates using all 6 signals.\n */\nexport function rerankCandidates(\n  candidates: ScoredNode[],\n  metrics: GraphMetrics,\n  weights: RerankingWeights = RERANKING_WEIGHTS,\n  now: Date = new Date()\n): RankedNode[] {\n  if (candidates.length === 0) return [];\n\n  const maxBM25 = Math.max(...candidates.map(c => c.bm25_score ?? 0));\n\n  return candidates.map(node => {\n    const breakdown: ScoreBreakdown = {\n      semantic: semanticScore(node),\n      keyword: keywordScore(node, maxBM25, candidates.length),\n      graph: graphScore(node),\n      recency: recencyScore(node.last_accessed, now),\n      authority: authorityScore(node.inbound_edge_count, metrics.avg_inbound_edges),\n      affinity: affinityScore(node.access_count, node.created_at, node.last_accessed, now),\n    };\n\n    const score =\n      weights.semantic * breakdown.semantic +\n      weights.keyword * breakdown.keyword +\n      weights.graph * breakdown.graph +\n      weights.recency * breakdown.recency +\n      weights.authority * breakdown.authority +\n      weights.affinity * breakdown.affinity;\n\n    const contributions = Object.entries(breakdown).map(([key, value]) => ({\n      key: key as keyof ScoreBreakdown,\n      contribution: weights[key as keyof RerankingWeights] * value\n    }));\n    const primary = contributions.reduce((a, b) =>\n      b.contribution > a.contribution ? b : a\n    ).key;\n\n    return { node, score, breakdown, primary_signal: primary };\n  }).sort((a, b) => b.score - a.score);\n}\n\n/**\n * Reranks candidates using per-section weights.\n *\n * Each candidate's subtype is mapped to a memory section, and that section's\n * weight profile is used for scoring. This gives different memory types\n * fundamentally different retrieval behavior:\n *   - Signals: recency-dominant (0.45 recency)\n *   - Episodic: recency-favoring (0.30 recency)\n *   - Knowledge: authority-dominant (0.20 authority, 0.35 semantic)\n *   - Procedural: keyword+graph-dominant (0.25 keyword, 0.20 graph)\n *\n * Critical design choice: maxBM25 is computed across ALL candidates (not per\n * section) so keyword scores are normalized against the full candidate set.\n * This prevents a section with one low-BM25 node from inflating that node's\n * keyword score to 1.0.\n *\n * Falls back to global RERANKING_WEIGHTS for nodes without a subtype.\n *\n * @see revisions/memory-sections/executive-summary.md — Issue 1\n * @see revisions/memory-sections/issue-0-section-foundation.md — SECTION_PROFILES\n */\nexport function rerankWithSectionWeights(\n  candidates: ScoredNode[],\n  metrics: GraphMetrics,\n  now: Date = new Date()\n): RankedNode[] {\n  if (candidates.length === 0) return [];\n\n  // maxBM25 is computed across ALL candidates — shared normalization base\n  const maxBM25 = Math.max(...candidates.map(c => c.bm25_score ?? 0));\n\n  return candidates.map(node => {\n    // Look up section-specific weights for this node's subtype\n    const section = getSectionForSubtype(node.subtype);\n    const weights = SECTION_PROFILES[section].reranking_weights;\n\n    const breakdown: ScoreBreakdown = {\n      semantic: semanticScore(node),\n      keyword: keywordScore(node, maxBM25, candidates.length),\n      graph: graphScore(node),\n      recency: recencyScore(node.last_accessed, now),\n      authority: authorityScore(node.inbound_edge_count, metrics.avg_inbound_edges),\n      affinity: affinityScore(node.access_count, node.created_at, node.last_accessed, now),\n    };\n\n    const score =\n      weights.semantic * breakdown.semantic +\n      weights.keyword * breakdown.keyword +\n      weights.graph * breakdown.graph +\n      weights.recency * breakdown.recency +\n      weights.authority * breakdown.authority +\n      weights.affinity * breakdown.affinity;\n\n    const contributions = Object.entries(breakdown).map(([key, value]) => ({\n      key: key as keyof ScoreBreakdown,\n      contribution: weights[key as keyof RerankingWeights] * value\n    }));\n    const primary = contributions.reduce((a, b) =>\n      b.contribution > a.contribution ? b : a\n    ).key;\n\n    return { node, score, breakdown, primary_signal: primary };\n  }).sort((a, b) => b.score - a.score);\n}\n\n// ============================================================\n// DECAY FUNCTIONS\n// ============================================================\n\n/**\n * Calculates retrievability using exponential decay.\n * R = e^(-t/S)\n */\nexport function calculateRetrievability(daysSinceAccess: number, stability: number): number {\n  if (stability <= 0) return 0;\n  return Math.exp(-daysSinceAccess / stability);\n}\n\n/**\n * Calculates difficulty based on node characteristics.\n */\nexport function calculateDifficulty(\n  type: AlgorithmNodeType,\n  contentLength: number,\n  edgeCount: number\n): number {\n  const baseDifficulty = INITIAL_DIFFICULTY[type] ?? 0.3;\n  const lengthFactor = Math.min(contentLength / 5000, 1) * 0.15;\n  const abstractionFactor = type === 'concept' ? 0.1 : 0;\n  const connectionBonus = -Math.min(edgeCount / 40, 1) * 0.15;\n\n  return Math.max(0, Math.min(1,\n    baseDifficulty + lengthFactor + abstractionFactor + connectionBonus\n  ));\n}\n\n/**\n * Updates stability on access.\n */\nexport function updateStabilityOnAccess(stability: number, difficulty: number): number {\n  const difficultyFactor = 1 - (difficulty * 0.5);\n  return Math.min(\n    stability * DECAY_CONFIG.growth_rate * difficultyFactor,\n    DECAY_CONFIG.max_stability_days\n  );\n}\n\n/**\n * Gets decay lifecycle state based on retrievability.\n */\nexport function getDecayLifecycleState(retrievability: number, daysDormant: number): DecayLifecycleState {\n  if (retrievability > DECAY_CONFIG.active_threshold) return 'ACTIVE';\n  if (retrievability > DECAY_CONFIG.weak_threshold) return 'WEAK';\n  if (daysDormant < DECAY_CONFIG.dormant_days) return 'DORMANT';\n  if (daysDormant < DECAY_CONFIG.compress_days) return 'DORMANT';\n  if (daysDormant < DECAY_CONFIG.archive_days) return 'COMPRESS';\n  return 'ARCHIVE';\n}\n\n/**\n * Applies cascade decay to edge weight.\n */\nexport function applyCascadeDecay(edgeWeight: number, retrievability: number): number {\n  if (retrievability >= DECAY_CONFIG.weak_threshold) {\n    return edgeWeight;\n  }\n  return Math.max(edgeWeight * DECAY_CONFIG.cascade_factor, DECAY_CONFIG.edge_floor);\n}\n\n/**\n * Gets initial stability for a node type.\n */\nexport function getInitialStability(type: AlgorithmNodeType): number {\n  return INITIAL_STABILITY[type] ?? 14;\n}\n\n/**\n * Gets initial difficulty for a node type.\n */\nexport function getInitialDifficulty(type: AlgorithmNodeType): number {\n  return INITIAL_DIFFICULTY[type] ?? 0.3;\n}\n\n/**\n * Gets decay lifecycle state using per-section thresholds.\n *\n * Unlike getDecayLifecycleState() which uses global DECAY_CONFIG,\n * this variant accepts a SectionDecayConfig so each memory section\n * can have different active/weak thresholds and lifecycle timing.\n *\n * Also fixes the dead branch bug in the original function where\n * COMPRESS was unreachable (line 1030 returned 'DORMANT' instead of 'COMPRESS').\n *\n * @param retrievability Current R value (0-1)\n * @param daysDormant Days the node has been below weak_threshold\n * @param decay Section-specific decay configuration\n * @returns Lifecycle state: ACTIVE | WEAK | DORMANT | COMPRESS | ARCHIVE\n *\n * @see revisions/memory-sections/issue-2-decay-curves.md\n */\nexport function getDecayLifecycleStateForSection(\n  retrievability: number,\n  daysDormant: number,\n  decay: SectionDecayConfig,\n): DecayLifecycleState {\n  if (retrievability > decay.active_threshold) return 'ACTIVE';\n  if (retrievability > decay.weak_threshold) return 'WEAK';\n  // Below weak_threshold — use dormant/compress/archive timing from global DECAY_CONFIG\n  // (These day-based thresholds are uniform across sections — only R-based thresholds differ)\n  if (daysDormant < DECAY_CONFIG.dormant_days) return 'DORMANT';\n  if (daysDormant < DECAY_CONFIG.compress_days) return 'COMPRESS';  // Fixed: was 'DORMANT' (dead branch)\n  if (daysDormant < DECAY_CONFIG.archive_days) return 'ARCHIVE';\n  return 'ARCHIVE';\n}\n\n/**\n * Updates stability on access using per-section growth rate and max stability.\n *\n * Unlike updateStabilityOnAccess() which uses global DECAY_CONFIG,\n * this variant accepts a SectionDecayConfig so each memory section\n * can have different reinforcement strength and stability caps.\n *\n * @param stability Current stability in days\n * @param difficulty Node difficulty (0-1)\n * @param decay Section-specific decay configuration\n * @returns New stability in days (capped at section's max_stability_days)\n *\n * @see revisions/memory-sections/issue-2-decay-curves.md\n */\nexport function updateStabilityOnAccessForSection(\n  stability: number,\n  difficulty: number,\n  decay: SectionDecayConfig,\n): number {\n  const difficultyFactor = 1 - (difficulty * 0.5);\n  return Math.min(\n    stability * decay.growth_rate * difficultyFactor,\n    decay.max_stability_days,\n  );\n}\n\n// ============================================================\n// CONFIDENCE FUNCTIONS\n// ============================================================\n\n/**\n * Calculates retrieval confidence using RCS.\n */\nexport function calculateRetrievalConfidence(\n  topScore: number,\n  secondScore: number | null,\n  resultCount: number,\n  hasAttribute: boolean\n): RetrievalConfidenceResult {\n  if (resultCount === 0) {\n    return {\n      score: 0,\n      level: 'LOW',\n      breakdown: { mq: 0, dt: 0, cm: 0 },\n      flags: ['no_results'],\n    };\n  }\n\n  const MQ = topScore;\n\n  const scoreGap = secondScore !== null ? topScore - secondScore : 1.0;\n  const gapNormalized = Math.min(scoreGap / 0.3, 1.0);\n  let focus: number;\n  if (resultCount === 1) focus = 1.0;\n  else if (resultCount <= 5) focus = 0.8;\n  else if (resultCount <= 15) focus = 0.5;\n  else focus = 0.3;\n  const DT = gapNormalized * 0.5 + focus * 0.5;\n\n  const CM = hasAttribute ? 1.0 : 0.5;\n\n  const MQ_safe = Math.max(MQ, 0.1);\n  const DT_safe = Math.max(DT, 0.1);\n  const CM_safe = Math.max(CM, 0.1);\n\n  let score = Math.pow(MQ_safe, RCS_WEIGHTS.match_quality) *\n              Math.pow(DT_safe, RCS_WEIGHTS.distinctiveness) *\n              Math.pow(CM_safe, RCS_WEIGHTS.completeness);\n\n  if (MQ < 0.3) score = Math.min(score, 0.4);\n  if (DT < 0.2) score = Math.min(score, 0.4);\n  if (!hasAttribute) score = Math.min(score, 0.7);\n\n  const flags: string[] = [];\n  if (resultCount > 1 && scoreGap < 0.15) flags.push('disambiguation_needed');\n  if (resultCount < 3 && MQ < 0.6) flags.push('sparse_results');\n  if (!hasAttribute) flags.push('attribute_unknown');\n  if (MQ > 0.95 && DT > 0.8 && hasAttribute) flags.push('perfect_match');\n\n  const level = getConfidenceLevel(score);\n\n  return { score, level, breakdown: { mq: MQ, dt: DT, cm: CM }, flags };\n}\n\n/**\n * Gets confidence level from score.\n */\nexport function getConfidenceLevel(score: number): ConfidenceLevel {\n  if (score >= CONFIDENCE_THRESHOLDS.retrieval.high) return 'HIGH';\n  if (score >= CONFIDENCE_THRESHOLDS.retrieval.medium) return 'MEDIUM';\n  return 'LOW';\n}\n\n/**\n * Detects contradiction between new and existing information.\n */\nexport function detectContradiction(\n  similarity: number,\n  logicalConflict: number,\n  daysSinceExisting: number\n): ContradictionResult {\n  const supersessionLikelihood = daysSinceExisting > 90 ? 0.3 : 0;\n\n  const score = Math.max(0, Math.min(1,\n    similarity * 0.4 + logicalConflict * 0.5 - supersessionLikelihood\n  ));\n\n  if (score >= CONFIDENCE_THRESHOLDS.contradiction.definite) {\n    return {\n      level: 'definite',\n      score,\n      action: 'flag_user',\n      explanation: `High conflict detected (${(score * 100).toFixed(0)}%): new info may contradict existing knowledge`,\n    };\n  }\n\n  if (score >= CONFIDENCE_THRESHOLDS.contradiction.possible) {\n    return {\n      level: 'possible',\n      score,\n      action: 'note_internal',\n      explanation: `Moderate conflict (${(score * 100).toFixed(0)}%): noted for potential review`,\n    };\n  }\n\n  return {\n    level: 'none',\n    score,\n    action: 'safe_to_store',\n    explanation: 'No significant conflict detected',\n  };\n}\n\n// ============================================================\n// ADAPTIVE LIMIT FUNCTIONS\n// ============================================================\n\n/**\n * Calculates adaptive limits based on graph characteristics.\n */\nexport function calculateAdaptiveLimits(\n  graphSize: number,\n  graphDensity: number,\n  queryType: QueryType\n): AdaptiveLimits {\n  if (graphSize < COLD_START_THRESHOLD) {\n    return {\n      ...COLD_START_LIMITS,\n      max_nodes: Math.min(COLD_START_LIMITS.max_nodes, Math.ceil(graphSize * 0.5)),\n    };\n  }\n\n  const entryPoints = Math.max(2, Math.min(5, Math.ceil(Math.log10(graphSize))));\n\n  let maxHops: number;\n  if (graphDensity < 0.001) maxHops = 5;\n  else if (graphDensity < 0.01) maxHops = 4;\n  else if (graphDensity < 0.05) maxHops = 3;\n  else maxHops = 2;\n\n  const percentageMap: Record<QueryType, number> = {\n    simple: 0.02,\n    standard: 0.05,\n    complex: 0.10,\n  };\n  const percentage = percentageMap[queryType];\n\n  const budgetKey = `${queryType}_query`;\n  const budgetLookup = OPERATION_BUDGETS[budgetKey];\n  const budget = budgetLookup ?? OPERATION_BUDGETS['standard_query']!;\n\n  const maxNodes = Math.max(\n    50,\n    Math.min(Math.ceil(graphSize * percentage), budget.max_nodes)\n  );\n\n  return { entry_points: entryPoints, max_hops: maxHops, max_nodes: maxNodes };\n}\n\n/**\n * Calculates quality score from components.\n */\nexport function calculateQualityScore(\n  coverage: number,\n  matchQuality: number,\n  convergence: number\n): number {\n  return (\n    coverage * QUALITY_WEIGHTS.coverage +\n    matchQuality * QUALITY_WEIGHTS.match_quality +\n    convergence * QUALITY_WEIGHTS.convergence\n  );\n}\n\n/**\n * Determines if search should terminate.\n */\nexport function shouldTerminate(\n  currentQuality: number,\n  targetQuality: number,\n  convergence: number,\n  lowConvergenceSteps: number,\n  remainingBudget: BudgetConfig\n): TerminationResult {\n  if (currentQuality >= targetQuality) {\n    return { terminate: true, reason: 'quality_target_met' };\n  }\n  if (convergence < 0.02 && lowConvergenceSteps >= 2) {\n    return { terminate: true, reason: 'converged' };\n  }\n  if (remainingBudget.time_ms <= 0) {\n    return { terminate: true, reason: 'time_exhausted' };\n  }\n  if (remainingBudget.max_nodes <= 0) {\n    return { terminate: true, reason: 'node_limit_reached' };\n  }\n  return { terminate: false, reason: '' };\n}\n\n/**\n * Gets budget for an operation.\n */\nexport function getBudgetForOperation(operation: string): BudgetConfig {\n  const budget = OPERATION_BUDGETS[operation];\n  return budget ?? OPERATION_BUDGETS['standard_query']!;\n}\n\n/**\n * Gets quality target for a query type.\n */\nexport function getQualityTargetForQueryType(queryType: string): QualityTarget {\n  const target = QUALITY_TARGETS[queryType];\n  return target ?? QUALITY_TARGETS['REASONING']!;\n}\n\n// ============================================================\n// BM25 FUNCTIONS\n// ============================================================\n\n/**\n * Gets effective stopwords set.\n */\nexport function getEffectiveStopwords(config: StopwordsConfig = STOPWORDS_CONFIG): Set<string> {\n  return new Set([...config.default_list, ...config.custom_additions]);\n}\n\n/**\n * Removes stopwords from tokens.\n */\nexport function removeStopwords(tokens: string[], stopwords: Set<string>): string[] {\n  return tokens.filter(token => !stopwords.has(token.toLowerCase()));\n}\n\n/**\n * Determines if a term should be indexed.\n */\nexport function shouldIndexTerm(\n  term: string,\n  docFrequency: number,\n  totalDocs: number,\n  config: BM25Config = BM25_CONFIG\n): boolean {\n  if (term.length < config.min_term_length) return false;\n  if (term.length > config.max_term_length) return false;\n  if (docFrequency < 1) return false;\n  if (totalDocs === 0) return docFrequency >= 1;\n  const frequencyRatio = docFrequency / totalDocs;\n  if (frequencyRatio > config.max_doc_frequency_ratio) return false;\n  return true;\n}\n\n/**\n * Gets field boost for a field type.\n */\nexport function getFieldBoost(field: FieldType): number {\n  const boost = FIELD_BOOSTS.find(fb => fb.field === field);\n  return boost?.boost ?? 1.0;\n}\n\n// ============================================================\n// VALIDATION FUNCTIONS\n// ============================================================\n\nexport function validateRerankingWeights(weights: unknown): weights is RerankingWeights {\n  return RerankingWeightsSchema.safeParse(weights).success;\n}\n\nexport function validateRerankingConfig(config: unknown): config is RerankingConfig {\n  return RerankingConfigSchema.safeParse(config).success;\n}\n\nexport function validateDecayConfig(config: unknown): config is DecayConfig {\n  return DecayConfigSchema.safeParse(config).success;\n}\n\nexport function validateSSAParams(params: unknown): params is SSAParams {\n  return SSAParamsSchema.safeParse(params).success;\n}\n\nexport function validateSSAEdgeWeights(weights: unknown): weights is SSAEdgeWeights {\n  return SSAEdgeWeightsSchema.safeParse(weights).success;\n}\n\nexport function validateConfidenceThresholds(thresholds: unknown): thresholds is ConfidenceThresholds {\n  return ConfidenceThresholdsSchema.safeParse(thresholds).success;\n}\n\nexport function validateBudgetConfig(config: unknown): config is BudgetConfig {\n  return BudgetConfigSchema.safeParse(config).success;\n}\n\nexport function validateAdaptiveLimits(limits: unknown): limits is AdaptiveLimits {\n  return AdaptiveLimitsSchema.safeParse(limits).success;\n}\n\nexport function validateBM25Config(config: unknown): config is BM25Config {\n  return BM25ConfigSchema.safeParse(config).success;\n}\n\nexport function validateQualityTarget(target: unknown): target is QualityTarget {\n  return QualityTargetSchema.safeParse(target).success;\n}\n\nexport function validateGraphMetrics(metrics: unknown): metrics is GraphMetrics {\n  return GraphMetricsSchema.safeParse(metrics).success;\n}\n","/**\n * @module @nous/core/embeddings\n * @description Contextual Embedding Ecosystem (CEE) - semantic representation for Nous\n * @version 1.0.0\n * @spec Brainstorms/Specs/Phase-2-Data-Representation/storm-016\n *\n * This module implements:\n * - NodeEmbedding interface (expands storm-011 EmbeddingField)\n * - Context prefix generation for all node types\n * - Hybrid search configuration (Dense + BM25)\n * - Matryoshka staged search support\n * - Provider fallback chain\n * - Similarity-based edge creation\n *\n * Core principle: \"Context in, context out.\"\n * Every embedding carries its origins - where information came from,\n * what it relates to, when it happened.\n */\n\nimport { z } from 'zod';\n\n// ============================================================\n// CONSTANTS\n// ============================================================\n\n/**\n * Full embedding vector dimensions (OpenAI text-embedding-3-small)\n */\nexport const EMBEDDING_DIMENSIONS = 1536;\n\n/**\n * Matryoshka truncation dimensions for staged search\n */\nexport const MATRYOSHKA_DIMS = [128, 512, 1536] as const;\n\n/**\n * Dimension used for fast similarity comparisons\n */\nexport const COMPARISON_DIMS = 512;\n\n/**\n * Weight for dense (vector) search in hybrid retrieval\n */\nexport const DENSE_WEIGHT = 0.7;\n\n/**\n * Weight for BM25 (keyword) search in hybrid retrieval\n */\nexport const BM25_WEIGHT = 0.3;\n\n/**\n * Minimum cosine similarity for automatic 'similar_to' edge creation\n */\nexport const SIMILARITY_EDGE_THRESHOLD = 0.90;\n\n/**\n * Cosine similarity threshold triggering deduplication check\n */\nexport const DEDUP_CHECK_THRESHOLD = 0.95;\n\n/**\n * Minimum similarity for SSA seeding\n */\nexport const SSA_SEED_THRESHOLD = 0.60;\n\n/**\n * Threshold for removing stale similarity edges\n */\nexport const STALE_EDGE_THRESHOLD = 0.80;\n\n/**\n * Minimum content length before context expansion\n */\nexport const MIN_CONTENT_LENGTH = 10;\n\n/**\n * Minimum total length (content + prefix) for embedding\n */\nexport const MIN_TOTAL_LENGTH = 50;\n\n/**\n * Stage 1 (coarse): Candidates from HNSW search\n */\nexport const STAGE_1_CANDIDATES = 200;\n\n/**\n * Stage 2 (medium): Candidates after rerank\n */\nexport const STAGE_2_CANDIDATES = 50;\n\n/**\n * Stage 3 (fine): Final candidates\n */\nexport const STAGE_3_CANDIDATES = 30;\n\n/**\n * Primary embedding model\n */\nexport const PRIMARY_MODEL = 'openai-3-small' as const;\n\n/**\n * Fallback 1: Voyage AI\n */\nexport const FALLBACK_1_MODEL = 'voyage-3-lite' as const;\n\n/**\n * Fallback 2: Local MiniLM\n */\nexport const FALLBACK_2_MODEL = 'minilm-v6' as const;\n\n/**\n * All supported embedding models\n */\nexport const EMBEDDING_MODELS = [\n  PRIMARY_MODEL,\n  FALLBACK_1_MODEL,\n  FALLBACK_2_MODEL,\n] as const;\n\n/**\n * Number of recent nodes to compare against for similarity edges\n */\nexport const RECENT_NODE_WINDOW = 100;\n\n/**\n * Retry delay between provider attempts (ms)\n */\nexport const FALLBACK_RETRY_DELAY_MS = 1000;\n\n/**\n * Max retries per provider\n */\nexport const FALLBACK_MAX_RETRIES = 2;\n\n/**\n * BM25 field weights\n */\nexport const BM25_FIELD_WEIGHTS = {\n  title: 2.0,\n  body: 1.0,\n  summary: 1.5,\n  tags: 1.5,\n} as const;\n\n// ============================================================\n// TYPES\n// ============================================================\n\nexport type EmbeddingModelId = (typeof EMBEDDING_MODELS)[number] | string;\nexport type MatryoshkaDim = (typeof MATRYOSHKA_DIMS)[number];\n\n/**\n * Embedding structure attached to each node\n * Extends storm-011's EmbeddingField placeholder\n */\nexport interface NodeEmbedding {\n  /** The embedding vector (Float32Array) */\n  vector: Float32Array;\n  /** Number of dimensions in the vector */\n  dimensions: number;\n  /** Model identifier that generated this embedding */\n  model: EmbeddingModelId;\n  /** Full context prefix prepended to content */\n  contextPrefix: string;\n  /** Hash of context prefix for change detection */\n  contextHash: string;\n  /** ISO 8601 timestamp when embedding was created */\n  createdAt: string;\n  /** True if embedding was created using a fallback model */\n  provisional: boolean;\n  /** Version counter, incremented on each re-embedding */\n  version: number;\n}\n\n/**\n * Context prefix template identifiers\n */\nexport type ContextPrefixTemplate =\n  | 'concept_extracted'\n  | 'concept_manual'\n  | 'episode'\n  | 'document_chunk'\n  | 'section'\n  | 'note'\n  | 'raw_archive'\n  | 'query';\n\n/**\n * Generated context prefix with metadata\n */\nexport interface ContextPrefix {\n  template: ContextPrefixTemplate;\n  generated: string;\n  hash: string;\n}\n\n/**\n * Hybrid search configuration\n */\nexport interface HybridSearchConfig {\n  denseWeight: number;\n  bm25Weight: number;\n  userTunable: boolean;\n}\n\n/**\n * Individual search result with component scores\n */\nexport interface HybridSearchResult {\n  nodeId: string;\n  denseScore: number;\n  bm25Score: number;\n  fusedScore: number;\n}\n\n/**\n * Matryoshka stage configuration\n */\nexport interface MatryoshkaStageConfig {\n  stage: 1 | 2 | 3;\n  dimensions: 128 | 512 | 1536;\n  candidates: number;\n  estimatedLatencyMs: number;\n}\n\n/**\n * Search filters\n */\nexport interface SearchFilters {\n  timeRange?: { start: string; end: string };\n  nodeTypes?: string[];\n  clusterIds?: string[];\n  excludeNodeIds?: string[];\n}\n\n/**\n * Result of processing a query\n */\nexport interface QueryEmbeddingResult {\n  dense: Float32Array;\n  bm25Terms: string[];\n  timeFilter?: { start: string; end: string; confidence: number };\n  typeFilter?: string[];\n  isPurelyTemporal: boolean;\n}\n\n/**\n * Query analysis result\n */\nexport interface QueryAnalysis {\n  hasTimeReference: boolean;\n  hasSemanticContent: boolean;\n  expectedTypes: string[];\n  semanticPart: string;\n  originalQuery: string;\n}\n\n/**\n * Similarity check result\n */\nexport interface SimilarityCheckResult {\n  shouldCreateEdge: boolean;\n  shouldCheckDedup: boolean;\n  similarity: number;\n  targetNodeId: string;\n}\n\n/**\n * Fallback levels\n */\nexport type FallbackLevel = 'primary' | 'secondary' | 'local' | 'degraded';\n\n/**\n * Provider health status\n */\nexport interface ProviderHealth {\n  isAvailable: boolean;\n  lastSuccessAt?: string;\n  lastFailureAt?: string;\n  lastError?: string;\n  consecutiveFailures: number;\n}\n\n/**\n * Fallback configuration\n */\nexport interface FallbackConfig {\n  chain: EmbeddingModelId[];\n  retryDelayMs: number;\n  maxRetries: number;\n  autoReEmbed: boolean;\n}\n\n/**\n * Fallback state\n */\nexport interface FallbackState {\n  currentLevel: FallbackLevel;\n  lastError?: string;\n  recoveryAttempts: number;\n  degradedSince?: string;\n  providerHealth: Record<string, ProviderHealth>;\n}\n\n/**\n * Embedding result\n */\nexport interface EmbedResult {\n  embedding: NodeEmbedding | null;\n  fallbackLevel: FallbackLevel;\n  modelUsed?: EmbeddingModelId;\n  error?: string;\n  latencyMs: number;\n  isProvisional: boolean;\n}\n\n/**\n * Context generator input\n */\nexport interface ContextGeneratorInput {\n  nodeType: string;\n  nodeSubtype?: string;\n  title: string;\n  sourceEpisode?: { title: string; subtype: string };\n  clusterInfo?: { name: string; description?: string; keywords?: string[] };\n  chunkInfo?: { index: number; total: number; sectionTitle?: string; parentTitle: string };\n  eventTimestamp?: string;\n  durationMinutes?: number;\n  participants?: string[];\n  contentType?: string;\n  sourceType?: 'extraction' | 'manual' | 'inference' | 'import';\n}\n\n/**\n * Similarity edge configuration\n */\nexport interface SimilarityEdgeConfig {\n  edgeThreshold: number;\n  dedupThreshold: number;\n  staleThreshold: number;\n  recentNodeWindow: number;\n  comparisonDims: number;\n}\n\n/**\n * Provider configuration\n */\nexport interface EmbeddingProviderConfig {\n  id: EmbeddingModelId;\n  name: string;\n  apiEndpoint: string;\n  modelName: string;\n  dimensions: number;\n  supportsMatryoshka: boolean;\n  costPer1MTokens: number;\n  maxTokens: number;\n  isLocal: boolean;\n}\n\n// ============================================================\n// ZOD SCHEMAS\n// ============================================================\n\nexport const NodeEmbeddingSchema = z.object({\n  vector: z.instanceof(Float32Array),\n  dimensions: z.number().int().positive().max(EMBEDDING_DIMENSIONS),\n  model: z.string().min(1),\n  contextPrefix: z.string(),\n  contextHash: z.string().min(1),\n  createdAt: z.string().datetime(),\n  provisional: z.boolean(),\n  version: z.number().int().nonnegative(),\n});\n\nexport const ContextPrefixSchema = z.object({\n  template: z.enum([\n    'concept_extracted',\n    'concept_manual',\n    'episode',\n    'document_chunk',\n    'section',\n    'note',\n    'raw_archive',\n    'query',\n  ]),\n  generated: z.string(),\n  hash: z.string(),\n});\n\nexport const HybridSearchConfigSchema = z.object({\n  denseWeight: z.number().min(0).max(1),\n  bm25Weight: z.number().min(0).max(1),\n  userTunable: z.boolean(),\n}).refine(\n  (data) => Math.abs(data.denseWeight + data.bm25Weight - 1) < 0.001,\n  { message: 'Weights must sum to 1.0' }\n);\n\nexport const HybridSearchResultSchema = z.object({\n  nodeId: z.string(),\n  denseScore: z.number().min(0).max(1),\n  bm25Score: z.number().min(0).max(1),\n  fusedScore: z.number().min(0).max(1),\n});\n\nexport const SearchFiltersSchema = z.object({\n  timeRange: z.object({\n    start: z.string().datetime(),\n    end: z.string().datetime(),\n  }).optional(),\n  nodeTypes: z.array(z.string()).optional(),\n  clusterIds: z.array(z.string()).optional(),\n  excludeNodeIds: z.array(z.string()).optional(),\n});\n\nexport const QueryAnalysisSchema = z.object({\n  hasTimeReference: z.boolean(),\n  hasSemanticContent: z.boolean(),\n  expectedTypes: z.array(z.string()),\n  semanticPart: z.string(),\n  originalQuery: z.string(),\n});\n\nexport const SimilarityCheckResultSchema = z.object({\n  shouldCreateEdge: z.boolean(),\n  shouldCheckDedup: z.boolean(),\n  similarity: z.number().min(-1).max(1),\n  targetNodeId: z.string(),\n});\n\nexport const FallbackLevelSchema = z.enum(['primary', 'secondary', 'local', 'degraded']);\n\nexport const FallbackConfigSchema = z.object({\n  chain: z.array(z.string()),\n  retryDelayMs: z.number().int().positive(),\n  maxRetries: z.number().int().nonnegative(),\n  autoReEmbed: z.boolean(),\n});\n\nexport const ProviderHealthSchema = z.object({\n  isAvailable: z.boolean(),\n  lastSuccessAt: z.string().datetime().optional(),\n  lastFailureAt: z.string().datetime().optional(),\n  lastError: z.string().optional(),\n  consecutiveFailures: z.number().int().nonnegative(),\n});\n\n// ============================================================\n// DEFAULT CONFIGURATIONS\n// ============================================================\n\nexport const DEFAULT_HYBRID_CONFIG: HybridSearchConfig = {\n  denseWeight: DENSE_WEIGHT,\n  bm25Weight: BM25_WEIGHT,\n  userTunable: true,\n};\n\nexport const DEFAULT_MATRYOSHKA_CONFIG = {\n  stages: [\n    { stage: 1 as const, dimensions: 128 as const, candidates: STAGE_1_CANDIDATES, estimatedLatencyMs: 3 },\n    { stage: 2 as const, dimensions: 512 as const, candidates: STAGE_2_CANDIDATES, estimatedLatencyMs: 5 },\n    { stage: 3 as const, dimensions: 1536 as const, candidates: STAGE_3_CANDIDATES, estimatedLatencyMs: 7 },\n  ],\n  totalEstimatedLatencyMs: 15,\n};\n\nexport const DEFAULT_SIMILARITY_CONFIG: SimilarityEdgeConfig = {\n  edgeThreshold: SIMILARITY_EDGE_THRESHOLD,\n  dedupThreshold: DEDUP_CHECK_THRESHOLD,\n  staleThreshold: STALE_EDGE_THRESHOLD,\n  recentNodeWindow: RECENT_NODE_WINDOW,\n  comparisonDims: COMPARISON_DIMS,\n};\n\nexport const DEFAULT_FALLBACK_CONFIG: FallbackConfig = {\n  chain: [PRIMARY_MODEL, FALLBACK_1_MODEL, FALLBACK_2_MODEL],\n  retryDelayMs: FALLBACK_RETRY_DELAY_MS,\n  maxRetries: FALLBACK_MAX_RETRIES,\n  autoReEmbed: true,\n};\n\nexport const INITIAL_PROVIDER_HEALTH: ProviderHealth = {\n  isAvailable: true,\n  consecutiveFailures: 0,\n};\n\n/**\n * Context template definitions\n */\nexport const CONTEXT_TEMPLATES: Record<ContextPrefixTemplate, string> = {\n  concept_extracted: '[{subtype}] From {source} ({source_type}). {cluster}.',\n  concept_manual: '[{subtype}] Created by user. {cluster}.',\n  episode: '[{subtype}] {date}, {duration}min. {participants}.',\n  document_chunk: '[Chunk {index}/{total}] {parent}. Section: {section}.',\n  section: '[Section] {parent}. {title}.',\n  note: '[note] {cluster}. {title}.',\n  raw_archive: '[archive: {content_type}] {title}.',\n  query: '[Query] ',\n};\n\n/**\n * Time reference patterns for detection\n */\nexport const TIME_REFERENCE_PATTERNS = [\n  /\\b(yesterday|today|tomorrow)\\b/i,\n  /\\b(last|this|next)\\s+(week|month|year|monday|tuesday|wednesday|thursday|friday|saturday|sunday)\\b/i,\n  /\\b(in|during|on|at)\\s+\\d{4}\\b/i,\n  /\\b\\d{1,2}[\\/\\-]\\d{1,2}[\\/\\-]\\d{2,4}\\b/,\n  /\\b(january|february|march|april|may|june|july|august|september|october|november|december)\\s+\\d{1,2}/i,\n  /\\b\\d+\\s+(days?|weeks?|months?|years?)\\s+ago\\b/i,\n];\n\n/**\n * Generic words to filter from semantic queries\n */\nexport const GENERIC_WORDS = [\n  'what', 'when', 'where', 'who', 'how', 'why',\n  'happened', 'did', 'was', 'is', 'are', 'were',\n  'tell', 'me', 'about', 'show', 'find', 'get',\n  'the', 'a', 'an', 'this', 'that', 'it',\n];\n\n// ============================================================\n// HASH FUNCTION\n// ============================================================\n\n/**\n * Compute a hash of the context prefix for change detection.\n * Simple but effective hash for fast comparison.\n */\nexport function hashContext(contextPrefix: string): string {\n  let hash = 0;\n  for (let i = 0; i < contextPrefix.length; i++) {\n    const char = contextPrefix.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  return Math.abs(hash).toString(16).padStart(8, '0');\n}\n\n// ============================================================\n// NODE EMBEDDING FUNCTIONS\n// ============================================================\n\n/**\n * Create a new node embedding\n */\nexport function createNodeEmbedding(\n  vector: Float32Array,\n  model: EmbeddingModelId,\n  contextPrefix: string,\n  provisional = false\n): NodeEmbedding {\n  return {\n    vector,\n    dimensions: vector.length,\n    model,\n    contextPrefix,\n    contextHash: hashContext(contextPrefix),\n    createdAt: new Date().toISOString(),\n    provisional,\n    version: 1,\n  };\n}\n\n/**\n * Check if an embedding is provisional\n */\nexport function isProvisional(embedding: NodeEmbedding): boolean {\n  return embedding.provisional;\n}\n\n/**\n * Check if an embedding needs re-embedding due to context changes\n */\nexport function needsReEmbedding(\n  embedding: NodeEmbedding,\n  currentContextHash: string\n): boolean {\n  return embedding.contextHash !== currentContextHash;\n}\n\n/**\n * Check if an embedding uses the primary model\n */\nexport function isPrimaryModel(embedding: NodeEmbedding): boolean {\n  return embedding.model === PRIMARY_MODEL;\n}\n\n/**\n * Update an embedding (increments version)\n */\nexport function updateEmbedding(\n  previous: NodeEmbedding,\n  vector: Float32Array,\n  model: EmbeddingModelId,\n  contextPrefix: string,\n  provisional = false\n): NodeEmbedding {\n  return {\n    ...createNodeEmbedding(vector, model, contextPrefix, provisional),\n    version: previous.version + 1,\n  };\n}\n\n/**\n * Truncate embedding vector to Matryoshka dimension\n */\nexport function truncateToMatryoshka(\n  embedding: NodeEmbedding,\n  dims: 128 | 512 | 1536\n): Float32Array {\n  if (dims >= embedding.dimensions) {\n    return embedding.vector;\n  }\n  return embedding.vector.slice(0, dims);\n}\n\n/**\n * Get dimensions for a model\n */\nexport function getModelDimensions(model: EmbeddingModelId): number {\n  switch (model) {\n    case 'openai-3-small':\n      return 1536;\n    case 'voyage-3-lite':\n      return 512;\n    case 'minilm-v6':\n      return 384;\n    default:\n      return EMBEDDING_DIMENSIONS;\n  }\n}\n\n// ============================================================\n// CONTEXT PREFIX FUNCTIONS\n// ============================================================\n\n/**\n * Select the appropriate template for a node\n */\nexport function selectTemplate(\n  nodeType: string,\n  sourceType?: 'extraction' | 'manual' | 'inference' | 'import'\n): ContextPrefixTemplate {\n  switch (nodeType) {\n    case 'concept':\n      return sourceType === 'extraction' ? 'concept_extracted' : 'concept_manual';\n    case 'episode':\n      return 'episode';\n    case 'chunk':\n      return 'document_chunk';\n    case 'section':\n      return 'section';\n    case 'note':\n      return 'note';\n    case 'raw':\n    case 'document':\n      return 'raw_archive';\n    default:\n      return 'concept_manual';\n  }\n}\n\n/**\n * Format a date for context prefix\n */\nexport function formatContextDate(timestamp: string): string {\n  const date = new Date(timestamp);\n  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',\n                  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n  return `${months[date.getMonth()]} ${date.getDate()} ${date.getFullYear()}`;\n}\n\n/**\n * Generate context prefix for a node\n */\nexport function generateContextPrefix(input: ContextGeneratorInput): ContextPrefix {\n  const template = selectTemplate(input.nodeType, input.sourceType);\n  let generated = CONTEXT_TEMPLATES[template];\n\n  // Replace placeholders\n  generated = generated.replace('{subtype}', input.nodeSubtype || input.nodeType);\n  generated = generated.replace('{source}', input.sourceEpisode?.title || '');\n  generated = generated.replace('{source_type}', input.sourceEpisode?.subtype || '');\n  generated = generated.replace('{cluster}', input.clusterInfo?.name || '');\n  generated = generated.replace('{date}', input.eventTimestamp\n    ? formatContextDate(input.eventTimestamp)\n    : '');\n  generated = generated.replace('{duration}', String(input.durationMinutes || 0));\n  generated = generated.replace('{participants}', input.participants?.join(', ') || '');\n  generated = generated.replace('{index}', String(input.chunkInfo?.index || 0));\n  generated = generated.replace('{total}', String(input.chunkInfo?.total || 0));\n  generated = generated.replace('{parent}', input.chunkInfo?.parentTitle || '');\n  generated = generated.replace('{section}', input.chunkInfo?.sectionTitle || 'Main');\n  generated = generated.replace('{content_type}', input.contentType || 'unknown');\n  generated = generated.replace('{title}', input.title);\n\n  // Clean up empty segments\n  generated = generated.replace(/\\(\\)\\.?/g, '');\n  generated = generated.replace(/\\s+/g, ' ');\n  generated = generated.trim();\n\n  return {\n    template,\n    generated,\n    hash: hashContext(generated),\n  };\n}\n\n/**\n * Expand short content with additional context\n */\nexport function expandMinimumContext(\n  content: string,\n  prefix: string,\n  clusterInfo?: { name: string; description?: string; keywords?: string[] }\n): string {\n  let expandedPrefix = prefix;\n\n  if (content.length < MIN_CONTENT_LENGTH && clusterInfo?.description) {\n    expandedPrefix += ` Topic: ${clusterInfo.description}.`;\n  }\n\n  if (\n    (content.length + expandedPrefix.length) < MIN_TOTAL_LENGTH &&\n    clusterInfo?.keywords?.length\n  ) {\n    const keywords = clusterInfo.keywords.slice(0, 5).join(', ');\n    expandedPrefix += ` Keywords: ${keywords}.`;\n  }\n\n  return expandedPrefix;\n}\n\n/**\n * Generate query prefix\n */\nexport function generateQueryPrefix(semanticContent: string): ContextPrefix {\n  const generated = `[Query] ${semanticContent}`;\n  return {\n    template: 'query',\n    generated,\n    hash: hashContext(generated),\n  };\n}\n\n/**\n * Combine prefix and content for embedding\n */\nexport function combineForEmbedding(\n  prefix: string,\n  content: string,\n  clusterInfo?: { name: string; description?: string; keywords?: string[] }\n): string {\n  const expandedPrefix = expandMinimumContext(content, prefix, clusterInfo);\n  return `${expandedPrefix} ${content}`.trim();\n}\n\n// ============================================================\n// HYBRID SEARCH FUNCTIONS\n// ============================================================\n\n/**\n * Get default hybrid search configuration\n */\nexport function getDefaultHybridConfig(): HybridSearchConfig {\n  return { ...DEFAULT_HYBRID_CONFIG };\n}\n\n/**\n * Fuse dense and BM25 scores\n */\nexport function fuseScores(\n  denseScore: number,\n  bm25Score: number,\n  config: HybridSearchConfig = DEFAULT_HYBRID_CONFIG\n): number {\n  return (denseScore * config.denseWeight) + (bm25Score * config.bm25Weight);\n}\n\n/**\n * Normalize scores to 0-1 range\n */\nexport function normalizeScores(\n  results: HybridSearchResult[]\n): HybridSearchResult[] {\n  if (results.length === 0) return [];\n\n  const denseScores = results.map((r) => r.denseScore);\n  const bm25Scores = results.map((r) => r.bm25Score);\n\n  const denseMin = Math.min(...denseScores);\n  const denseMax = Math.max(...denseScores);\n  const bm25Min = Math.min(...bm25Scores);\n  const bm25Max = Math.max(...bm25Scores);\n\n  const denseRange = denseMax - denseMin || 1;\n  const bm25Range = bm25Max - bm25Min || 1;\n\n  return results.map((result) => ({\n    ...result,\n    denseScore: (result.denseScore - denseMin) / denseRange,\n    bm25Score: (result.bm25Score - bm25Min) / bm25Range,\n  }));\n}\n\n/**\n * Create a search result\n */\nexport function createSearchResult(\n  nodeId: string,\n  denseScore: number,\n  bm25Score: number,\n  config: HybridSearchConfig = DEFAULT_HYBRID_CONFIG\n): HybridSearchResult {\n  return {\n    nodeId,\n    denseScore,\n    bm25Score,\n    fusedScore: fuseScores(denseScore, bm25Score, config),\n  };\n}\n\n/**\n * Sort results by fused score descending\n */\nexport function sortByFusedScore(\n  results: HybridSearchResult[]\n): HybridSearchResult[] {\n  return [...results].sort((a, b) => b.fusedScore - a.fusedScore);\n}\n\n/**\n * Take top k results\n */\nexport function takeTopK(\n  results: HybridSearchResult[],\n  k: number\n): HybridSearchResult[] {\n  return sortByFusedScore(results).slice(0, k);\n}\n\n/**\n * Validate hybrid config\n */\nexport function validateHybridConfig(config: HybridSearchConfig): boolean {\n  return Math.abs(config.denseWeight + config.bm25Weight - 1) < 0.001;\n}\n\n// ============================================================\n// QUERY PROCESSING FUNCTIONS\n// ============================================================\n\n/**\n * Detect if a query contains time references\n */\nexport function detectTimeReference(query: string): boolean {\n  return TIME_REFERENCE_PATTERNS.some((pattern) => pattern.test(query));\n}\n\n/**\n * Remove time references from query\n */\nexport function removeTimeReferences(query: string): string {\n  let result = query;\n  for (const pattern of TIME_REFERENCE_PATTERNS) {\n    result = result.replace(pattern, '');\n  }\n  return result.replace(/\\s+/g, ' ').trim();\n}\n\n/**\n * Remove generic words from query\n */\nexport function removeGenericWords(query: string): string {\n  const words = query.toLowerCase().split(/\\s+/);\n  const filtered = words.filter((word) => !GENERIC_WORDS.includes(word));\n  return filtered.join(' ');\n}\n\n/**\n * Infer expected node types from query\n */\nexport function inferExpectedTypes(query: string): string[] {\n  const types: string[] = [];\n  const lower = query.toLowerCase();\n\n  if (lower.includes('lecture') || lower.includes('class') || lower.includes('meeting')) {\n    types.push('episode');\n  }\n  if (lower.includes('concept') || lower.includes('idea') || lower.includes('fact')) {\n    types.push('concept');\n  }\n  if (lower.includes('note') || lower.includes('wrote')) {\n    types.push('note');\n  }\n  if (lower.includes('document') || lower.includes('file') || lower.includes('pdf')) {\n    types.push('document', 'chunk');\n  }\n\n  if (types.length === 0) {\n    types.push('concept', 'episode', 'note');\n  }\n\n  return types;\n}\n\n/**\n * Analyze a raw query\n */\nexport function analyzeQuery(rawQuery: string): QueryAnalysis {\n  const hasTimeReference = detectTimeReference(rawQuery);\n  const semanticPart = hasTimeReference\n    ? removeTimeReferences(rawQuery)\n    : rawQuery;\n  const cleanedSemantic = removeGenericWords(semanticPart);\n  const hasSemanticContent = cleanedSemantic.length >= 3;\n\n  return {\n    hasTimeReference,\n    hasSemanticContent,\n    expectedTypes: inferExpectedTypes(rawQuery),\n    semanticPart: cleanedSemantic,\n    originalQuery: rawQuery,\n  };\n}\n\n/**\n * Determine if query should skip embedding\n */\nexport function shouldSkipEmbedding(analysis: QueryAnalysis): boolean {\n  return analysis.hasTimeReference && !analysis.hasSemanticContent;\n}\n\n/**\n * Tokenize text for BM25 search\n */\nexport function tokenizeForBM25(text: string): string[] {\n  const normalized = text.toLowerCase();\n  const tokens = normalized\n    .split(/[\\s\\-_.,;:!?'\"()\\[\\]{}]+/)\n    .filter((token) => token.length > 1);\n  return tokens;\n}\n\n// ============================================================\n// SIMILARITY FUNCTIONS\n// ============================================================\n\n/**\n * Compute cosine similarity between two vectors\n */\nexport function cosineSimilarity(a: Float32Array, b: Float32Array): number {\n  if (a.length !== b.length) {\n    throw new Error(`Vector length mismatch: ${a.length} vs ${b.length}`);\n  }\n\n  let dotProduct = 0;\n  let normA = 0;\n  let normB = 0;\n\n  for (let i = 0; i < a.length; i++) {\n    dotProduct += a[i]! * b[i]!;\n    normA += a[i]! * a[i]!;\n    normB += b[i]! * b[i]!;\n  }\n\n  const denominator = Math.sqrt(normA) * Math.sqrt(normB);\n  if (denominator === 0) return 0;\n\n  return dotProduct / denominator;\n}\n\n/**\n * Truncate vector for fast comparison\n */\nexport function truncateForComparison(\n  vector: Float32Array,\n  dims: number\n): Float32Array {\n  if (dims >= vector.length) return vector;\n  return vector.slice(0, dims);\n}\n\n/**\n * Check similarity between embeddings\n */\nexport function checkSimilarity(\n  sourceEmbedding: NodeEmbedding,\n  targetEmbedding: NodeEmbedding,\n  targetNodeId: string,\n  config: SimilarityEdgeConfig = DEFAULT_SIMILARITY_CONFIG\n): SimilarityCheckResult {\n  const sourceVec = truncateForComparison(\n    sourceEmbedding.vector,\n    config.comparisonDims\n  );\n  const targetVec = truncateForComparison(\n    targetEmbedding.vector,\n    config.comparisonDims\n  );\n\n  const similarity = cosineSimilarity(sourceVec, targetVec);\n\n  return {\n    shouldCreateEdge: similarity >= config.edgeThreshold,\n    shouldCheckDedup: similarity >= config.dedupThreshold,\n    similarity,\n    targetNodeId,\n  };\n}\n\n/**\n * Check if edge is stale\n */\nexport function isStaleEdge(\n  currentSimilarity: number,\n  config: SimilarityEdgeConfig = DEFAULT_SIMILARITY_CONFIG\n): boolean {\n  return currentSimilarity < config.staleThreshold;\n}\n\n/**\n * Sort results by similarity descending\n */\nexport function sortBySimilarity(\n  results: SimilarityCheckResult[]\n): SimilarityCheckResult[] {\n  return [...results].sort((a, b) => b.similarity - a.similarity);\n}\n\n// ============================================================\n// FALLBACK FUNCTIONS\n// ============================================================\n\n/**\n * Get fallback level for a model\n */\nexport function getFallbackLevel(modelId: EmbeddingModelId): FallbackLevel {\n  switch (modelId) {\n    case PRIMARY_MODEL:\n      return 'primary';\n    case FALLBACK_1_MODEL:\n      return 'secondary';\n    case FALLBACK_2_MODEL:\n      return 'local';\n    default:\n      return 'degraded';\n  }\n}\n\n/**\n * Determine if an error is retryable\n */\nexport function shouldRetry(error: Error, statusCode?: number): boolean {\n  if (statusCode === 429) return true;\n  if (statusCode && statusCode >= 500 && statusCode < 600) return true;\n  if (error.message.includes('ECONNREFUSED')) return true;\n  if (error.message.includes('ETIMEDOUT')) return true;\n  if (error.message.includes('network')) return true;\n  if (statusCode === 401 || statusCode === 403) return false;\n  if (statusCode === 400) return false;\n  return false;\n}\n\n/**\n * Get next provider in fallback chain\n */\nexport function getNextProvider(\n  currentModel: EmbeddingModelId,\n  config: FallbackConfig = DEFAULT_FALLBACK_CONFIG\n): EmbeddingModelId | null {\n  const currentIndex = config.chain.indexOf(currentModel);\n  if (currentIndex === -1 || currentIndex >= config.chain.length - 1) {\n    return null;\n  }\n  return config.chain[currentIndex + 1] ?? null;\n}\n\n/**\n * Create initial fallback state\n */\nexport function createInitialFallbackState(): FallbackState {\n  const providerHealth: Record<string, ProviderHealth> = {};\n  for (const model of EMBEDDING_MODELS) {\n    providerHealth[model] = { ...INITIAL_PROVIDER_HEALTH };\n  }\n\n  return {\n    currentLevel: 'primary',\n    recoveryAttempts: 0,\n    providerHealth,\n  };\n}\n\n/**\n * Record provider success\n */\nexport function recordSuccess(\n  state: FallbackState,\n  provider: EmbeddingModelId\n): FallbackState {\n  const newHealth: ProviderHealth = {\n    ...state.providerHealth[provider],\n    isAvailable: true,\n    lastSuccessAt: new Date().toISOString(),\n    consecutiveFailures: 0,\n  };\n\n  const newLevel = provider === PRIMARY_MODEL ? 'primary' : state.currentLevel;\n\n  return {\n    ...state,\n    currentLevel: newLevel,\n    providerHealth: { ...state.providerHealth, [provider]: newHealth },\n    degradedSince: newLevel === 'primary' ? undefined : state.degradedSince,\n  };\n}\n\n/**\n * Record provider failure\n */\nexport function recordFailure(\n  state: FallbackState,\n  provider: EmbeddingModelId,\n  error: string\n): FallbackState {\n  const currentHealth = state.providerHealth[provider] || INITIAL_PROVIDER_HEALTH;\n  const newHealth: ProviderHealth = {\n    ...currentHealth,\n    isAvailable: false,\n    lastFailureAt: new Date().toISOString(),\n    lastError: error,\n    consecutiveFailures: currentHealth.consecutiveFailures + 1,\n  };\n\n  let newLevel = state.currentLevel;\n  if (provider === PRIMARY_MODEL && state.currentLevel === 'primary') {\n    newLevel = 'secondary';\n  }\n\n  return {\n    ...state,\n    currentLevel: newLevel,\n    lastError: error,\n    providerHealth: { ...state.providerHealth, [provider]: newHealth },\n    degradedSince: state.degradedSince || new Date().toISOString(),\n    recoveryAttempts: state.recoveryAttempts + 1,\n  };\n}\n\n/**\n * Create degraded result (no embedding)\n */\nexport function createDegradedResult(error: string, latencyMs: number): EmbedResult {\n  return {\n    embedding: null,\n    fallbackLevel: 'degraded',\n    error,\n    latencyMs,\n    isProvisional: false,\n  };\n}\n\n/**\n * Create success result\n */\nexport function createSuccessResult(\n  embedding: NodeEmbedding,\n  modelUsed: EmbeddingModelId,\n  latencyMs: number\n): EmbedResult {\n  const level = getFallbackLevel(modelUsed);\n  return {\n    embedding,\n    fallbackLevel: level,\n    modelUsed,\n    latencyMs,\n    isProvisional: level !== 'primary',\n  };\n}\n\n// ============================================================\n// COST ESTIMATION\n// ============================================================\n\n/**\n * Estimate embedding cost\n */\nexport function estimateCost(\n  tokens: number,\n  costPer1M = 0.02\n): { tokens: number; costUsd: number } {\n  return {\n    tokens,\n    costUsd: (tokens / 1_000_000) * costPer1M,\n  };\n}\n\n/**\n * Estimate monthly cost\n */\nexport function estimateMonthlyCost(\n  nodesPerDay: number,\n  queriesPerDay: number,\n  tokensPerNode = 150,\n  tokensPerQuery = 30,\n  costPer1M = 0.02\n): { tokens: number; costUsd: number } {\n  const dailyNodeTokens = nodesPerDay * tokensPerNode;\n  const dailyQueryTokens = queriesPerDay * tokensPerQuery;\n  const monthlyTokens = (dailyNodeTokens + dailyQueryTokens) * 30;\n  return estimateCost(monthlyTokens, costPer1M);\n}\n","/**\n * @module @nous/core/ssa\n * @description Seeded Spreading Activation retrieval algorithm\n * @version 1.0.0\n * @spec Brainstorms/Specs/Phase-3-Retrieval-Core/storm-005\n * @storm Brainstorms/Infrastructure/storm-005-retrieval-algorithm\n *\n * This module implements storm-005: SSA Retrieval Algorithm.\n *\n * Algorithm flow:\n * 0. Parse filters → 1. Embed queries → 2. Hybrid seeding →\n * 3. Spreading activation → 4. Reranking → 5. Build result\n *\n * Key integrations:\n * - storm-016: Embedding thresholds (SSA_SEED_THRESHOLD, DENSE_WEIGHT, BM25_WEIGHT)\n * - storm-028: SSA_PARAMS, SSA_EDGE_WEIGHTS, rerankCandidates()\n */\n\nimport { z } from 'zod';\nimport {\n  SSA_PARAMS,\n  SSA_EDGE_WEIGHTS,\n  rerankCandidates,\n  rerankWithSectionWeights,\n  type ScoredNode,\n  type RankedNode,\n  type GraphMetrics,\n  type ScoreBreakdown,\n} from '../params';\nimport {\n  SSA_SEED_THRESHOLD,\n  DENSE_WEIGHT,\n  BM25_WEIGHT,\n} from '../embeddings';\n\n// ============================================================\n// CONSTANTS\n// ============================================================\n\n/**\n * Serendipity levels for unexpected connection discovery.\n */\nexport const SERENDIPITY_LEVELS = ['off', 'low', 'medium', 'high'] as const;\nexport type SerendipityLevel = (typeof SERENDIPITY_LEVELS)[number];\n\n/**\n * Query combination strategies for multi-query.\n */\nexport const QUERY_COMBINATION_STRATEGIES = ['average', 'max_pooling'] as const;\nexport type QueryCombinationStrategy = (typeof QUERY_COMBINATION_STRATEGIES)[number];\n\n/**\n * Serendipity thresholds per level.\n */\nexport const SERENDIPITY_THRESHOLDS: Record<SerendipityLevel, { minGraph: number; maxSim: number; count: number }> = {\n  off: { minGraph: 1.0, maxSim: 0.0, count: 0 },\n  low: { minGraph: 0.4, maxSim: 0.5, count: 2 },\n  medium: { minGraph: 0.3, maxSim: 0.5, count: 5 },\n  high: { minGraph: 0.2, maxSim: 0.5, count: 10 },\n};\n\n// ============================================================\n// FILTER INTERFACES\n// ============================================================\n\n/**\n * Date range filter.\n */\nexport interface DateRangeFilter {\n  after?: string;\n  before?: string;\n}\n\nexport const DateRangeFilterSchema = z.object({\n  after: z.string().datetime().optional(),\n  before: z.string().datetime().optional(),\n}).refine(\n  (data) => {\n    if (data.after && data.before) {\n      return new Date(data.after) <= new Date(data.before);\n    }\n    return true;\n  },\n  { message: 'after must be before or equal to before' }\n);\n\n/**\n * Last accessed filter.\n */\nexport interface LastAccessedFilter {\n  within_days: number;\n}\n\nexport const LastAccessedFilterSchema = z.object({\n  within_days: z.number().int().positive(),\n});\n\n/**\n * Search filters for SSA.\n */\nexport interface SSASearchFilters {\n  date_range?: DateRangeFilter;\n  last_accessed?: LastAccessedFilter;\n  types?: string[];\n  exclude_types?: string[];\n  clusters?: string[];\n  tags?: string[];\n  tags_any?: string[];\n  exclude_tags?: string[];\n  relationships?: string[];\n  connected_to?: string;\n  within_hops?: number;\n}\n\nexport const SSASearchFiltersSchema = z.object({\n  date_range: DateRangeFilterSchema.optional(),\n  last_accessed: LastAccessedFilterSchema.optional(),\n  types: z.array(z.string().max(100)).max(50).optional(),\n  exclude_types: z.array(z.string().max(100)).max(50).optional(),\n  clusters: z.array(z.string().min(1).max(100)).optional(),\n  tags: z.array(z.string().min(1).max(50)).optional(),\n  tags_any: z.array(z.string().min(1).max(50)).optional(),\n  exclude_tags: z.array(z.string().min(1).max(50)).optional(),\n  relationships: z.array(z.string().max(100)).max(30).optional(),\n  connected_to: z.string().min(1).max(100).optional(),\n  within_hops: z.number().int().min(1).max(10).optional(),\n});\n\n// ============================================================\n// REQUEST/RESPONSE INTERFACES\n// ============================================================\n\n/**\n * Search request for SSA.\n */\nexport interface SearchRequest {\n  query?: string;\n  queries?: string[];\n  filters?: SSASearchFilters;\n  serendipity_level?: SerendipityLevel;\n  query_combination?: QueryCombinationStrategy;\n  limit?: number;\n  include_connections?: boolean;\n}\n\nexport const SearchRequestSchema = z.object({\n  query: z.string().min(1).max(2000).optional(),\n  queries: z.array(z.string().min(1).max(2000)).max(10).optional(),\n  filters: SSASearchFiltersSchema.optional(),\n  serendipity_level: z.enum(SERENDIPITY_LEVELS).optional(),\n  query_combination: z.enum(QUERY_COMBINATION_STRATEGIES).optional(),\n  limit: z.number().int().min(1).max(100).optional(),\n  include_connections: z.boolean().optional(),\n}).refine(\n  (data) => data.query !== undefined || (data.queries !== undefined && data.queries.length > 0),\n  { message: 'Either query or queries must be provided' }\n);\n\n/**\n * Score breakdown for a ranked node.\n */\nexport interface SSAScoreBreakdown {\n  semantic: number;\n  keyword: number;\n  graph: number;\n  recency: number;\n  authority: number;\n  affinity: number;\n}\n\nexport const SSAScoreBreakdownSchema = z.object({\n  semantic: z.number().min(0).max(1),\n  keyword: z.number().min(0).max(1),\n  graph: z.number().min(0).max(1),\n  recency: z.number().min(0).max(1),\n  authority: z.number().min(0).max(1),\n  affinity: z.number().min(0).max(1),\n});\n\n/**\n * Ranking reason explaining why a node was ranked.\n */\nexport interface RankingReason {\n  primary_signal: keyof SSAScoreBreakdown;\n  explanation: string;\n  score_breakdown: SSAScoreBreakdown;\n}\n\nexport const RankingReasonSchema = z.object({\n  primary_signal: z.enum(['semantic', 'keyword', 'graph', 'recency', 'authority', 'affinity']),\n  explanation: z.string(),\n  score_breakdown: SSAScoreBreakdownSchema,\n});\n\n/**\n * Ranked node in search results.\n */\nexport interface SSARankedNode {\n  node_id: string;\n  score: number;\n  ranking_reason: RankingReason;\n}\n\nexport const SSARankedNodeSchema = z.object({\n  node_id: z.string(),\n  score: z.number().min(0).max(1),\n  ranking_reason: RankingReasonSchema,\n});\n\n/**\n * Connection between two nodes.\n */\nexport interface NodeConnection {\n  source_id: string;\n  target_id: string;\n  edge_type: string;\n  weight: number;\n}\n\nexport const NodeConnectionSchema = z.object({\n  source_id: z.string(),\n  target_id: z.string(),\n  edge_type: z.string(),\n  weight: z.number().min(0).max(1),\n});\n\n/**\n * Map of connections between activated nodes.\n */\nexport interface ConnectionMap {\n  connections: NodeConnection[];\n  node_count: number;\n  edge_count: number;\n}\n\nexport const ConnectionMapSchema = z.object({\n  connections: z.array(NodeConnectionSchema),\n  node_count: z.number().int().nonnegative(),\n  edge_count: z.number().int().nonnegative(),\n});\n\n/**\n * Serendipity candidate - unexpected but connected node.\n */\nexport interface SerendipityCandidate {\n  node_id: string;\n  semantic_score: number;\n  graph_score: number;\n  connection_path: string[];\n  explanation: string;\n}\n\nexport const SerendipityCandidateSchema = z.object({\n  node_id: z.string(),\n  semantic_score: z.number().min(0).max(1),\n  graph_score: z.number().min(0).max(1),\n  connection_path: z.array(z.string()),\n  explanation: z.string(),\n});\n\n/**\n * Execution metrics for performance tracking.\n */\nexport interface ExecutionMetrics {\n  total_ms: number;\n  parse_filters_ms: number;\n  embed_queries_ms: number;\n  hybrid_seeding_ms: number;\n  spreading_ms: number;\n  reranking_ms: number;\n  seeds_found: number;\n  nodes_activated: number;\n  nodes_filtered: number;\n  nodes_returned: number;\n}\n\nexport const ExecutionMetricsSchema = z.object({\n  total_ms: z.number().nonnegative(),\n  parse_filters_ms: z.number().nonnegative(),\n  embed_queries_ms: z.number().nonnegative(),\n  hybrid_seeding_ms: z.number().nonnegative(),\n  spreading_ms: z.number().nonnegative(),\n  reranking_ms: z.number().nonnegative(),\n  seeds_found: z.number().int().nonnegative(),\n  nodes_activated: z.number().int().nonnegative(),\n  nodes_filtered: z.number().int().nonnegative(),\n  nodes_returned: z.number().int().nonnegative(),\n});\n\n/**\n * Search response from SSA.\n */\nexport interface SearchResponse {\n  results: SSARankedNode[];\n  filters_applied: SSASearchFilters;\n  total_candidates: number;\n  execution_time_ms: number;\n  metrics: ExecutionMetrics;\n}\n\nexport const SearchResponseSchema = z.object({\n  results: z.array(SSARankedNodeSchema),\n  filters_applied: SSASearchFiltersSchema,\n  total_candidates: z.number().int().nonnegative(),\n  execution_time_ms: z.number().nonnegative(),\n  metrics: ExecutionMetricsSchema,\n});\n\n// ============================================================\n// SSA RESULT (Phase 2 Handoff)\n// ============================================================\n\n/**\n * Complete SSA result for Phase 2 handoff.\n */\nexport interface SSAResult {\n  original_queries: string[];\n  filters_applied: SSASearchFilters;\n  relevant_nodes: SSARankedNode[];\n  connection_map?: ConnectionMap;\n  ranking_reasons: Record<string, RankingReason>;\n  serendipity_candidates?: SerendipityCandidate[];\n  metrics: ExecutionMetrics;\n}\n\nexport const SSAResultSchema = z.object({\n  original_queries: z.array(z.string()),\n  filters_applied: SSASearchFiltersSchema,\n  relevant_nodes: z.array(SSARankedNodeSchema),\n  connection_map: ConnectionMapSchema.optional(),\n  ranking_reasons: z.record(z.string(), RankingReasonSchema),\n  serendipity_candidates: z.array(SerendipityCandidateSchema).optional(),\n  metrics: ExecutionMetricsSchema,\n});\n\n// ============================================================\n// ALGORITHM CONFIGURATION\n// ============================================================\n\n/**\n * SSA algorithm configuration.\n */\nexport interface SSAConfig {\n  seed_threshold: number;\n  dense_weight: number;\n  bm25_weight: number;\n  max_seeds: number;\n  initial_activation: number;\n  hop_decay: number;\n  min_threshold: number;\n  max_hops: number;\n  max_nodes: number;\n  aggregation: 'sum' | 'max';\n  query_combination: QueryCombinationStrategy;\n  default_limit: number;\n}\n\nexport const SSAConfigSchema = z.object({\n  seed_threshold: z.number().min(0).max(1),\n  dense_weight: z.number().min(0).max(1),\n  bm25_weight: z.number().min(0).max(1),\n  max_seeds: z.number().int().positive(),\n  initial_activation: z.number().min(0).max(1),\n  hop_decay: z.number().min(0).max(1),\n  min_threshold: z.number().min(0).max(1),\n  max_hops: z.number().int().positive(),\n  max_nodes: z.number().int().positive(),\n  aggregation: z.enum(['sum', 'max']),\n  query_combination: z.enum(QUERY_COMBINATION_STRATEGIES),\n  default_limit: z.number().int().positive(),\n});\n\n/**\n * Default SSA configuration using storm-016 and storm-028 values.\n */\nexport const DEFAULT_SSA_CONFIG: SSAConfig = {\n  seed_threshold: SSA_SEED_THRESHOLD,\n  dense_weight: DENSE_WEIGHT,\n  bm25_weight: BM25_WEIGHT,\n  max_seeds: 15,\n  initial_activation: SSA_PARAMS.initial_activation,\n  hop_decay: SSA_PARAMS.hop_decay,\n  min_threshold: SSA_PARAMS.min_threshold,\n  max_hops: SSA_PARAMS.max_hops,\n  max_nodes: SSA_PARAMS.max_nodes,\n  aggregation: SSA_PARAMS.aggregation,\n  query_combination: 'average',\n  default_limit: 30,\n};\n\n// ============================================================\n// INTERNAL ALGORITHM TYPES\n// ============================================================\n\n/**\n * Seed node from hybrid seeding.\n */\nexport interface SeedNode {\n  node_id: string;\n  vector_score: number;\n  bm25_score: number;\n  combined_score: number;\n}\n\nexport const SeedNodeSchema = z.object({\n  node_id: z.string(),\n  vector_score: z.number().min(0).max(1),\n  bm25_score: z.number().nonnegative(),\n  combined_score: z.number().min(0).max(1),\n});\n\n/**\n * Result of hybrid seeding phase.\n */\nexport interface SeedingResult {\n  seeds: SeedNode[];\n  vector_candidates: number;\n  bm25_candidates: number;\n  combined_candidates: number;\n  execution_ms: number;\n}\n\nexport const SeedingResultSchema = z.object({\n  seeds: z.array(SeedNodeSchema),\n  vector_candidates: z.number().int().nonnegative(),\n  bm25_candidates: z.number().int().nonnegative(),\n  combined_candidates: z.number().int().nonnegative(),\n  execution_ms: z.number().nonnegative(),\n});\n\n/**\n * Activated node during spreading.\n */\nexport interface SSAActivatedNode {\n  node_id: string;\n  activation: number;\n  hop_distance: number;\n  activation_path: string[];\n  is_seed: boolean;\n  vector_score: number;\n  bm25_score: number;\n}\n\nexport const SSAActivatedNodeSchema = z.object({\n  node_id: z.string(),\n  activation: z.number().min(0),\n  hop_distance: z.number().int().nonnegative(),\n  activation_path: z.array(z.string()),\n  is_seed: z.boolean(),\n  vector_score: z.number().min(0).max(1),\n  bm25_score: z.number().nonnegative(),\n});\n\n/**\n * Result of spreading activation phase.\n */\nexport interface SpreadingResult {\n  activated: SSAActivatedNode[];\n  hops_completed: number;\n  nodes_visited: number;\n  edges_traversed: number;\n  terminated_reason: 'max_hops' | 'max_nodes' | 'no_spread' | 'threshold';\n  execution_ms: number;\n}\n\nexport const SpreadingResultSchema = z.object({\n  activated: z.array(SSAActivatedNodeSchema),\n  hops_completed: z.number().int().nonnegative(),\n  nodes_visited: z.number().int().nonnegative(),\n  edges_traversed: z.number().int().nonnegative(),\n  terminated_reason: z.enum(['max_hops', 'max_nodes', 'no_spread', 'threshold']),\n  execution_ms: z.number().nonnegative(),\n});\n\n/**\n * Minimal node info for filter evaluation.\n */\nexport interface FilterNodeInput {\n  id: string;\n  type: string;\n  created_at: string;\n  last_accessed: string;\n  clusters?: string[];\n  tags?: string[];\n}\n\nexport const FilterNodeInputSchema = z.object({\n  id: z.string(),\n  type: z.string(),\n  created_at: z.string().datetime(),\n  last_accessed: z.string().datetime(),\n  clusters: z.array(z.string()).optional(),\n  tags: z.array(z.string()).optional(),\n});\n\n/**\n * Minimal edge info for filter evaluation.\n */\nexport interface FilterEdgeInput {\n  id: string;\n  source_id: string;\n  target_id: string;\n  edge_type: string;\n}\n\nexport const FilterEdgeInputSchema = z.object({\n  id: z.string(),\n  source_id: z.string(),\n  target_id: z.string(),\n  edge_type: z.string(),\n});\n\n/**\n * Filter predicate result.\n */\nexport interface FilterPredicate {\n  filters: SSASearchFilters;\n  evaluateNode: (node: FilterNodeInput) => boolean;\n  evaluateEdge: (edge: FilterEdgeInput) => boolean;\n}\n\n// ============================================================\n// GRAPH CONTEXT INTERFACE\n// ============================================================\n\n/**\n * Node data for reranking.\n */\nexport interface RerankingNodeData {\n  id: string;\n  last_accessed: Date;\n  created_at: Date;\n  access_count: number;\n  inbound_edge_count: number;\n  subtype?: string;  // e.g. 'custom:lesson' — for per-section reranking (Issue 1)\n}\n\n/**\n * Neighbor result from graph query.\n */\nexport interface NeighborResult {\n  node: FilterNodeInput;\n  edge: FilterEdgeInput;\n  weight: number;\n}\n\n/**\n * Vector search result.\n */\nexport interface SSAVectorSearchResult {\n  nodeId: string;\n  score: number;\n}\n\n/**\n * BM25 search result.\n */\nexport interface BM25SearchResult {\n  nodeId: string;\n  score: number;\n}\n\n/**\n * Graph context for SSA execution.\n */\nexport interface SSAGraphContext {\n  getNode: (id: string) => Promise<FilterNodeInput | null>;\n  getNeighbors: (nodeId: string) => Promise<NeighborResult[]>;\n  vectorSearch: (embedding: Float32Array, limit: number) => Promise<SSAVectorSearchResult[]>;\n  bm25Search: (terms: string[], limit: number) => Promise<BM25SearchResult[]>;\n  getGraphMetrics: () => Promise<GraphMetrics>;\n  getNodeForReranking: (id: string) => Promise<RerankingNodeData | null>;\n}\n\n/**\n * Embed function for query embedding.\n */\nexport type EmbedFunction = (queries: string[]) => Promise<Float32Array>;\n\n/**\n * Options for executeSSA.\n */\nexport interface ExecuteSSAOptions {\n  request: SearchRequest;\n  context: SSAGraphContext;\n  embed: EmbedFunction;\n  config?: Partial<SSAConfig>;\n}\n\n// ============================================================\n// FILTER FUNCTIONS\n// ============================================================\n\n/**\n * Build filter predicate from search filters.\n */\nexport function buildFilterPredicate(filters: SSASearchFilters): FilterPredicate {\n  const now = new Date();\n\n  const evaluateNode = (node: FilterNodeInput): boolean => {\n    // Date range filter\n    if (filters.date_range) {\n      const created = new Date(node.created_at);\n      if (filters.date_range.after && created < new Date(filters.date_range.after)) {\n        return false;\n      }\n      if (filters.date_range.before && created > new Date(filters.date_range.before)) {\n        return false;\n      }\n    }\n\n    // Last accessed filter\n    if (filters.last_accessed) {\n      const lastAccessed = new Date(node.last_accessed);\n      const daysAgo = (now.getTime() - lastAccessed.getTime()) / (1000 * 60 * 60 * 24);\n      if (daysAgo > filters.last_accessed.within_days) {\n        return false;\n      }\n    }\n\n    // Type filter\n    if (filters.types && filters.types.length > 0) {\n      if (!filters.types.includes(node.type)) {\n        return false;\n      }\n    }\n\n    // Exclude types filter\n    if (filters.exclude_types && filters.exclude_types.length > 0) {\n      if (filters.exclude_types.includes(node.type)) {\n        return false;\n      }\n    }\n\n    // Cluster filter\n    if (filters.clusters && filters.clusters.length > 0) {\n      if (!node.clusters || !filters.clusters.some(c => node.clusters!.includes(c))) {\n        return false;\n      }\n    }\n\n    // Tags filter (must have ALL)\n    if (filters.tags && filters.tags.length > 0) {\n      if (!node.tags || !filters.tags.every(t => node.tags!.includes(t))) {\n        return false;\n      }\n    }\n\n    // Tags any filter (must have ANY)\n    if (filters.tags_any && filters.tags_any.length > 0) {\n      if (!node.tags || !filters.tags_any.some(t => node.tags!.includes(t))) {\n        return false;\n      }\n    }\n\n    // Exclude tags filter\n    if (filters.exclude_tags && filters.exclude_tags.length > 0) {\n      if (node.tags && filters.exclude_tags.some(t => node.tags!.includes(t))) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  const evaluateEdge = (edge: FilterEdgeInput): boolean => {\n    // Relationship filter\n    if (filters.relationships && filters.relationships.length > 0) {\n      if (!filters.relationships.includes(edge.edge_type)) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  return { filters, evaluateNode, evaluateEdge };\n}\n\n/**\n * Parse and validate search filters.\n */\nexport function parseFilters(filters: unknown): { success: true; data: SSASearchFilters } | { success: false; error: string } {\n  const result = SSASearchFiltersSchema.safeParse(filters);\n  if (result.success) {\n    return { success: true, data: result.data };\n  }\n  return { success: false, error: result.error.message };\n}\n\n// ============================================================\n// SEEDING FUNCTIONS\n// ============================================================\n\n/**\n * Perform hybrid seeding with vector and BM25.\n */\nexport async function hybridSeed(\n  queryEmbedding: Float32Array,\n  queryTerms: string[],\n  context: SSAGraphContext,\n  predicate: FilterPredicate,\n  config: SSAConfig\n): Promise<SeedingResult> {\n  const startTime = performance.now();\n\n  // Vector search\n  const vectorResults = await context.vectorSearch(queryEmbedding, config.max_seeds * 3);\n\n  // BM25 search\n  const bm25Results = await context.bm25Search(queryTerms, config.max_seeds * 3);\n\n  // Combine scores\n  const scoreMap = new Map<string, { vector: number; bm25: number }>();\n\n  // Normalize BM25 scores (they can be > 1)\n  const maxBm25 = Math.max(...bm25Results.map(r => r.score), 1);\n\n  for (const result of vectorResults) {\n    scoreMap.set(result.nodeId, { vector: result.score, bm25: 0 });\n  }\n\n  for (const result of bm25Results) {\n    const existing = scoreMap.get(result.nodeId);\n    const normalizedBm25 = result.score / maxBm25;\n    if (existing) {\n      existing.bm25 = normalizedBm25;\n    } else {\n      scoreMap.set(result.nodeId, { vector: 0, bm25: normalizedBm25 });\n    }\n  }\n\n  // Calculate combined scores and filter\n  const seeds: SeedNode[] = [];\n\n  for (const [nodeId, scores] of scoreMap) {\n    const combined = config.dense_weight * scores.vector + config.bm25_weight * scores.bm25;\n\n    if (combined >= config.seed_threshold) {\n      // Apply node filter\n      const node = await context.getNode(nodeId);\n      if (node && predicate.evaluateNode(node)) {\n        seeds.push({\n          node_id: nodeId,\n          vector_score: scores.vector,\n          bm25_score: scores.bm25,\n          combined_score: combined,\n        });\n      }\n    }\n  }\n\n  // Sort by combined score and limit\n  seeds.sort((a, b) => b.combined_score - a.combined_score);\n  const limitedSeeds = seeds.slice(0, config.max_seeds);\n\n  return {\n    seeds: limitedSeeds,\n    vector_candidates: vectorResults.length,\n    bm25_candidates: bm25Results.length,\n    combined_candidates: scoreMap.size,\n    execution_ms: performance.now() - startTime,\n  };\n}\n\n// ============================================================\n// SPREADING ACTIVATION FUNCTIONS\n// ============================================================\n\n/**\n * Get edge weight for SSA from edge type.\n */\nexport function getSSAEdgeWeight(edgeType: string): number {\n  const weights = SSA_EDGE_WEIGHTS as unknown as Record<string, number>;\n  return weights[edgeType] ?? 0.50; // Default to related_to weight\n}\n\n/**\n * Run spreading activation from seed nodes.\n */\nexport async function spreadActivation(\n  seeds: SeedNode[],\n  context: SSAGraphContext,\n  predicate: FilterPredicate,\n  config: SSAConfig\n): Promise<SpreadingResult> {\n  const startTime = performance.now();\n\n  // Initialize activation map\n  const activations = new Map<string, SSAActivatedNode>();\n  const toProcess: Array<{ nodeId: string; activation: number; hop: number; path: string[] }> = [];\n\n  // Initialize seeds\n  for (const seed of seeds) {\n    const activation = config.initial_activation * seed.combined_score;\n    activations.set(seed.node_id, {\n      node_id: seed.node_id,\n      activation,\n      hop_distance: 0,\n      activation_path: [seed.node_id],\n      is_seed: true,\n      vector_score: seed.vector_score,\n      bm25_score: seed.bm25_score,\n    });\n    toProcess.push({ nodeId: seed.node_id, activation, hop: 0, path: [seed.node_id] });\n  }\n\n  let nodesVisited = seeds.length;\n  let edgesTraversed = 0;\n  let hopsCompleted = 0;\n  let terminatedReason: 'max_hops' | 'max_nodes' | 'no_spread' | 'threshold' = 'max_hops';\n\n  // Process activation spread\n  while (toProcess.length > 0 && hopsCompleted < config.max_hops) {\n    const nextRound: typeof toProcess = [];\n    hopsCompleted++;\n\n    for (const { nodeId, activation, hop, path } of toProcess) {\n      // Skip if below threshold\n      if (activation < config.min_threshold) {\n        continue;\n      }\n\n      // Get neighbors\n      const neighbors = await context.getNeighbors(nodeId);\n\n      for (const neighbor of neighbors) {\n        edgesTraversed++;\n\n        // Check edge filter\n        if (!predicate.evaluateEdge(neighbor.edge)) {\n          continue;\n        }\n\n        // Check node filter\n        if (!predicate.evaluateNode(neighbor.node)) {\n          continue;\n        }\n\n        // Calculate spread\n        const edgeWeight = getSSAEdgeWeight(neighbor.edge.edge_type);\n        const spread = activation * edgeWeight * config.hop_decay;\n\n        if (spread < config.min_threshold) {\n          continue;\n        }\n\n        const neighborId = neighbor.node.id;\n        const existing = activations.get(neighborId);\n\n        if (existing) {\n          // Update existing activation based on aggregation mode\n          if (config.aggregation === 'sum') {\n            existing.activation += spread;\n          } else {\n            existing.activation = Math.max(existing.activation, spread);\n          }\n          // Update path if this path is shorter\n          if (hop + 1 < existing.hop_distance) {\n            existing.hop_distance = hop + 1;\n            existing.activation_path = [...path, neighborId];\n          }\n        } else {\n          // Add new activation\n          const newNode: SSAActivatedNode = {\n            node_id: neighborId,\n            activation: spread,\n            hop_distance: hop + 1,\n            activation_path: [...path, neighborId],\n            is_seed: false,\n            vector_score: 0,\n            bm25_score: 0,\n          };\n          activations.set(neighborId, newNode);\n          nodesVisited++;\n\n          // Check max nodes limit\n          if (nodesVisited >= config.max_nodes) {\n            terminatedReason = 'max_nodes';\n            break;\n          }\n        }\n\n        // Queue for next round\n        nextRound.push({\n          nodeId: neighborId,\n          activation: spread,\n          hop: hop + 1,\n          path: [...path, neighborId],\n        });\n      }\n\n      if (nodesVisited >= config.max_nodes) {\n        break;\n      }\n    }\n\n    if (nodesVisited >= config.max_nodes) {\n      break;\n    }\n\n    if (nextRound.length === 0) {\n      terminatedReason = 'no_spread';\n      break;\n    }\n\n    toProcess.length = 0;\n    toProcess.push(...nextRound);\n  }\n\n  // Convert map to array — raw activations may exceed 1.0 from sum aggregation.\n  // Normalization happens downstream in executeSSA after the query-relevance filter,\n  // so graph scores are relative to the surviving result set, not deleted hub nodes.\n  const activated = Array.from(activations.values());\n\n  return {\n    activated,\n    hops_completed: hopsCompleted,\n    nodes_visited: nodesVisited,\n    edges_traversed: edgesTraversed,\n    terminated_reason: terminatedReason,\n    execution_ms: performance.now() - startTime,\n  };\n}\n\n// ============================================================\n// RERANKING INTEGRATION\n// ============================================================\n\n/**\n * Convert activated nodes to scored nodes for reranking.\n */\nexport async function buildScoredNodes(\n  activated: SSAActivatedNode[],\n  context: SSAGraphContext\n): Promise<ScoredNode[]> {\n  const scoredNodes: ScoredNode[] = [];\n\n  for (const node of activated) {\n    const rerankData = await context.getNodeForReranking(node.node_id);\n    if (rerankData) {\n      scoredNodes.push({\n        id: node.node_id,\n        semantic_score: node.vector_score,\n        bm25_score: node.bm25_score,\n        graph_score: node.activation,\n        last_accessed: rerankData.last_accessed,\n        created_at: rerankData.created_at,\n        access_count: rerankData.access_count,\n        inbound_edge_count: rerankData.inbound_edge_count,\n        subtype: rerankData.subtype,  // For per-section reranking (Issue 1)\n      });\n    }\n  }\n\n  return scoredNodes;\n}\n\n/**\n * Convert ranked nodes to SSA format.\n */\nexport function convertToSSARankedNodes(ranked: RankedNode[]): SSARankedNode[] {\n  return ranked.map(r => ({\n    node_id: r.node.id,\n    score: r.score,\n    ranking_reason: {\n      primary_signal: r.primary_signal,\n      explanation: generateExplanation(r.primary_signal, r.breakdown),\n      score_breakdown: r.breakdown,\n    },\n  }));\n}\n\n// ============================================================\n// SERENDIPITY FUNCTIONS\n// ============================================================\n\n/**\n * Identify serendipity candidates.\n */\nexport function identifySerendipity(\n  activated: SSAActivatedNode[],\n  level: SerendipityLevel\n): SerendipityCandidate[] {\n  if (level === 'off') {\n    return [];\n  }\n\n  const threshold = SERENDIPITY_THRESHOLDS[level];\n  const candidates: SerendipityCandidate[] = [];\n\n  for (const node of activated) {\n    // Low semantic similarity but high graph activation\n    if (node.vector_score < threshold.maxSim && node.activation >= threshold.minGraph) {\n      candidates.push({\n        node_id: node.node_id,\n        semantic_score: node.vector_score,\n        graph_score: node.activation,\n        connection_path: node.activation_path,\n        explanation: `Connected via ${node.hop_distance} hops despite low semantic similarity`,\n      });\n    }\n  }\n\n  // Sort by graph score and limit\n  candidates.sort((a, b) => b.graph_score - a.graph_score);\n  return candidates.slice(0, threshold.count);\n}\n\n// ============================================================\n// CONNECTION MAP FUNCTIONS\n// ============================================================\n\n/**\n * Build connection map from activated nodes.\n */\nexport async function buildConnectionMap(\n  activated: SSAActivatedNode[],\n  context: SSAGraphContext,\n  predicate: FilterPredicate\n): Promise<ConnectionMap> {\n  const activatedIds = new Set(activated.map(n => n.node_id));\n  const connections: NodeConnection[] = [];\n\n  for (const node of activated) {\n    const neighbors = await context.getNeighbors(node.node_id);\n    for (const neighbor of neighbors) {\n      // Only include edges between activated nodes\n      if (activatedIds.has(neighbor.node.id)) {\n        // Check edge filter\n        if (predicate.evaluateEdge(neighbor.edge)) {\n          connections.push({\n            source_id: node.node_id,\n            target_id: neighbor.node.id,\n            edge_type: neighbor.edge.edge_type,\n            weight: neighbor.weight,\n          });\n        }\n      }\n    }\n  }\n\n  return {\n    connections,\n    node_count: activated.length,\n    edge_count: connections.length,\n  };\n}\n\n// ============================================================\n// UTILITY FUNCTIONS\n// ============================================================\n\n/**\n * Get normalized queries from request.\n */\nexport function getNormalizedQueries(request: SearchRequest): string[] {\n  if (request.queries && request.queries.length > 0) {\n    return request.queries;\n  }\n  if (request.query) {\n    return [request.query];\n  }\n  return [];\n}\n\n/**\n * Extract query terms for BM25.\n */\nexport function extractQueryTerms(queries: string[]): string[] {\n  const terms: string[] = [];\n  for (const query of queries) {\n    // Simple tokenization - split on whitespace and punctuation\n    const tokens = query.toLowerCase()\n      .replace(/[^\\w\\s]/g, ' ')\n      .split(/\\s+/)\n      .filter(t => t.length >= 2);\n    terms.push(...tokens);\n  }\n  // Deduplicate\n  return [...new Set(terms)];\n}\n\n/**\n * Merge config with defaults.\n */\nexport function mergeSSAConfig(partial?: Partial<SSAConfig>): SSAConfig {\n  if (!partial) return DEFAULT_SSA_CONFIG;\n  return { ...DEFAULT_SSA_CONFIG, ...partial };\n}\n\n/**\n * Create empty execution metrics.\n */\nexport function createEmptyMetrics(): ExecutionMetrics {\n  return {\n    total_ms: 0,\n    parse_filters_ms: 0,\n    embed_queries_ms: 0,\n    hybrid_seeding_ms: 0,\n    spreading_ms: 0,\n    reranking_ms: 0,\n    seeds_found: 0,\n    nodes_activated: 0,\n    nodes_filtered: 0,\n    nodes_returned: 0,\n  };\n}\n\n/**\n * Generate explanation for primary signal.\n */\nexport function generateExplanation(\n  primary: keyof ScoreBreakdown,\n  breakdown: ScoreBreakdown\n): string {\n  const score = breakdown[primary];\n  const percentage = Math.round(score * 100);\n\n  switch (primary) {\n    case 'semantic':\n      return `Strong semantic match (${percentage}% similarity)`;\n    case 'keyword':\n      return `Keyword match in content (${percentage}% BM25 score)`;\n    case 'graph':\n      return `Connected via knowledge graph (${percentage}% activation)`;\n    case 'recency':\n      return `Recently accessed (${percentage}% recency score)`;\n    case 'authority':\n      return `Well-connected node (${percentage}% authority)`;\n    case 'affinity':\n      return `Frequently accessed by user (${percentage}% affinity)`;\n    default:\n      return `Primary signal: ${primary} (${percentage}%)`;\n  }\n}\n\n/**\n * Get serendipity threshold for a level.\n */\nexport function getSerendipityThreshold(level: SerendipityLevel): { minGraph: number; maxSim: number; count: number } {\n  return SERENDIPITY_THRESHOLDS[level];\n}\n\n// ============================================================\n// VALIDATION FUNCTIONS\n// ============================================================\n\nexport function validateSearchRequest(request: unknown): request is SearchRequest {\n  return SearchRequestSchema.safeParse(request).success;\n}\n\nexport function validateSearchFilters(filters: unknown): filters is SSASearchFilters {\n  return SSASearchFiltersSchema.safeParse(filters).success;\n}\n\nexport function validateSSAConfig(config: unknown): config is SSAConfig {\n  return SSAConfigSchema.safeParse(config).success;\n}\n\nexport function validateSSAResult(result: unknown): result is SSAResult {\n  return SSAResultSchema.safeParse(result).success;\n}\n\n/**\n * Safely parse search request.\n */\nexport function parseSearchRequest(request: unknown): { success: true; data: SearchRequest } | { success: false; error: string } {\n  const result = SearchRequestSchema.safeParse(request);\n  if (result.success) {\n    return { success: true, data: result.data };\n  }\n  return { success: false, error: result.error.message };\n}\n\n// ============================================================\n// MAIN EXECUTION FUNCTION\n// ============================================================\n\n/**\n * Execute SSA retrieval algorithm.\n * Main entry point for Phase 1 retrieval.\n */\nexport async function executeSSA(options: ExecuteSSAOptions): Promise<SSAResult> {\n  const startTime = performance.now();\n  const metrics = createEmptyMetrics();\n\n  const { request, context, embed, config: partialConfig } = options;\n  const config = mergeSSAConfig(partialConfig);\n\n  // Validate request\n  const parseResult = parseSearchRequest(request);\n  if (!parseResult.success) {\n    // Don't expose internal schema details in error message\n    throw new Error('Invalid search request: validation failed. Ensure query or queries is provided.');\n  }\n\n  // Step 0: Parse filters\n  const filterStart = performance.now();\n  const filters = request.filters ?? {};\n  const predicate = buildFilterPredicate(filters);\n  metrics.parse_filters_ms = performance.now() - filterStart;\n\n  // Get normalized queries\n  const queries = getNormalizedQueries(request);\n  if (queries.length === 0) {\n    throw new Error('No queries provided');\n  }\n\n  // Step 1: Embed queries\n  const embedStart = performance.now();\n  const queryEmbedding = await embed(queries);\n  metrics.embed_queries_ms = performance.now() - embedStart;\n\n  // Extract query terms for BM25\n  const queryTerms = extractQueryTerms(queries);\n\n  // Step 2: Hybrid seeding\n  const seedingStart = performance.now();\n  const seedingResult = await hybridSeed(queryEmbedding, queryTerms, context, predicate, config);\n  metrics.hybrid_seeding_ms = performance.now() - seedingStart;\n  metrics.seeds_found = seedingResult.seeds.length;\n\n  // Handle empty seed case\n  if (seedingResult.seeds.length === 0) {\n    metrics.total_ms = performance.now() - startTime;\n    return {\n      original_queries: queries,\n      filters_applied: filters,\n      relevant_nodes: [],\n      ranking_reasons: {},\n      metrics,\n    };\n  }\n\n  // Step 3: Spreading activation\n  const spreadingStart = performance.now();\n  const spreadingResult = await spreadActivation(seedingResult.seeds, context, predicate, config);\n  metrics.spreading_ms = performance.now() - spreadingStart;\n  metrics.nodes_activated = spreadingResult.activated.length;\n\n  // Step 3.5: Query-relevance floor — drop nodes with zero topical connection.\n  // Nodes discovered purely through graph edges (not seeds) have bm25_score=0\n  // and vector_score=0. They got activated because they're well-connected, not\n  // because they match the query. Seeds always pass (they matched during seeding).\n  const relevantActivated = spreadingResult.activated.filter(\n    (node) => node.is_seed || node.bm25_score > 0 || node.vector_score > 0,\n  );\n  metrics.nodes_filtered = spreadingResult.activated.length - relevantActivated.length;\n\n  // Step 3.6: Normalize activations to [0, 1] across surviving nodes.\n  // Raw activations from sum aggregation can exceed 1.0 when multiple paths converge.\n  // Normalizing here (after the filter) ensures graph scores are relative to the\n  // surviving result set — not inflated by removed hub nodes.\n  if (relevantActivated.length > 0) {\n    const maxActivation = Math.max(...relevantActivated.map((n) => n.activation));\n    if (maxActivation > 0) {\n      for (const node of relevantActivated) {\n        node.activation = node.activation / maxActivation;\n      }\n    }\n  }\n\n  // Step 4: Per-section reranking — each node scored with its section's weight profile\n  // Signals: recency-dominant. Episodic: recency-favoring. Knowledge: authority-dominant.\n  // Procedural: keyword+graph-dominant. See: revisions/memory-sections/issue-1-retrieval-weights.md\n  const rerankingStart = performance.now();\n  const graphMetrics = await context.getGraphMetrics();\n  const scoredNodes = await buildScoredNodes(relevantActivated, context);\n  const rankedNodes = rerankWithSectionWeights(scoredNodes, graphMetrics);\n  metrics.reranking_ms = performance.now() - rerankingStart;\n\n  // Apply limit\n  const limit = request.limit ?? config.default_limit;\n  const limitedRanked = rankedNodes.slice(0, limit);\n\n  // Convert to SSA format\n  const ssaRankedNodes = convertToSSARankedNodes(limitedRanked);\n  metrics.nodes_returned = ssaRankedNodes.length;\n\n  // Build ranking reasons map\n  const rankingReasons: Record<string, RankingReason> = {};\n  for (const node of ssaRankedNodes) {\n    rankingReasons[node.node_id] = node.ranking_reason;\n  }\n\n  // Step 5: Build result\n  const result: SSAResult = {\n    original_queries: queries,\n    filters_applied: filters,\n    relevant_nodes: ssaRankedNodes,\n    ranking_reasons: rankingReasons,\n    metrics,\n  };\n\n  // Optional: Include connection map\n  if (request.include_connections) {\n    result.connection_map = await buildConnectionMap(\n      spreadingResult.activated,\n      context,\n      predicate\n    );\n  }\n\n  // Optional: Include serendipity candidates\n  const serendipityLevel = request.serendipity_level ?? 'off';\n  if (serendipityLevel !== 'off') {\n    result.serendipity_candidates = identifySerendipity(spreadingResult.activated, serendipityLevel);\n  }\n\n  metrics.total_ms = performance.now() - startTime;\n\n  return result;\n}\n\n/**\n * Create a search response from SSA result.\n */\nexport function createSearchResponse(result: SSAResult): SearchResponse {\n  return {\n    results: result.relevant_nodes,\n    filters_applied: result.filters_applied,\n    total_candidates: result.metrics.nodes_activated,\n    execution_time_ms: result.metrics.total_ms,\n    metrics: result.metrics,\n  };\n}\n"]}