{"version":3,"sources":["../../src/params/index.ts","../../src/qcs/index.ts"],"names":["z"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * @module @nous/core/params\n * @description Canonical algorithm parameters for Nous - the single source of truth\n * @version 1.0.0\n * @spec Brainstorms/Specs/Phase-2-Data-Representation/storm-028\n *\n * This module implements storm-028: Algorithm Parameters & Thresholds.\n *\n * storm-028 is the AUTHORITATIVE SOURCE for all algorithm parameters.\n * Other storms should reference this module for values:\n * - storm-005 (Retrieval): Use reranking weights, SSA parameters\n * - storm-007 (Forgetting): Use decay parameters\n * - storm-008 (Classification): Use confidence thresholds\n * - storm-012 (Adaptive Limits): Use budget parameters\n */\n\nimport { z } from 'zod';\n\n// ============================================================\n// ALGORITHM NODE TYPES\n// ============================================================\n\n/**\n * Node types for algorithm behavior.\n * These are behavioral categories used for stability/difficulty,\n * distinct from storm-011's structural node types.\n */\nexport const ALGORITHM_NODE_TYPES = [\n  'person',\n  'fact',\n  'concept',\n  'event',\n  'note',\n  'document',\n  'preference',\n] as const;\n\nexport type AlgorithmNodeType = (typeof ALGORITHM_NODE_TYPES)[number];\n\n// ============================================================\n// RERANKING WEIGHTS\n// ============================================================\n\n/**\n * Reranking weight configuration.\n * All weights must sum to 1.0.\n */\nexport interface RerankingWeights {\n  semantic: number;   // 0.30 - Vector similarity\n  keyword: number;    // 0.15 - BM25 keyword match\n  graph: number;      // 0.20 - Spreading activation\n  recency: number;    // 0.15 - Time-based decay\n  authority: number;  // 0.10 - Inbound edge count\n  affinity: number;   // 0.10 - User interaction history\n}\n\nexport const RerankingWeightsSchema = z.object({\n  semantic: z.number().min(0).max(1),\n  keyword: z.number().min(0).max(1),\n  graph: z.number().min(0).max(1),\n  recency: z.number().min(0).max(1),\n  authority: z.number().min(0).max(1),\n  affinity: z.number().min(0).max(1),\n}).refine(\n  (w) => Math.abs(w.semantic + w.keyword + w.graph + w.recency + w.authority + w.affinity - 1.0) < 0.001,\n  { message: 'Reranking weights must sum to 1.0' }\n);\n\n/**\n * Default reranking weights.\n */\nexport const RERANKING_WEIGHTS: RerankingWeights = {\n  semantic: 0.30,\n  keyword: 0.15,\n  graph: 0.20,\n  recency: 0.15,\n  authority: 0.10,\n  affinity: 0.10,\n};\n\n/**\n * Reranking behavior configuration.\n */\nexport interface RerankingConfig {\n  recency_half_life_days: number;\n  authority_cap_multiple: number;\n  affinity_saturation: number;\n  new_content_boost_days: number;\n  new_content_boost_value: number;\n}\n\nexport const RerankingConfigSchema = z.object({\n  recency_half_life_days: z.number().positive(),\n  authority_cap_multiple: z.number().positive(),\n  affinity_saturation: z.number().positive(),\n  new_content_boost_days: z.number().int().nonnegative(),\n  new_content_boost_value: z.number().min(0).max(1),\n});\n\nexport const RERANKING_CONFIG: RerankingConfig = {\n  recency_half_life_days: 30,\n  authority_cap_multiple: 2.0,\n  affinity_saturation: 10,\n  new_content_boost_days: 7,\n  new_content_boost_value: 0.2,\n};\n\n/**\n * Per-signal score breakdown.\n */\nexport interface ScoreBreakdown {\n  semantic: number;\n  keyword: number;\n  graph: number;\n  recency: number;\n  authority: number;\n  affinity: number;\n}\n\nexport const ScoreBreakdownSchema = z.object({\n  semantic: z.number().min(0).max(1),\n  keyword: z.number().min(0).max(1),\n  graph: z.number().min(0).max(1),\n  recency: z.number().min(0).max(1),\n  authority: z.number().min(0).max(1),\n  affinity: z.number().min(0).max(1),\n});\n\n/**\n * Scored node input for reranking.\n */\nexport interface ScoredNode {\n  id: string;\n  semantic_score?: number;\n  bm25_score?: number;\n  graph_score?: number;\n  last_accessed: Date;\n  created_at: Date;\n  access_count: number;\n  inbound_edge_count: number;\n}\n\nexport const ScoredNodeSchema = z.object({\n  id: z.string(),\n  semantic_score: z.number().min(0).max(1).optional(),\n  bm25_score: z.number().nonnegative().optional(),\n  graph_score: z.number().min(0).max(1).optional(),\n  last_accessed: z.date(),\n  created_at: z.date(),\n  access_count: z.number().int().nonnegative(),\n  inbound_edge_count: z.number().int().nonnegative(),\n});\n\n/**\n * Graph metrics for reranking context.\n */\nexport interface GraphMetrics {\n  total_nodes: number;\n  total_edges: number;\n  density: number;\n  avg_inbound_edges: number;\n  avg_outbound_edges: number;\n}\n\nexport const GraphMetricsSchema = z.object({\n  total_nodes: z.number().int().nonnegative(),\n  total_edges: z.number().int().nonnegative(),\n  density: z.number().min(0).max(1),\n  avg_inbound_edges: z.number().nonnegative(),\n  avg_outbound_edges: z.number().nonnegative(),\n});\n\n/**\n * Ranked node result.\n */\nexport interface RankedNode {\n  node: ScoredNode;\n  score: number;\n  breakdown: ScoreBreakdown;\n  primary_signal: keyof ScoreBreakdown;\n}\n\n// ============================================================\n// DECAY CONFIGURATION\n// ============================================================\n\n/**\n * Decay behavior configuration (FSRS-inspired).\n */\nexport interface DecayConfig {\n  growth_rate: number;            // 2.5 - Stability multiplier on access\n  max_stability_days: number;     // 365 - Cap at 1 year\n  active_threshold: number;       // 0.5 - R > 0.5 = ACTIVE\n  weak_threshold: number;         // 0.1 - R 0.1-0.5 = WEAK, R < 0.1 = DORMANT\n  dormant_days: number;           // 60 - Days at R < 0.1 before dormant status\n  compress_days: number;          // 120 - Days before compression eligible\n  archive_days: number;           // 240 - Days before archive eligible\n  cascade_factor: number;         // 0.8 - Edge weakening on dormant\n  edge_floor: number;             // 0.1 - Minimum edge strength\n}\n\nexport const DecayConfigSchema = z.object({\n  growth_rate: z.number().positive(),\n  max_stability_days: z.number().int().positive(),\n  active_threshold: z.number().min(0).max(1),\n  weak_threshold: z.number().min(0).max(1),\n  dormant_days: z.number().int().nonnegative(),\n  compress_days: z.number().int().nonnegative(),\n  archive_days: z.number().int().nonnegative(),\n  cascade_factor: z.number().min(0).max(1),\n  edge_floor: z.number().min(0).max(1),\n});\n\nexport const DECAY_CONFIG: DecayConfig = {\n  growth_rate: 2.5,\n  max_stability_days: 365,\n  active_threshold: 0.5,\n  weak_threshold: 0.1,\n  dormant_days: 60,\n  compress_days: 120,\n  archive_days: 240,\n  cascade_factor: 0.8,\n  edge_floor: 0.1,\n};\n\n/**\n * Initial stability per algorithm node type (days).\n */\nexport const INITIAL_STABILITY: Record<AlgorithmNodeType, number> = {\n  person: 14,\n  fact: 7,\n  concept: 21,\n  event: 10,\n  note: 30,\n  document: 7,\n  preference: 45,\n};\n\n/**\n * Initial difficulty per algorithm node type (0-1).\n */\nexport const INITIAL_DIFFICULTY: Record<AlgorithmNodeType, number> = {\n  person: 0.2,\n  fact: 0.3,\n  concept: 0.4,\n  event: 0.3,\n  note: 0.2,\n  document: 0.5,\n  preference: 0.1,\n};\n\n/**\n * Decay-based lifecycle states for memory retrieval.\n * NOTE: These are distinct from storm-011's content lifecycle states.\n * These states are used by the forgetting model (storm-007) for decay calculations.\n */\nexport const DECAY_LIFECYCLE_STATES = ['ACTIVE', 'WEAK', 'DORMANT', 'COMPRESS', 'ARCHIVE'] as const;\nexport type DecayLifecycleState = (typeof DECAY_LIFECYCLE_STATES)[number];\n\n// ============================================================\n// SSA PARAMETERS\n// ============================================================\n\n/**\n * SSA aggregation modes.\n */\nexport type SSAAggregation = 'sum' | 'max';\n\n/**\n * Spreading activation parameters.\n */\nexport interface SSAParams {\n  initial_activation: number;   // 1.0 - Seeds start at full\n  hop_decay: number;            // 0.5 - 50% loss per hop\n  min_threshold: number;        // 0.05 - Stop spreading below 5%\n  max_hops: number;             // 3 - Hard limit\n  max_nodes: number;            // 500 - Breadth limit\n  aggregation: SSAAggregation;  // 'sum' - Allow path reinforcement\n}\n\nexport const SSAParamsSchema = z.object({\n  initial_activation: z.number().min(0).max(1),\n  hop_decay: z.number().min(0).max(1),\n  min_threshold: z.number().min(0).max(1),\n  max_hops: z.number().int().positive(),\n  max_nodes: z.number().int().positive(),\n  aggregation: z.enum(['sum', 'max']),\n});\n\nexport const SSA_PARAMS: SSAParams = {\n  initial_activation: 1.0,\n  hop_decay: 0.5,\n  min_threshold: 0.05,\n  max_hops: 3,\n  max_nodes: 500,\n  aggregation: 'sum',\n};\n\n/**\n * Edge weights for SSA.\n * NOTE: These reference storm-031's edge weights but are defined here\n * as the canonical SSA values.\n */\nexport interface SSAEdgeWeights {\n  same_entity: number;\n  part_of: number;\n  caused_by: number;\n  mentioned_together: number;\n  related_to: number;\n  similar_to: number;\n  user_linked: number;\n  temporal_adjacent: number;\n}\n\nexport const SSAEdgeWeightsSchema = z.object({\n  same_entity: z.number().min(0).max(1),\n  part_of: z.number().min(0).max(1),\n  caused_by: z.number().min(0).max(1),\n  mentioned_together: z.number().min(0).max(1),\n  related_to: z.number().min(0).max(1),\n  similar_to: z.number().min(0).max(1),\n  user_linked: z.number().min(0).max(1),\n  temporal_adjacent: z.number().min(0).max(1),\n});\n\nexport const SSA_EDGE_WEIGHTS: SSAEdgeWeights = {\n  same_entity: 0.95,\n  part_of: 0.85,\n  caused_by: 0.80,\n  mentioned_together: 0.60,\n  related_to: 0.50,\n  similar_to: 0.45,\n  user_linked: 0.90,\n  temporal_adjacent: 0.40,\n};\n\n/**\n * Activated node result from SSA.\n */\nexport interface ActivatedNode {\n  id: string;\n  activation: number;\n  path: string[];\n}\n\nexport const ActivatedNodeSchema = z.object({\n  id: z.string(),\n  activation: z.number().min(0).max(1),\n  path: z.array(z.string()),\n});\n\n// ============================================================\n// CONFIDENCE THRESHOLDS\n// ============================================================\n\n/**\n * Confidence threshold categories.\n */\nexport interface ConfidenceThresholds {\n  retrieval: {\n    high: number;     // 0.70 - Answer directly\n    medium: number;   // 0.45 - May need context\n    low: number;      // 0.45 - Below this, clarify\n  };\n  classification: {\n    clear_lookup: number;    // 0.85 - Definitely a simple lookup\n    clear_reasoning: number; // 0.85 - Definitely needs reasoning\n    ambiguous_floor: number; // 0.50 - Below this is REASONING\n  };\n  extraction: {\n    auto_store: number;    // 0.85 - Store without asking\n    confirm_store: number; // 0.60 - Ask user to confirm\n  };\n  contradiction: {\n    definite: number;  // 0.85 - Flag for user\n    possible: number;  // 0.60 - Note internally\n  };\n}\n\nexport const ConfidenceThresholdsSchema = z.object({\n  retrieval: z.object({\n    high: z.number().min(0).max(1),\n    medium: z.number().min(0).max(1),\n    low: z.number().min(0).max(1),\n  }),\n  classification: z.object({\n    clear_lookup: z.number().min(0).max(1),\n    clear_reasoning: z.number().min(0).max(1),\n    ambiguous_floor: z.number().min(0).max(1),\n  }),\n  extraction: z.object({\n    auto_store: z.number().min(0).max(1),\n    confirm_store: z.number().min(0).max(1),\n  }),\n  contradiction: z.object({\n    definite: z.number().min(0).max(1),\n    possible: z.number().min(0).max(1),\n  }),\n});\n\nexport const CONFIDENCE_THRESHOLDS: ConfidenceThresholds = {\n  retrieval: {\n    high: 0.70,\n    medium: 0.45,\n    low: 0.45,\n  },\n  classification: {\n    clear_lookup: 0.85,\n    clear_reasoning: 0.85,\n    ambiguous_floor: 0.50,\n  },\n  extraction: {\n    auto_store: 0.85,\n    confirm_store: 0.60,\n  },\n  contradiction: {\n    definite: 0.85,\n    possible: 0.60,\n  },\n};\n\n/**\n * Confidence levels.\n */\nexport const CONFIDENCE_LEVELS = ['HIGH', 'MEDIUM', 'LOW'] as const;\nexport type ConfidenceLevel = (typeof CONFIDENCE_LEVELS)[number];\n\n/**\n * Retrieval Confidence System weights.\n */\nexport interface RCSWeights {\n  match_quality: number;     // 0.40\n  distinctiveness: number;   // 0.35\n  completeness: number;      // 0.25\n}\n\nexport const RCSWeightsSchema = z.object({\n  match_quality: z.number().min(0).max(1),\n  distinctiveness: z.number().min(0).max(1),\n  completeness: z.number().min(0).max(1),\n});\n\nexport const RCS_WEIGHTS: RCSWeights = {\n  match_quality: 0.40,\n  distinctiveness: 0.35,\n  completeness: 0.25,\n};\n\n/**\n * Retrieval confidence result.\n */\nexport interface RetrievalConfidenceResult {\n  score: number;\n  level: ConfidenceLevel;\n  breakdown: { mq: number; dt: number; cm: number };\n  flags: string[];\n}\n\nexport const RetrievalConfidenceResultSchema = z.object({\n  score: z.number().min(0).max(1),\n  level: z.enum(CONFIDENCE_LEVELS),\n  breakdown: z.object({\n    mq: z.number().min(0).max(1),\n    dt: z.number().min(0).max(1),\n    cm: z.number().min(0).max(1),\n  }),\n  flags: z.array(z.string()),\n});\n\n/**\n * Contradiction detection levels.\n */\nexport const CONTRADICTION_LEVELS = ['definite', 'possible', 'none'] as const;\nexport type ContradictionLevel = (typeof CONTRADICTION_LEVELS)[number];\n\n/**\n * Contradiction detection result.\n */\nexport interface ContradictionResult {\n  level: ContradictionLevel;\n  score: number;\n  action: 'flag_user' | 'note_internal' | 'safe_to_store';\n  explanation: string;\n}\n\nexport const ContradictionResultSchema = z.object({\n  level: z.enum(CONTRADICTION_LEVELS),\n  score: z.number().min(0).max(1),\n  action: z.enum(['flag_user', 'note_internal', 'safe_to_store']),\n  explanation: z.string(),\n});\n\n// ============================================================\n// ADAPTIVE LIMITS\n// ============================================================\n\n/**\n * Budget configuration per operation.\n */\nexport interface BudgetConfig {\n  time_ms: number;\n  max_nodes: number;\n  max_api_calls: number;\n}\n\nexport const BudgetConfigSchema = z.object({\n  time_ms: z.number().nonnegative(),\n  max_nodes: z.number().int().nonnegative(),\n  max_api_calls: z.number().int().nonnegative(),\n});\n\nexport const OPERATION_BUDGETS: Record<string, BudgetConfig> = {\n  simple_lookup: { time_ms: 50, max_nodes: 100, max_api_calls: 0 },\n  standard_query: { time_ms: 100, max_nodes: 500, max_api_calls: 0 },\n  complex_query: { time_ms: 200, max_nodes: 1000, max_api_calls: 0 },\n  phase2_reasoning: { time_ms: 3000, max_nodes: 500, max_api_calls: 5 },\n  deep_search: { time_ms: 500, max_nodes: 2000, max_api_calls: 0 },\n  serendipity: { time_ms: 200, max_nodes: 200, max_api_calls: 0 },\n};\n\n/**\n * Quality target per query type.\n */\nexport interface QualityTarget {\n  confidence: number;\n  min_coverage: number;\n}\n\nexport const QualityTargetSchema = z.object({\n  confidence: z.number().min(0).max(1),\n  min_coverage: z.number().min(0).max(1),\n});\n\nexport const QUALITY_TARGETS: Record<string, QualityTarget> = {\n  LOOKUP: { confidence: 0.80, min_coverage: 0.60 },\n  REASONING: { confidence: 0.70, min_coverage: 0.70 },\n  EXPLORATORY: { confidence: 0.50, min_coverage: 0.40 },\n  TEMPORAL: { confidence: 0.75, min_coverage: 0.65 },\n};\n\n/**\n * Quality score weights.\n */\nexport interface QualityWeights {\n  coverage: number;\n  match_quality: number;\n  convergence: number;\n}\n\nexport const QualityWeightsSchema = z.object({\n  coverage: z.number().min(0).max(1),\n  match_quality: z.number().min(0).max(1),\n  convergence: z.number().min(0).max(1),\n});\n\nexport const QUALITY_WEIGHTS: QualityWeights = {\n  coverage: 0.35,\n  match_quality: 0.45,\n  convergence: 0.20,\n};\n\n/**\n * Cold start threshold (node count).\n */\nexport const COLD_START_THRESHOLD = 200;\n\n/**\n * Adaptive limits configuration.\n */\nexport interface AdaptiveLimits {\n  entry_points: number;\n  max_hops: number;\n  max_nodes: number;\n}\n\nexport const AdaptiveLimitsSchema = z.object({\n  entry_points: z.number().int().positive(),\n  max_hops: z.number().int().positive(),\n  max_nodes: z.number().int().positive(),\n});\n\nexport const COLD_START_LIMITS: AdaptiveLimits = {\n  entry_points: 2,\n  max_hops: 3,\n  max_nodes: 50,\n};\n\n/**\n * Query types for adaptive limits.\n */\nexport const QUERY_TYPES = ['simple', 'standard', 'complex'] as const;\nexport type QueryType = (typeof QUERY_TYPES)[number];\n\n/**\n * Termination result.\n */\nexport interface TerminationResult {\n  terminate: boolean;\n  reason: string;\n}\n\nexport const TerminationResultSchema = z.object({\n  terminate: z.boolean(),\n  reason: z.string(),\n});\n\n// ============================================================\n// BM25 CONFIGURATION\n// ============================================================\n\n/**\n * Stemmer types.\n */\nexport type StemmerType = 'porter' | 'snowball' | 'none';\n\n/**\n * BM25 core configuration.\n */\nexport interface BM25Config {\n  k1: number;                     // 1.2 - Term frequency saturation\n  b: number;                      // 0.75 - Document length normalization\n  min_term_length: number;        // 2\n  max_term_length: number;        // 50\n  max_doc_frequency_ratio: number; // 0.95\n  stemmer: StemmerType;\n  preserve_original: boolean;\n}\n\nexport const BM25ConfigSchema = z.object({\n  k1: z.number().positive(),\n  b: z.number().min(0).max(1),\n  min_term_length: z.number().int().positive(),\n  max_term_length: z.number().int().positive(),\n  max_doc_frequency_ratio: z.number().min(0).max(1),\n  stemmer: z.enum(['porter', 'snowball', 'none']),\n  preserve_original: z.boolean(),\n});\n\nexport const BM25_CONFIG: BM25Config = {\n  k1: 1.2,\n  b: 0.75,\n  min_term_length: 2,\n  max_term_length: 50,\n  max_doc_frequency_ratio: 0.95,\n  stemmer: 'porter',\n  preserve_original: true,\n};\n\n/**\n * Field types for boosting.\n */\nexport type FieldType = 'title' | 'tags' | 'headers' | 'body' | 'metadata';\n\n/**\n * Field boost configuration.\n */\nexport interface FieldBoost {\n  field: FieldType;\n  boost: number;\n}\n\nexport const FieldBoostSchema = z.object({\n  field: z.enum(['title', 'tags', 'headers', 'body', 'metadata']),\n  boost: z.number().positive(),\n});\n\nexport const FIELD_BOOSTS: FieldBoost[] = [\n  { field: 'title', boost: 3.0 },\n  { field: 'tags', boost: 2.5 },\n  { field: 'headers', boost: 2.0 },\n  { field: 'body', boost: 1.0 },\n  { field: 'metadata', boost: 0.5 },\n];\n\n/**\n * Stopwords behavior.\n */\nexport type StopwordsBehavior = 'remove_from_query' | 'remove_from_both' | 'keep_for_phrases';\n\n/**\n * Stopwords configuration.\n */\nexport interface StopwordsConfig {\n  language: string;\n  default_list: string[];\n  custom_additions: string[];\n  behavior: StopwordsBehavior;\n}\n\nexport const StopwordsConfigSchema = z.object({\n  language: z.string(),\n  default_list: z.array(z.string()),\n  custom_additions: z.array(z.string()),\n  behavior: z.enum(['remove_from_query', 'remove_from_both', 'keep_for_phrases']),\n});\n\nexport const STOPWORDS_CONFIG: StopwordsConfig = {\n  language: 'en',\n  default_list: [\n    'a', 'an', 'the',\n    'and', 'or', 'but',\n    'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'from', 'as',\n    'is', 'was', 'are', 'were', 'been', 'be',\n    'have', 'has', 'had',\n    'do', 'does', 'did',\n    'will', 'would', 'could', 'should', 'may', 'might', 'must', 'shall', 'can',\n    'this', 'that', 'these', 'those',\n    'i', 'you', 'he', 'she', 'it', 'we', 'they',\n    'what', 'which', 'who', 'whom', 'whose', 'where', 'when', 'why', 'how',\n  ],\n  custom_additions: [\n    'note', 'notes',\n    'idea', 'ideas',\n    'thought', 'thoughts',\n    'todo', 'item', 'entry',\n  ],\n  behavior: 'remove_from_query',\n};\n\n// ============================================================\n// MASTER ALGORITHM PARAMS\n// ============================================================\n\n/**\n * Master algorithm parameters aggregation.\n */\nexport interface AlgorithmParams {\n  reranking: {\n    weights: RerankingWeights;\n    config: RerankingConfig;\n  };\n  decay: {\n    config: DecayConfig;\n    initial_stability: Record<AlgorithmNodeType, number>;\n    initial_difficulty: Record<AlgorithmNodeType, number>;\n  };\n  ssa: {\n    params: SSAParams;\n    edge_weights: SSAEdgeWeights;\n  };\n  confidence: {\n    thresholds: ConfidenceThresholds;\n    rcs_weights: RCSWeights;\n  };\n  adaptive: {\n    budgets: Record<string, BudgetConfig>;\n    quality_targets: Record<string, QualityTarget>;\n    quality_weights: QualityWeights;\n    cold_start_threshold: number;\n    cold_start_limits: AdaptiveLimits;\n  };\n  bm25: {\n    config: BM25Config;\n    field_boosts: FieldBoost[];\n    stopwords: StopwordsConfig;\n  };\n}\n\n/**\n * The canonical algorithm parameters object.\n * This is THE single source of truth for all algorithm parameters.\n */\nexport const ALGORITHM_PARAMS: AlgorithmParams = {\n  reranking: {\n    weights: RERANKING_WEIGHTS,\n    config: RERANKING_CONFIG,\n  },\n  decay: {\n    config: DECAY_CONFIG,\n    initial_stability: INITIAL_STABILITY,\n    initial_difficulty: INITIAL_DIFFICULTY,\n  },\n  ssa: {\n    params: SSA_PARAMS,\n    edge_weights: SSA_EDGE_WEIGHTS,\n  },\n  confidence: {\n    thresholds: CONFIDENCE_THRESHOLDS,\n    rcs_weights: RCS_WEIGHTS,\n  },\n  adaptive: {\n    budgets: OPERATION_BUDGETS,\n    quality_targets: QUALITY_TARGETS,\n    quality_weights: QUALITY_WEIGHTS,\n    cold_start_threshold: COLD_START_THRESHOLD,\n    cold_start_limits: COLD_START_LIMITS,\n  },\n  bm25: {\n    config: BM25_CONFIG,\n    field_boosts: FIELD_BOOSTS,\n    stopwords: STOPWORDS_CONFIG,\n  },\n};\n\n// ============================================================\n// HELPER FUNCTIONS\n// ============================================================\n\n/**\n * Calculates days between two dates.\n */\nfunction daysBetween(start: Date, end: Date): number {\n  return Math.floor((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));\n}\n\n// ============================================================\n// RERANKING FUNCTIONS\n// ============================================================\n\n/**\n * Gets semantic score from node.\n */\nexport function semanticScore(node: ScoredNode): number {\n  return node.semantic_score ?? 0;\n}\n\n/**\n * Normalizes BM25 score against batch max.\n */\nexport function keywordScore(node: ScoredNode, maxBM25: number, candidateCount: number): number {\n  if (maxBM25 === 0) return 0.5;\n  if (candidateCount === 1) return 1.0;\n  return (node.bm25_score ?? 0) / maxBM25;\n}\n\n/**\n * Gets graph score from node.\n */\nexport function graphScore(node: ScoredNode): number {\n  return node.graph_score ?? 0;\n}\n\n/**\n * Calculates recency score using exponential decay.\n */\nexport function recencyScore(lastAccessed: Date, now: Date = new Date()): number {\n  const daysSince = daysBetween(lastAccessed, now);\n  return Math.exp(-daysSince / RERANKING_CONFIG.recency_half_life_days);\n}\n\n/**\n * Calculates authority score based on inbound edges.\n */\nexport function authorityScore(inboundEdges: number, avgInbound: number): number {\n  if (avgInbound === 0) return 0.5;\n  const ratio = inboundEdges / avgInbound;\n  return Math.min(ratio / RERANKING_CONFIG.authority_cap_multiple, 1.0);\n}\n\n/**\n * Calculates affinity score based on interaction history.\n */\nexport function affinityScore(\n  accessCount: number,\n  createdAt: Date,\n  lastAccessed: Date,\n  now: Date = new Date()\n): number {\n  const recency = recencyScore(lastAccessed, now);\n  const interactionScore = Math.tanh(accessCount / RERANKING_CONFIG.affinity_saturation) * recency;\n\n  const ageDays = daysBetween(createdAt, now);\n  const newContentBoost = ageDays < RERANKING_CONFIG.new_content_boost_days\n    ? RERANKING_CONFIG.new_content_boost_value\n    : 0;\n\n  return Math.min(interactionScore + newContentBoost, 1.0);\n}\n\n/**\n * Reranks candidates using all 6 signals.\n */\nexport function rerankCandidates(\n  candidates: ScoredNode[],\n  metrics: GraphMetrics,\n  weights: RerankingWeights = RERANKING_WEIGHTS,\n  now: Date = new Date()\n): RankedNode[] {\n  if (candidates.length === 0) return [];\n\n  const maxBM25 = Math.max(...candidates.map(c => c.bm25_score ?? 0));\n\n  return candidates.map(node => {\n    const breakdown: ScoreBreakdown = {\n      semantic: semanticScore(node),\n      keyword: keywordScore(node, maxBM25, candidates.length),\n      graph: graphScore(node),\n      recency: recencyScore(node.last_accessed, now),\n      authority: authorityScore(node.inbound_edge_count, metrics.avg_inbound_edges),\n      affinity: affinityScore(node.access_count, node.created_at, node.last_accessed, now),\n    };\n\n    const score =\n      weights.semantic * breakdown.semantic +\n      weights.keyword * breakdown.keyword +\n      weights.graph * breakdown.graph +\n      weights.recency * breakdown.recency +\n      weights.authority * breakdown.authority +\n      weights.affinity * breakdown.affinity;\n\n    const contributions = Object.entries(breakdown).map(([key, value]) => ({\n      key: key as keyof ScoreBreakdown,\n      contribution: weights[key as keyof RerankingWeights] * value\n    }));\n    const primary = contributions.reduce((a, b) =>\n      b.contribution > a.contribution ? b : a\n    ).key;\n\n    return { node, score, breakdown, primary_signal: primary };\n  }).sort((a, b) => b.score - a.score);\n}\n\n// ============================================================\n// DECAY FUNCTIONS\n// ============================================================\n\n/**\n * Calculates retrievability using exponential decay.\n * R = e^(-t/S)\n */\nexport function calculateRetrievability(daysSinceAccess: number, stability: number): number {\n  if (stability <= 0) return 0;\n  return Math.exp(-daysSinceAccess / stability);\n}\n\n/**\n * Calculates difficulty based on node characteristics.\n */\nexport function calculateDifficulty(\n  type: AlgorithmNodeType,\n  contentLength: number,\n  edgeCount: number\n): number {\n  const baseDifficulty = INITIAL_DIFFICULTY[type] ?? 0.3;\n  const lengthFactor = Math.min(contentLength / 5000, 1) * 0.15;\n  const abstractionFactor = type === 'concept' ? 0.1 : 0;\n  const connectionBonus = -Math.min(edgeCount / 40, 1) * 0.15;\n\n  return Math.max(0, Math.min(1,\n    baseDifficulty + lengthFactor + abstractionFactor + connectionBonus\n  ));\n}\n\n/**\n * Updates stability on access.\n */\nexport function updateStabilityOnAccess(stability: number, difficulty: number): number {\n  const difficultyFactor = 1 - (difficulty * 0.5);\n  return Math.min(\n    stability * DECAY_CONFIG.growth_rate * difficultyFactor,\n    DECAY_CONFIG.max_stability_days\n  );\n}\n\n/**\n * Gets decay lifecycle state based on retrievability.\n */\nexport function getDecayLifecycleState(retrievability: number, daysDormant: number): DecayLifecycleState {\n  if (retrievability > DECAY_CONFIG.active_threshold) return 'ACTIVE';\n  if (retrievability > DECAY_CONFIG.weak_threshold) return 'WEAK';\n  if (daysDormant < DECAY_CONFIG.dormant_days) return 'DORMANT';\n  if (daysDormant < DECAY_CONFIG.compress_days) return 'DORMANT';\n  if (daysDormant < DECAY_CONFIG.archive_days) return 'COMPRESS';\n  return 'ARCHIVE';\n}\n\n/**\n * Applies cascade decay to edge weight.\n */\nexport function applyCascadeDecay(edgeWeight: number, retrievability: number): number {\n  if (retrievability >= DECAY_CONFIG.weak_threshold) {\n    return edgeWeight;\n  }\n  return Math.max(edgeWeight * DECAY_CONFIG.cascade_factor, DECAY_CONFIG.edge_floor);\n}\n\n/**\n * Gets initial stability for a node type.\n */\nexport function getInitialStability(type: AlgorithmNodeType): number {\n  return INITIAL_STABILITY[type] ?? 14;\n}\n\n/**\n * Gets initial difficulty for a node type.\n */\nexport function getInitialDifficulty(type: AlgorithmNodeType): number {\n  return INITIAL_DIFFICULTY[type] ?? 0.3;\n}\n\n// ============================================================\n// CONFIDENCE FUNCTIONS\n// ============================================================\n\n/**\n * Calculates retrieval confidence using RCS.\n */\nexport function calculateRetrievalConfidence(\n  topScore: number,\n  secondScore: number | null,\n  resultCount: number,\n  hasAttribute: boolean\n): RetrievalConfidenceResult {\n  if (resultCount === 0) {\n    return {\n      score: 0,\n      level: 'LOW',\n      breakdown: { mq: 0, dt: 0, cm: 0 },\n      flags: ['no_results'],\n    };\n  }\n\n  const MQ = topScore;\n\n  const scoreGap = secondScore !== null ? topScore - secondScore : 1.0;\n  const gapNormalized = Math.min(scoreGap / 0.3, 1.0);\n  let focus: number;\n  if (resultCount === 1) focus = 1.0;\n  else if (resultCount <= 5) focus = 0.8;\n  else if (resultCount <= 15) focus = 0.5;\n  else focus = 0.3;\n  const DT = gapNormalized * 0.5 + focus * 0.5;\n\n  const CM = hasAttribute ? 1.0 : 0.5;\n\n  const MQ_safe = Math.max(MQ, 0.1);\n  const DT_safe = Math.max(DT, 0.1);\n  const CM_safe = Math.max(CM, 0.1);\n\n  let score = Math.pow(MQ_safe, RCS_WEIGHTS.match_quality) *\n              Math.pow(DT_safe, RCS_WEIGHTS.distinctiveness) *\n              Math.pow(CM_safe, RCS_WEIGHTS.completeness);\n\n  if (MQ < 0.3) score = Math.min(score, 0.4);\n  if (DT < 0.2) score = Math.min(score, 0.4);\n  if (!hasAttribute) score = Math.min(score, 0.7);\n\n  const flags: string[] = [];\n  if (resultCount > 1 && scoreGap < 0.15) flags.push('disambiguation_needed');\n  if (resultCount < 3 && MQ < 0.6) flags.push('sparse_results');\n  if (!hasAttribute) flags.push('attribute_unknown');\n  if (MQ > 0.95 && DT > 0.8 && hasAttribute) flags.push('perfect_match');\n\n  const level = getConfidenceLevel(score);\n\n  return { score, level, breakdown: { mq: MQ, dt: DT, cm: CM }, flags };\n}\n\n/**\n * Gets confidence level from score.\n */\nexport function getConfidenceLevel(score: number): ConfidenceLevel {\n  if (score >= CONFIDENCE_THRESHOLDS.retrieval.high) return 'HIGH';\n  if (score >= CONFIDENCE_THRESHOLDS.retrieval.medium) return 'MEDIUM';\n  return 'LOW';\n}\n\n/**\n * Detects contradiction between new and existing information.\n */\nexport function detectContradiction(\n  similarity: number,\n  logicalConflict: number,\n  daysSinceExisting: number\n): ContradictionResult {\n  const supersessionLikelihood = daysSinceExisting > 90 ? 0.3 : 0;\n\n  const score = Math.max(0, Math.min(1,\n    similarity * 0.4 + logicalConflict * 0.5 - supersessionLikelihood\n  ));\n\n  if (score >= CONFIDENCE_THRESHOLDS.contradiction.definite) {\n    return {\n      level: 'definite',\n      score,\n      action: 'flag_user',\n      explanation: `High conflict detected (${(score * 100).toFixed(0)}%): new info may contradict existing knowledge`,\n    };\n  }\n\n  if (score >= CONFIDENCE_THRESHOLDS.contradiction.possible) {\n    return {\n      level: 'possible',\n      score,\n      action: 'note_internal',\n      explanation: `Moderate conflict (${(score * 100).toFixed(0)}%): noted for potential review`,\n    };\n  }\n\n  return {\n    level: 'none',\n    score,\n    action: 'safe_to_store',\n    explanation: 'No significant conflict detected',\n  };\n}\n\n// ============================================================\n// ADAPTIVE LIMIT FUNCTIONS\n// ============================================================\n\n/**\n * Calculates adaptive limits based on graph characteristics.\n */\nexport function calculateAdaptiveLimits(\n  graphSize: number,\n  graphDensity: number,\n  queryType: QueryType\n): AdaptiveLimits {\n  if (graphSize < COLD_START_THRESHOLD) {\n    return {\n      ...COLD_START_LIMITS,\n      max_nodes: Math.min(COLD_START_LIMITS.max_nodes, Math.ceil(graphSize * 0.5)),\n    };\n  }\n\n  const entryPoints = Math.max(2, Math.min(5, Math.ceil(Math.log10(graphSize))));\n\n  let maxHops: number;\n  if (graphDensity < 0.001) maxHops = 5;\n  else if (graphDensity < 0.01) maxHops = 4;\n  else if (graphDensity < 0.05) maxHops = 3;\n  else maxHops = 2;\n\n  const percentageMap: Record<QueryType, number> = {\n    simple: 0.02,\n    standard: 0.05,\n    complex: 0.10,\n  };\n  const percentage = percentageMap[queryType];\n\n  const budgetKey = `${queryType}_query`;\n  const budgetLookup = OPERATION_BUDGETS[budgetKey];\n  const budget = budgetLookup ?? OPERATION_BUDGETS['standard_query']!;\n\n  const maxNodes = Math.max(\n    50,\n    Math.min(Math.ceil(graphSize * percentage), budget.max_nodes)\n  );\n\n  return { entry_points: entryPoints, max_hops: maxHops, max_nodes: maxNodes };\n}\n\n/**\n * Calculates quality score from components.\n */\nexport function calculateQualityScore(\n  coverage: number,\n  matchQuality: number,\n  convergence: number\n): number {\n  return (\n    coverage * QUALITY_WEIGHTS.coverage +\n    matchQuality * QUALITY_WEIGHTS.match_quality +\n    convergence * QUALITY_WEIGHTS.convergence\n  );\n}\n\n/**\n * Determines if search should terminate.\n */\nexport function shouldTerminate(\n  currentQuality: number,\n  targetQuality: number,\n  convergence: number,\n  lowConvergenceSteps: number,\n  remainingBudget: BudgetConfig\n): TerminationResult {\n  if (currentQuality >= targetQuality) {\n    return { terminate: true, reason: 'quality_target_met' };\n  }\n  if (convergence < 0.02 && lowConvergenceSteps >= 2) {\n    return { terminate: true, reason: 'converged' };\n  }\n  if (remainingBudget.time_ms <= 0) {\n    return { terminate: true, reason: 'time_exhausted' };\n  }\n  if (remainingBudget.max_nodes <= 0) {\n    return { terminate: true, reason: 'node_limit_reached' };\n  }\n  return { terminate: false, reason: '' };\n}\n\n/**\n * Gets budget for an operation.\n */\nexport function getBudgetForOperation(operation: string): BudgetConfig {\n  const budget = OPERATION_BUDGETS[operation];\n  return budget ?? OPERATION_BUDGETS['standard_query']!;\n}\n\n/**\n * Gets quality target for a query type.\n */\nexport function getQualityTargetForQueryType(queryType: string): QualityTarget {\n  const target = QUALITY_TARGETS[queryType];\n  return target ?? QUALITY_TARGETS['REASONING']!;\n}\n\n// ============================================================\n// BM25 FUNCTIONS\n// ============================================================\n\n/**\n * Gets effective stopwords set.\n */\nexport function getEffectiveStopwords(config: StopwordsConfig = STOPWORDS_CONFIG): Set<string> {\n  return new Set([...config.default_list, ...config.custom_additions]);\n}\n\n/**\n * Removes stopwords from tokens.\n */\nexport function removeStopwords(tokens: string[], stopwords: Set<string>): string[] {\n  return tokens.filter(token => !stopwords.has(token.toLowerCase()));\n}\n\n/**\n * Determines if a term should be indexed.\n */\nexport function shouldIndexTerm(\n  term: string,\n  docFrequency: number,\n  totalDocs: number,\n  config: BM25Config = BM25_CONFIG\n): boolean {\n  if (term.length < config.min_term_length) return false;\n  if (term.length > config.max_term_length) return false;\n  if (docFrequency < 1) return false;\n  if (totalDocs === 0) return docFrequency >= 1;\n  const frequencyRatio = docFrequency / totalDocs;\n  if (frequencyRatio > config.max_doc_frequency_ratio) return false;\n  return true;\n}\n\n/**\n * Gets field boost for a field type.\n */\nexport function getFieldBoost(field: FieldType): number {\n  const boost = FIELD_BOOSTS.find(fb => fb.field === field);\n  return boost?.boost ?? 1.0;\n}\n\n// ============================================================\n// VALIDATION FUNCTIONS\n// ============================================================\n\nexport function validateRerankingWeights(weights: unknown): weights is RerankingWeights {\n  return RerankingWeightsSchema.safeParse(weights).success;\n}\n\nexport function validateRerankingConfig(config: unknown): config is RerankingConfig {\n  return RerankingConfigSchema.safeParse(config).success;\n}\n\nexport function validateDecayConfig(config: unknown): config is DecayConfig {\n  return DecayConfigSchema.safeParse(config).success;\n}\n\nexport function validateSSAParams(params: unknown): params is SSAParams {\n  return SSAParamsSchema.safeParse(params).success;\n}\n\nexport function validateSSAEdgeWeights(weights: unknown): weights is SSAEdgeWeights {\n  return SSAEdgeWeightsSchema.safeParse(weights).success;\n}\n\nexport function validateConfidenceThresholds(thresholds: unknown): thresholds is ConfidenceThresholds {\n  return ConfidenceThresholdsSchema.safeParse(thresholds).success;\n}\n\nexport function validateBudgetConfig(config: unknown): config is BudgetConfig {\n  return BudgetConfigSchema.safeParse(config).success;\n}\n\nexport function validateAdaptiveLimits(limits: unknown): limits is AdaptiveLimits {\n  return AdaptiveLimitsSchema.safeParse(limits).success;\n}\n\nexport function validateBM25Config(config: unknown): config is BM25Config {\n  return BM25ConfigSchema.safeParse(config).success;\n}\n\nexport function validateQualityTarget(target: unknown): target is QualityTarget {\n  return QualityTargetSchema.safeParse(target).success;\n}\n\nexport function validateGraphMetrics(metrics: unknown): metrics is GraphMetrics {\n  return GraphMetricsSchema.safeParse(metrics).success;\n}\n","/**\n * @module @nous/core/qcs\n * @description Query Classification System\n * @version 1.0.0\n * @spec Brainstorms/Specs/Phase-3-Retrieval-Core/storm-008\n * @storm Brainstorms/Infrastructure/storm-008-query-classification\n *\n * This module implements storm-008: Query Classification System.\n *\n * Two-Stage Architecture:\n * 1. Disqualifier Check - Fast-fail patterns that always need Phase 2\n * 2. Two-Factor Analysis - Query Type + Retrieval Confidence System (RCS)\n *\n * Core Decision Rule:\n * LOOKUP query + HIGH confidence + no blocking flags = Skip Phase 2\n *\n * Key integrations:\n * - storm-005: SSAResult for retrieval context\n * - storm-028: RCS functions (calculateRetrievalConfidence, getConfidenceLevel)\n */\n\nimport { z } from 'zod';\nimport {\n  calculateRetrievalConfidence,\n  ConfidenceLevel,\n} from '../params';\n\n// ============================================================\n// CONSTANTS\n// ============================================================\n\n/**\n * Disqualifier categories for Stage 1.\n * Queries matching these patterns always require Phase 2.\n */\nexport const DISQUALIFIER_CATEGORIES = ['D1', 'D2', 'D3', 'D4', 'D5', 'D6'] as const;\nexport type DisqualifierCategory = (typeof DISQUALIFIER_CATEGORIES)[number];\n\n/**\n * Query types for classification.\n * LOOKUP: Seeking specific attribute from specific entity\n * AMBIGUOUS: Unclear what's being asked\n */\nexport const QCS_QUERY_TYPES = ['LOOKUP', 'AMBIGUOUS'] as const;\nexport type QCSQueryType = (typeof QCS_QUERY_TYPES)[number];\n\n/**\n * Skip decisions for Phase 2.\n * SKIP: Answer directly from Phase 1\n * SKIP_WITH_CAVEAT: Answer with uncertainty note\n * PHASE2: Proceed to LLM reasoning\n */\nexport const SKIP_DECISIONS = ['SKIP', 'SKIP_WITH_CAVEAT', 'PHASE2'] as const;\nexport type SkipDecision = (typeof SKIP_DECISIONS)[number];\n\n// ============================================================\n// DISQUALIFIER PATTERNS\n// ============================================================\n\n/**\n * D1: Reasoning keywords\n * Queries that require understanding relationships or explanations.\n */\nexport const D1_REASONING_PATTERNS: RegExp[] = [\n  /\\bhow does\\b/i,\n  /\\bhow do\\b/i,\n  /\\bhow is\\b/i,\n  /\\bwhy does\\b/i,\n  /\\bwhy is\\b/i,\n  /\\bwhy did\\b/i,\n  /\\brelate\\b/i,\n  /\\brelationship\\b/i,\n  /\\bconnection\\b/i,\n  /\\bcompare\\b/i,\n  /\\bcomparison\\b/i,\n  /\\bdifference\\b/i,\n  /\\bversus\\b/i,\n  /\\bvs\\b/i,\n  /\\bexplain\\b/i,\n  /\\bsummarize\\b/i,\n  /\\bdescribe\\b/i,\n  /\\bwhat do I know about\\b/i,\n  /\\btell me about\\b/i,\n];\n\n/**\n * D2: Negation patterns\n * Queries involving absence or exclusion.\n */\nexport const D2_NEGATION_PATTERNS: RegExp[] = [\n  /\\bnot in\\b/i,\n  /\\bnot included\\b/i,\n  /\\bmissing from\\b/i,\n  /\\bnever\\b/i,\n  /\\bwithout\\b/i,\n  /\\bexcept\\b/i,\n  /\\bwhat don't I\\b/i,\n  /\\bwhat haven't I\\b/i,\n];\n\n/**\n * D3: Time reference patterns\n * Queries involving temporal context.\n */\nexport const D3_TIME_PATTERNS: RegExp[] = [\n  // Relative time\n  /\\blast week\\b/i,\n  /\\byesterday\\b/i,\n  /\\brecently\\b/i,\n  /\\blast month\\b/i,\n  /\\blast year\\b/i,\n  /\\btoday\\b/i,\n  /\\bthis week\\b/i,\n  /\\bthis month\\b/i,\n  // Specific time\n  /\\bin (january|february|march|april|may|june|july|august|september|october|november|december)\\b/i,\n  /\\bon (monday|tuesday|wednesday|thursday|friday|saturday|sunday)\\b/i,\n  /\\bin \\d{4}\\b/i,\n  // Time ranges\n  /\\bbetween\\b/i,\n  /\\bfrom .+ to\\b/i,\n  /\\bduring\\b/i,\n];\n\n/**\n * D4: Compound query patterns\n * Multiple questions in one query.\n */\nexport const D4_COMPOUND_PATTERNS: RegExp[] = [\n  /\\?\\s*\\S+.*\\?/,  // Multiple question marks with content between\n  /\\band what\\b/i,\n  /\\band when\\b/i,\n  /\\band where\\b/i,\n  /\\band who\\b/i,\n  /\\band how\\b/i,\n  /\\band why\\b/i,\n  /\\balso\\b.*\\?/i,\n];\n\n/**\n * D5: Unresolved reference patterns\n * Pronouns or references without clear antecedent.\n */\nexport const D5_REFERENCE_PATTERNS: RegExp[] = [\n  /\\btheir\\b/i,\n  /\\bhis\\b/i,\n  /\\bher\\b/i,\n  /\\bits\\b/i,\n  /\\bthat\\b/i,\n  /\\bthis\\b/i,\n  /\\bthe same\\b/i,\n  /\\bthe other\\b/i,\n];\n\n/**\n * D6: Exploration signal patterns\n * Queries seeking discovery rather than retrieval.\n */\nexport const D6_EXPLORATION_PATTERNS: RegExp[] = [\n  /\\bwhat else\\b/i,\n  /\\banything related\\b/i,\n  /\\bmore about\\b/i,\n  /\\bsimilar to\\b/i,\n  /\\blike \\S+\\b/i,\n  /\\bbrainstorm\\b/i,\n  /\\bideas for\\b/i,\n  /\\bsuggest\\b/i,\n];\n\n/**\n * All disqualifier patterns grouped by category.\n */\nexport const DISQUALIFIER_PATTERNS: Record<DisqualifierCategory, RegExp[]> = {\n  D1: D1_REASONING_PATTERNS,\n  D2: D2_NEGATION_PATTERNS,\n  D3: D3_TIME_PATTERNS,\n  D4: D4_COMPOUND_PATTERNS,\n  D5: D5_REFERENCE_PATTERNS,\n  D6: D6_EXPLORATION_PATTERNS,\n};\n\n// ============================================================\n// LOOKUP PATTERNS\n// ============================================================\n\n/**\n * Patterns that indicate a LOOKUP query type.\n * Format: Entity + Attribute seeking patterns.\n */\nexport const LOOKUP_PATTERNS: RegExp[] = [\n  // \"What's X's Y?\"\n  /\\bwhat(?:'s|'s| is)\\s+(\\S+(?:\\s+\\S+)?)'s\\s+(\\S+)/i,\n  // \"What is X's Y?\"\n  /\\bwhat is\\s+(\\S+(?:\\s+\\S+)?)'s\\s+(\\S+)/i,\n  // \"X's Y?\"\n  /^(\\S+(?:\\s+\\S+)?)'s\\s+(\\S+)\\??$/i,\n  // \"Y for X?\"\n  /\\b(\\S+)\\s+for\\s+(\\S+(?:\\s+\\S+)?)\\??$/i,\n  // \"Who is X?\"\n  /\\bwho is\\s+(\\S+(?:\\s+\\S+)?)\\??$/i,\n  // \"Where is X?\"\n  /\\bwhere is\\s+(\\S+(?:\\s+\\S+)?)\\??$/i,\n  // \"When is X?\"\n  /\\bwhen is\\s+(\\S+(?:\\s+\\S+)?)\\??$/i,\n];\n\n/**\n * Keywords that boost LOOKUP confidence.\n * These indicate the user is seeking a specific attribute.\n */\nexport const ATTRIBUTE_KEYWORDS: string[] = [\n  'phone',\n  'email',\n  'address',\n  'birthday',\n  'number',\n  'date',\n  'name',\n  'title',\n  'location',\n  'id',\n  'link',\n  'url',\n  'contact',\n  'age',\n  'status',\n  'role',\n  'position',\n  'company',\n  'team',\n  'project',\n];\n\n// ============================================================\n// INTERFACES\n// ============================================================\n\n/**\n * Result of Stage 1 disqualifier check.\n */\nexport interface DisqualifierResult {\n  /** Whether the query is disqualified (requires Phase 2) */\n  disqualified: boolean;\n  /** Human-readable reason for disqualification */\n  reason?: string;\n  /** Which category matched */\n  category?: DisqualifierCategory;\n  /** The pattern that matched (for debugging) */\n  pattern?: string;\n}\n\nexport const DisqualifierResultSchema = z.object({\n  disqualified: z.boolean(),\n  reason: z.string().optional(),\n  category: z.enum(DISQUALIFIER_CATEGORIES).optional(),\n  pattern: z.string().optional(),\n});\n\n/**\n * Result of Stage 2a query type classification.\n */\nexport interface QueryTypeResult {\n  /** Classified query type */\n  type: QCSQueryType;\n  /** Extracted entity name(s) if LOOKUP */\n  entity?: string;\n  /** Extracted attribute being sought if LOOKUP */\n  attribute?: string;\n  /** Confidence in classification (0-1) */\n  confidence: number;\n}\n\nexport const QueryTypeResultSchema = z.object({\n  type: z.enum(QCS_QUERY_TYPES),\n  entity: z.string().optional(),\n  attribute: z.string().optional(),\n  confidence: z.number().min(0).max(1),\n});\n\n/**\n * Complete classification result.\n */\nexport interface ClassificationResult {\n  /** Original query */\n  query: string;\n  /** Classified query type */\n  queryType: QueryTypeResult;\n  /** Retrieval Confidence System result */\n  rcs: {\n    score: number;\n    level: ConfidenceLevel;\n    flags: string[];\n  };\n  /** Final decision */\n  decision: SkipDecision;\n  /** Explanation of decision */\n  explanation: string;\n  /** Handoff metadata if proceeding to Phase 2 */\n  handoff?: Phase2HandoffMetadata;\n}\n\nexport const ClassificationResultSchema = z.object({\n  query: z.string(),\n  queryType: QueryTypeResultSchema,\n  rcs: z.object({\n    score: z.number().min(0).max(1),\n    level: z.enum(['HIGH', 'MEDIUM', 'LOW']),\n    flags: z.array(z.string()),\n  }),\n  decision: z.enum(SKIP_DECISIONS),\n  explanation: z.string(),\n  handoff: z.lazy(() => Phase2HandoffMetadataSchema).optional(),\n});\n\n/**\n * Classification reason codes for Phase 2 handoff.\n */\nexport const CLASSIFICATION_REASONS = [\n  'reasoning_query',\n  'low_confidence',\n  'no_answer_found',\n  'disambiguation',\n  'compound_query',\n  'time_reference',\n  'exploration',\n  'unresolved_reference',\n  'negation_query',\n  'ambiguous_query',\n] as const;\nexport type ClassificationReason = (typeof CLASSIFICATION_REASONS)[number];\n\n/**\n * Metadata passed to Phase 2 when not skipping.\n */\nexport interface Phase2HandoffMetadata {\n  /** Why Phase 2 is needed */\n  classification_reason: ClassificationReason;\n  /** Phase 1 retrieval results (node IDs and scores) */\n  phase1_results: Array<{\n    node_id: string;\n    score: number;\n  }>;\n  /** Query analysis details */\n  query_analysis: {\n    type: QCSQueryType;\n    entities: string[];\n    attribute: string | null;\n    confidence: number;\n  };\n}\n\nexport const Phase2HandoffMetadataSchema = z.object({\n  classification_reason: z.enum(CLASSIFICATION_REASONS),\n  phase1_results: z.array(z.object({\n    node_id: z.string(),\n    score: z.number().min(0).max(1),\n  })).max(100),\n  query_analysis: z.object({\n    type: z.enum(QCS_QUERY_TYPES),\n    entities: z.array(z.string()).max(20),\n    attribute: z.string().nullable(),\n    confidence: z.number().min(0).max(1),\n  }),\n});\n\n/**\n * Configuration for QCS.\n */\nexport interface QCSConfig {\n  /** Enable debug logging */\n  debug?: boolean;\n  /** Custom disqualifier patterns to add */\n  customDisqualifiers?: RegExp[];\n  /** Custom lookup patterns to add */\n  customLookupPatterns?: RegExp[];\n}\n\nexport const QCSConfigSchema = z.object({\n  debug: z.boolean().optional(),\n  customDisqualifiers: z.array(z.instanceof(RegExp)).optional(),\n  customLookupPatterns: z.array(z.instanceof(RegExp)).optional(),\n});\n\n// ============================================================\n// SSA RESULT TYPE (minimal interface for QCS)\n// ============================================================\n\n/**\n * Minimal SSA result interface for QCS.\n * Full type is in @nous/core/ssa.\n */\nexport interface SSAResultForQCS {\n  relevant_nodes: Array<{\n    node_id: string;\n    score: number;\n  }>;\n  metrics: {\n    nodes_returned: number;\n  };\n}\n\n// ============================================================\n// UTILITY FUNCTIONS\n// ============================================================\n\n/**\n * Get disqualifier category description.\n */\nexport function getDisqualifierDescription(category: DisqualifierCategory): string {\n  const descriptions: Record<DisqualifierCategory, string> = {\n    D1: 'Reasoning query (how/why/explain)',\n    D2: 'Negation query (not/never/except)',\n    D3: 'Time reference (last week/in September)',\n    D4: 'Compound query (multiple questions)',\n    D5: 'Unresolved reference (their/his/it)',\n    D6: 'Exploration query (what else/similar to)',\n  };\n  return descriptions[category];\n}\n\n/**\n * Map disqualifier category to classification reason.\n */\nexport function categoryToReason(category: DisqualifierCategory): ClassificationReason {\n  const mapping: Record<DisqualifierCategory, ClassificationReason> = {\n    D1: 'reasoning_query',\n    D2: 'negation_query',\n    D3: 'time_reference',\n    D4: 'compound_query',\n    D5: 'unresolved_reference',\n    D6: 'exploration',\n  };\n  return mapping[category];\n}\n\n/**\n * Check if a flag blocks skipping Phase 2.\n */\nexport function isBlockingFlag(flag: string): boolean {\n  const blockingFlags = [\n    'disambiguation_needed',\n    'sparse_results',\n    'no_results',\n  ];\n  return blockingFlags.includes(flag);\n}\n\n/**\n * Generate decision explanation.\n */\nexport function generateDecisionExplanation(\n  decision: SkipDecision,\n  queryType: QCSQueryType,\n  rcsLevel: ConfidenceLevel,\n  flags: string[],\n  disqualified?: DisqualifierCategory\n): string {\n  if (disqualified) {\n    return `Query disqualified by ${disqualified}: ${getDisqualifierDescription(disqualified)}. Proceeding to Phase 2.`;\n  }\n\n  if (queryType === 'AMBIGUOUS') {\n    return 'Query type is AMBIGUOUS. Proceeding to Phase 2 for clarification.';\n  }\n\n  const blockingFlags = flags.filter(isBlockingFlag);\n  if (blockingFlags.length > 0) {\n    return `LOOKUP query with ${rcsLevel} confidence, but blocked by: ${blockingFlags.join(', ')}. Proceeding to Phase 2.`;\n  }\n\n  switch (decision) {\n    case 'SKIP':\n      return `LOOKUP query with HIGH confidence and no blocking flags. Answering directly from Phase 1.`;\n    case 'SKIP_WITH_CAVEAT':\n      return `LOOKUP query with MEDIUM confidence. Answering with uncertainty note.`;\n    case 'PHASE2':\n      return `LOOKUP query with ${rcsLevel} confidence. Proceeding to Phase 2 for verification.`;\n    default:\n      return `Decision: ${decision}`;\n  }\n}\n\n// ============================================================\n// STAGE 1: DISQUALIFIER CHECK\n// ============================================================\n\n/**\n * Stage 1: Check if query matches any disqualifier patterns.\n * @param query - The user query to check\n * @returns Disqualifier result with match details\n */\nexport function checkDisqualifiers(query: string): DisqualifierResult {\n  // Check each category in order\n  for (const category of DISQUALIFIER_CATEGORIES) {\n    const patterns = DISQUALIFIER_PATTERNS[category];\n    for (const pattern of patterns) {\n      if (pattern.test(query)) {\n        return {\n          disqualified: true,\n          reason: getDisqualifierDescription(category),\n          category,\n          pattern: pattern.source,\n        };\n      }\n    }\n  }\n\n  return { disqualified: false };\n}\n\n// ============================================================\n// STAGE 2: QUERY TYPE CLASSIFICATION\n// ============================================================\n\n/**\n * Clean extracted value by removing trailing punctuation.\n */\nfunction cleanExtractedValue(value: string | undefined): string | undefined {\n  if (!value) return undefined;\n  // Remove trailing punctuation (?, !, ., etc.)\n  return value.replace(/[?!.,;:]+$/, '').trim();\n}\n\n/**\n * Stage 2a: Classify query as LOOKUP or AMBIGUOUS.\n * @param query - The user query to classify\n * @returns Classification with entity/attribute extraction\n */\nexport function classifyQueryType(query: string): QueryTypeResult {\n  // Try each LOOKUP pattern\n  for (const pattern of LOOKUP_PATTERNS) {\n    const match = query.match(pattern);\n    if (match) {\n      // Extract entity and attribute from match groups\n      const entity = cleanExtractedValue(match[1]?.trim());\n      const attribute = cleanExtractedValue(match[2]?.trim());\n\n      // Calculate confidence based on specificity\n      let confidence = 0.7; // Base confidence for pattern match\n\n      // Boost if attribute is a known keyword\n      if (attribute && ATTRIBUTE_KEYWORDS.some(kw =>\n        attribute.toLowerCase().includes(kw.toLowerCase())\n      )) {\n        confidence = Math.min(confidence + 0.15, 1.0);\n      }\n\n      // Boost if query ends with question mark\n      if (query.trim().endsWith('?')) {\n        confidence = Math.min(confidence + 0.05, 1.0);\n      }\n\n      // Boost if query is short (more specific)\n      if (query.length < 50) {\n        confidence = Math.min(confidence + 0.05, 1.0);\n      }\n\n      return {\n        type: 'LOOKUP',\n        entity: entity || undefined,\n        attribute: attribute || undefined,\n        confidence,\n      };\n    }\n  }\n\n  // Check for attribute keywords even without pattern match\n  const hasAttributeKeyword = ATTRIBUTE_KEYWORDS.some(kw =>\n    query.toLowerCase().includes(kw.toLowerCase())\n  );\n\n  if (hasAttributeKeyword) {\n    // Try to extract entity from simple queries like \"John's phone\"\n    const simpleMatch = query.match(/(\\S+(?:\\s+\\S+)?)'s\\s+(\\S+)/i);\n    if (simpleMatch) {\n      return {\n        type: 'LOOKUP',\n        entity: cleanExtractedValue(simpleMatch[1]?.trim()),\n        attribute: cleanExtractedValue(simpleMatch[2]?.trim()),\n        confidence: 0.6,\n      };\n    }\n\n    return {\n      type: 'LOOKUP',\n      attribute: ATTRIBUTE_KEYWORDS.find(kw =>\n        query.toLowerCase().includes(kw.toLowerCase())\n      ),\n      confidence: 0.5,\n    };\n  }\n\n  // Default to AMBIGUOUS\n  return {\n    type: 'AMBIGUOUS',\n    confidence: 0.3,\n  };\n}\n\n/**\n * Extract entity names from query.\n * @param query - The user query\n * @returns Array of extracted entity names\n */\nexport function extractQueryEntities(query: string): string[] {\n  const entities: string[] = [];\n\n  // Try possessive patterns - match just the word(s) immediately before 's\n  // Use a more precise pattern that captures only proper word boundaries\n  const possessiveMatches = query.matchAll(/(?:^|\\s)(\\w+)'s\\s+/gi);\n  for (const match of possessiveMatches) {\n    const cleaned = cleanExtractedValue(match[1]);\n    if (cleaned) {\n      entities.push(cleaned);\n    }\n  }\n\n  // Try \"for X\" patterns - capture word chars only\n  const forMatches = query.matchAll(/\\bfor\\s+(\\w+(?:\\s+\\w+)?)\\b/gi);\n  for (const match of forMatches) {\n    const cleaned = cleanExtractedValue(match[1]);\n    if (cleaned) {\n      entities.push(cleaned);\n    }\n  }\n\n  // Try \"who/where/when is X\" patterns - capture word chars only\n  const isMatches = query.matchAll(/\\b(?:who|where|when) is\\s+(\\w+(?:\\s+\\w+)?)\\b/gi);\n  for (const match of isMatches) {\n    const cleaned = cleanExtractedValue(match[1]);\n    if (cleaned) {\n      entities.push(cleaned);\n    }\n  }\n\n  // Deduplicate\n  return [...new Set(entities)];\n}\n\n/**\n * Extract sought attribute from query.\n * @param query - The user query\n * @returns Attribute name or null\n */\nexport function extractQueryAttribute(query: string): string | null {\n  // Check for possessive pattern: \"X's Y\" - capture word chars\n  const possessiveMatch = query.match(/\\S+'s\\s+(\\w+)/i);\n  if (possessiveMatch?.[1]) {\n    return cleanExtractedValue(possessiveMatch[1].trim()) ?? null;\n  }\n\n  // Check for \"Y for X\" pattern\n  const forMatch = query.match(/^(\\w+)\\s+for\\s+/i);\n  if (forMatch?.[1]) {\n    return cleanExtractedValue(forMatch[1].trim()) ?? null;\n  }\n\n  // Check for known attribute keywords\n  for (const keyword of ATTRIBUTE_KEYWORDS) {\n    if (query.toLowerCase().includes(keyword.toLowerCase())) {\n      return keyword;\n    }\n  }\n\n  return null;\n}\n\n// ============================================================\n// MAIN CLASSIFICATION FUNCTION\n// ============================================================\n\n/**\n * Main entry point: Complete query classification.\n * @param query - The user query\n * @param ssaResult - Results from SSA retrieval\n * @param config - Optional configuration\n * @returns Complete classification result\n */\nexport function classifyQuery(\n  query: string,\n  ssaResult: SSAResultForQCS,\n  _config?: QCSConfig\n): ClassificationResult {\n  // Stage 1: Disqualifier check\n  const disqualifierResult = checkDisqualifiers(query);\n\n  // Stage 2a: Query type classification\n  const queryTypeResult = classifyQueryType(query);\n\n  // Stage 2b: Entity/attribute extraction\n  const entities = extractQueryEntities(query);\n  const attribute = extractQueryAttribute(query);\n\n  // Stage 2c: Calculate RCS from SSA results\n  const relevantNodes = ssaResult.relevant_nodes;\n  const topScore = relevantNodes[0]?.score ?? 0;\n  const secondScore = relevantNodes.length > 1 ? relevantNodes[1]?.score ?? null : null;\n  const resultCount = relevantNodes.length;\n  const hasAttribute = attribute !== null;\n\n  const rcsResult = calculateRetrievalConfidence(\n    topScore,\n    secondScore,\n    resultCount,\n    hasAttribute\n  );\n\n  // Stage 3: Decision matrix\n  let decision: SkipDecision;\n  let classificationReason: ClassificationReason | undefined;\n\n  if (disqualifierResult.disqualified) {\n    // Disqualified queries always go to Phase 2\n    decision = 'PHASE2';\n    classificationReason = disqualifierResult.category\n      ? categoryToReason(disqualifierResult.category)\n      : 'reasoning_query';\n  } else if (queryTypeResult.type === 'AMBIGUOUS') {\n    // Ambiguous queries always go to Phase 2\n    decision = 'PHASE2';\n    classificationReason = 'ambiguous_query';\n  } else if (resultCount === 0) {\n    // No results\n    decision = 'PHASE2';\n    classificationReason = 'no_answer_found';\n  } else if (rcsResult.flags.some(isBlockingFlag)) {\n    // Blocking flags force Phase 2\n    decision = 'PHASE2';\n    if (rcsResult.flags.includes('disambiguation_needed')) {\n      classificationReason = 'disambiguation';\n    } else if (rcsResult.flags.includes('no_results')) {\n      classificationReason = 'no_answer_found';\n    } else {\n      classificationReason = 'low_confidence';\n    }\n  } else {\n    // Apply decision matrix based on confidence level\n    switch (rcsResult.level) {\n      case 'HIGH':\n        decision = 'SKIP';\n        break;\n      case 'MEDIUM':\n        decision = 'SKIP_WITH_CAVEAT';\n        break;\n      case 'LOW':\n      default:\n        decision = 'PHASE2';\n        classificationReason = 'low_confidence';\n        break;\n    }\n  }\n\n  // Generate explanation\n  const explanation = generateDecisionExplanation(\n    decision,\n    queryTypeResult.type,\n    rcsResult.level,\n    rcsResult.flags,\n    disqualifierResult.category\n  );\n\n  // Build result\n  const result: ClassificationResult = {\n    query,\n    queryType: queryTypeResult,\n    rcs: {\n      score: rcsResult.score,\n      level: rcsResult.level,\n      flags: rcsResult.flags,\n    },\n    decision,\n    explanation,\n  };\n\n  // Add handoff metadata if proceeding to Phase 2\n  if (decision === 'PHASE2' && classificationReason) {\n    result.handoff = buildPhase2Handoff(\n      classificationReason,\n      relevantNodes,\n      queryTypeResult,\n      entities,\n      attribute\n    );\n  }\n\n  return result;\n}\n\n/**\n * Decision helper: Determine skip decision from classification.\n * @param classification - Complete classification result\n * @returns Skip decision (SKIP, SKIP_WITH_CAVEAT, or PHASE2)\n */\nexport function shouldSkipPhase2(classification: ClassificationResult): SkipDecision {\n  return classification.decision;\n}\n\n/**\n * Build Phase 2 handoff metadata.\n * @param reason - Why Phase 2 is needed\n * @param relevantNodes - Phase 1 results\n * @param queryType - Query classification\n * @param entities - Extracted entities\n * @param attribute - Extracted attribute\n * @returns Handoff metadata for Phase 2\n */\nexport function buildPhase2Handoff(\n  reason: ClassificationReason,\n  relevantNodes: Array<{ node_id: string; score: number }>,\n  queryType: QueryTypeResult,\n  entities: string[],\n  attribute: string | null\n): Phase2HandoffMetadata {\n  return {\n    classification_reason: reason,\n    phase1_results: relevantNodes.slice(0, 100).map(n => ({\n      node_id: n.node_id,\n      score: n.score,\n    })),\n    query_analysis: {\n      type: queryType.type,\n      entities,\n      attribute,\n      confidence: queryType.confidence,\n    },\n  };\n}\n\n// ============================================================\n// VALIDATION FUNCTIONS\n// ============================================================\n\nexport function validateDisqualifierResult(result: unknown): result is DisqualifierResult {\n  return DisqualifierResultSchema.safeParse(result).success;\n}\n\nexport function validateQueryTypeResult(result: unknown): result is QueryTypeResult {\n  return QueryTypeResultSchema.safeParse(result).success;\n}\n\nexport function validateClassificationResult(result: unknown): result is ClassificationResult {\n  return ClassificationResultSchema.safeParse(result).success;\n}\n\nexport function validatePhase2HandoffMetadata(metadata: unknown): metadata is Phase2HandoffMetadata {\n  return Phase2HandoffMetadataSchema.safeParse(metadata).success;\n}\n\nexport function validateQCSConfig(config: unknown): config is QCSConfig {\n  return QCSConfigSchema.safeParse(config).success;\n}\n"]}