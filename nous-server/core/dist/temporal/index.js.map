{"version":3,"sources":["../../src/constants.ts","../../src/temporal/index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/**\n * @module @nous/core/constants\n * @description All constants, enums, and configuration values\n * @version 0.1.0\n * @spec Brainstorms/Specs/storm-011/spec/constants.ts\n */\n\n// ============================================================\n// ID CONFIGURATION\n// ============================================================\n\n/** Length of nanoid for globally unique IDs */\nexport const NANOID_LENGTH = 12;\n\n/** Prefix for node IDs: \"n_\" + nanoid(12) */\nexport const NODE_ID_PREFIX = 'n_';\n\n/** Prefix for block IDs: \"b_\" + nanoid(12) */\nexport const BLOCK_ID_PREFIX = 'b_';\n\n/** Prefix for edge IDs: \"e_\" + nanoid(12) */\nexport const EDGE_ID_PREFIX = 'e_';\n\n/** Prefix for edit record IDs: \"edit_\" + nanoid(12) */\nexport const EDIT_ID_PREFIX = 'edit_';\n\n// ============================================================\n// NODE TYPES\n// ============================================================\n\nexport const NODE_TYPES = [\n  'concept',\n  'episode',\n  'document',\n  'section',\n  'chunk',\n  'note',\n  'raw',\n] as const;\n\nexport type NodeType = (typeof NODE_TYPES)[number];\n\nexport const SEMANTIC_LAYER_TYPES: NodeType[] = ['concept', 'note', 'chunk'];\nexport const EPISODE_LAYER_TYPES: NodeType[] = ['episode', 'document', 'section'];\nexport const ARCHIVE_LAYER_TYPES: NodeType[] = ['raw'];\n\n// ============================================================\n// SUBTYPES\n// ============================================================\n\nexport const CONCEPT_SUBTYPES = [\n  'fact',\n  'definition',\n  'relationship',\n  'preference',\n  'belief',\n  'procedure',\n  'entity',\n  'event',\n  'insight',\n] as const;\n\nexport type ConceptSubtype = (typeof CONCEPT_SUBTYPES)[number] | `custom:${string}`;\n\nexport const EPISODE_SUBTYPES = [\n  'lecture',\n  'meeting',\n  'conversation',\n  'note_session',\n  'document_read',\n  'thought',\n  'external_event',\n] as const;\n\nexport type EpisodeSubtype = (typeof EPISODE_SUBTYPES)[number] | `custom:${string}`;\n\nexport const RAW_SUBTYPES = [\n  'transcript',\n  'document',\n  'note',\n  'image',\n  'audio_recording',\n] as const;\n\nexport type RawSubtype = (typeof RAW_SUBTYPES)[number];\n\n// ============================================================\n// BLOCK TYPES\n// ============================================================\n\nexport const BLOCK_TYPES = [\n  'paragraph',\n  'heading',\n  'list',\n  'list_item',\n  'code',\n  'quote',\n  'callout',\n  'divider',\n  'table',\n  'image',\n] as const;\n\nexport type BlockType = (typeof BLOCK_TYPES)[number];\n\n// ============================================================\n// EDGE TYPES\n// ============================================================\n\nexport const EDGE_TYPES = [\n  'relates_to',\n  'part_of',\n  'mentioned_in',\n  'causes',\n  'precedes',\n  'contradicts',\n  'supersedes',\n  'derived_from',\n  'similar_to',\n] as const;\n\nexport type EdgeType = (typeof EDGE_TYPES)[number];\n\n// ============================================================\n// LIFECYCLE STATES\n// ============================================================\n\nexport const LIFECYCLE_STATES = [\n  'working',\n  'active',\n  'superseded',\n  'dormant',\n  'archived',\n] as const;\n\nexport type LifecycleState = (typeof LIFECYCLE_STATES)[number];\n\n// ============================================================\n// SOURCE TYPES\n// ============================================================\n\nexport const SOURCE_TYPES = [\n  'extraction',\n  'manual',\n  'inference',\n  'import',\n] as const;\n\nexport type SourceType = (typeof SOURCE_TYPES)[number];\n\n// ============================================================\n// CONTENT SOURCES\n// ============================================================\n\nexport const CONTENT_SOURCES = [\n  'import',\n  'user_note',\n  'chat_extraction',\n  'fact',\n  'document',\n  'transcript',\n] as const;\n\nexport type ContentSource = (typeof CONTENT_SOURCES)[number];\n\n// ============================================================\n// EDIT SYSTEM\n// ============================================================\n\nexport const EDIT_TARGET_METHODS = [\n  'block_id',\n  'heading',\n  'position',\n  'search',\n  'full',\n] as const;\n\nexport type EditTargetMethod = (typeof EDIT_TARGET_METHODS)[number];\n\nexport const EDIT_ACTIONS = ['replace', 'insert', 'append', 'delete'] as const;\n\nexport type EditAction = (typeof EDIT_ACTIONS)[number];\n\nexport const MODIFIERS = ['user', 'ai', 'system', 'sync'] as const;\n\nexport type Modifier = (typeof MODIFIERS)[number];\n\nexport const EDIT_HISTORY_RETENTION = {\n  maxEdits: 100,\n  maxAgeDays: 30,\n  undoWindowHours: 24,\n  pruneSchedule: 'daily',\n} as const;\n\n// ============================================================\n// TEMPORAL\n// ============================================================\n\nexport const TEMPORAL_GRANULARITIES = [\n  'minute',\n  'hour',\n  'day',\n  'week',\n  'month',\n  'year',\n] as const;\n\nexport type TemporalGranularity = (typeof TEMPORAL_GRANULARITIES)[number];\n\nexport const EVENT_TIME_SOURCES = ['explicit', 'inferred', 'user_stated'] as const;\n\nexport type EventTimeSource = (typeof EVENT_TIME_SOURCES)[number];\n\nexport const CONTENT_TIME_TYPES = ['historical', 'relative', 'approximate'] as const;\n\nexport type ContentTimeType = (typeof CONTENT_TIME_TYPES)[number];\n\n// ============================================================\n// PROCESSING PATHS\n// ============================================================\n\nexport const INPUT_TYPES = [\n  'DOCUMENT',\n  'TRANSCRIPT',\n  'CONVERSATION',\n  'NOTE',\n  'IMPORT',\n] as const;\n\nexport type InputType = (typeof INPUT_TYPES)[number];\n\nexport const INPUT_SIZES = ['tiny', 'small', 'medium', 'large', 'huge'] as const;\n\nexport type InputSize = (typeof INPUT_SIZES)[number];\n\nexport const PROCESSING_PATHS = [\n  'fast',\n  'standard',\n  'progressive',\n  'conversation',\n] as const;\n\nexport type ProcessingPath = (typeof PROCESSING_PATHS)[number];\n\nexport const SIZE_THRESHOLDS = {\n  tiny: { min: 0, max: 50 },\n  small: { min: 50, max: 500 },\n  medium: { min: 500, max: 5000 },\n  large: { min: 5000, max: 25000 },\n  huge: { min: 25000, max: Infinity },\n} as const;\n\n// ============================================================\n// BLOCK DECISION THRESHOLDS\n// ============================================================\n\nexport const BLOCK_LENGTH_THRESHOLD = 1000;\nexport const BLOCK_LIST_THRESHOLD = 3;\n\n// ============================================================\n// NEURAL DEFAULTS\n// ============================================================\n\nexport const NEURAL_DEFAULTS = {\n  stability: 0.5,\n  retrievability: 1.0,\n  accessCount: 0,\n} as const;\n\n// ============================================================\n// EXTRACTION DEPTH\n// ============================================================\n\nexport const EXTRACTION_DEPTHS = ['summary', 'section', 'full'] as const;\n\nexport type ExtractionDepth = (typeof EXTRACTION_DEPTHS)[number];\n\n// ============================================================\n// REGEX PATTERNS\n// ============================================================\n\nexport const HEADING_PATTERN = /^#{1,6}\\s/m;\nexport const LIST_ITEM_PATTERN = /^[-*]\\s/gm;\n","/**\n * @module @nous/core/temporal\n * @description Four-type temporal model for time handling\n * @version 0.1.0\n * @spec Brainstorms/Specs/storm-011/spec/temporal-model.ts\n *\n * Nous distinguishes FOUR types of time:\n * 1. Ingestion time - When user added content to Nous\n * 2. Event time - When the event actually happened\n * 3. Content times - Times mentioned IN the content\n * 4. Reference patterns - How user typically recalls it\n */\n\nimport { z } from 'zod';\nimport {\n  EVENT_TIME_SOURCES,\n  CONTENT_TIME_TYPES,\n  type EventTimeSource,\n  type ContentTimeType,\n  type TemporalGranularity,\n} from '../constants';\n\n// ============================================================\n// INGESTION TIME\n// ============================================================\n\n/**\n * When the user added this content to Nous.\n * This is always known with certainty.\n */\nexport interface IngestionTime {\n  /** When content was added (ISO 8601) */\n  timestamp: string;\n  /** User's timezone when they added it */\n  timezone: string;\n}\n\nexport const IngestionTimeSchema = z.object({\n  timestamp: z.string().datetime(),\n  timezone: z.string(),\n});\n\n// ============================================================\n// EVENT TIME\n// ============================================================\n\n/**\n * When the event actually happened (if different from ingestion).\n */\nexport interface EventTime {\n  /** When the event occurred (ISO 8601) */\n  timestamp: string;\n  /** Confidence in this timestamp (0-1) */\n  confidence: number;\n  /** How this time was determined */\n  source: EventTimeSource;\n}\n\nexport const EventTimeSchema = z.object({\n  timestamp: z.string().datetime(),\n  confidence: z.number().min(0).max(1),\n  source: z.enum(EVENT_TIME_SOURCES),\n});\n\n// ============================================================\n// CONTENT TIME\n// ============================================================\n\n/**\n * A time mentioned WITHIN the content itself.\n */\nexport interface ContentTime {\n  /** Original text mentioning time */\n  text: string;\n  /** Resolved timestamp (ISO 8601) */\n  resolved: string;\n  /** Type of time reference */\n  type: ContentTimeType;\n  /** Confidence in the resolution (0-1) */\n  confidence: number;\n}\n\nexport const ContentTimeSchema = z.object({\n  text: z.string(),\n  resolved: z.string().datetime(),\n  type: z.enum(CONTENT_TIME_TYPES),\n  confidence: z.number().min(0).max(1),\n});\n\n// ============================================================\n// TEMPORAL MODEL\n// ============================================================\n\n/**\n * Complete temporal model for a node.\n * Implements the four-type system from storm-011 v2.\n */\nexport interface TemporalModel {\n  /** When user added this to Nous. ALWAYS present. */\n  ingestion: IngestionTime;\n  /** When the event happened. Present for episodes and time-anchored content. */\n  event?: EventTime;\n  /** Times mentioned IN the content. Extracted during processing. */\n  content_times?: ContentTime[];\n  /** How user typically refers to this. Built from access patterns. */\n  reference_patterns?: string[];\n}\n\nexport const TemporalModelSchema = z.object({\n  ingestion: IngestionTimeSchema,\n  event: EventTimeSchema.optional(),\n  content_times: z.array(ContentTimeSchema).optional(),\n  reference_patterns: z.array(z.string()).optional(),\n});\n\n// ============================================================\n// TEMPORAL CONFIDENCE\n// ============================================================\n\n/**\n * Three-factor temporal confidence from storm-004.\n */\nexport interface TemporalConfidence {\n  /** Confidence in time source */\n  source: number;\n  /** Confidence in granularity */\n  granularity: number;\n  /** Confidence in interpretation */\n  interpretation: number;\n  /** Combined score: source × granularity × interpretation */\n  combined: number;\n}\n\nexport const TemporalConfidenceSchema = z.object({\n  source: z.number().min(0).max(1),\n  granularity: z.number().min(0).max(1),\n  interpretation: z.number().min(0).max(1),\n  combined: z.number().min(0).max(1),\n});\n\n// ============================================================\n// FACTORY FUNCTIONS\n// ============================================================\n\n/**\n * Creates a basic temporal model for new content.\n */\nexport function createTemporalModel(timezone?: string): TemporalModel {\n  return {\n    ingestion: {\n      timestamp: new Date().toISOString(),\n      timezone: timezone ?? Intl.DateTimeFormat().resolvedOptions().timeZone,\n    },\n  };\n}\n\n/**\n * Adds event time to a temporal model.\n */\nexport function addEventTime(\n  temporal: TemporalModel,\n  eventTimestamp: string | Date,\n  source: EventTimeSource,\n  confidence: number = 1.0\n): TemporalModel {\n  return {\n    ...temporal,\n    event: {\n      timestamp:\n        typeof eventTimestamp === 'string'\n          ? eventTimestamp\n          : eventTimestamp.toISOString(),\n      source,\n      confidence,\n    },\n  };\n}\n\n/**\n * Adds a content time reference.\n */\nexport function addContentTime(\n  temporal: TemporalModel,\n  contentTime: ContentTime\n): TemporalModel {\n  return {\n    ...temporal,\n    content_times: [...(temporal.content_times ?? []), contentTime],\n  };\n}\n\n/**\n * Adds a reference pattern.\n */\nexport function addReferencePattern(\n  temporal: TemporalModel,\n  pattern: string\n): TemporalModel {\n  const existing = temporal.reference_patterns ?? [];\n  if (existing.includes(pattern)) {\n    return temporal;\n  }\n  return {\n    ...temporal,\n    reference_patterns: [...existing, pattern],\n  };\n}\n\n/**\n * Calculates combined temporal confidence.\n */\nexport function calculateTemporalConfidence(\n  source: number,\n  granularity: number,\n  interpretation: number\n): TemporalConfidence {\n  return {\n    source,\n    granularity,\n    interpretation,\n    combined: source * granularity * interpretation,\n  };\n}\n\n// ============================================================\n// QUERY HELPERS\n// ============================================================\n\nexport type TimeQueryType = 'ingestion' | 'event' | 'content' | 'any';\n\n/**\n * Checks if a temporal model matches a time range query.\n */\nexport function matchesTimeRange(\n  temporal: TemporalModel,\n  start: string,\n  end: string,\n  queryType: TimeQueryType = 'any'\n): boolean {\n  const startDate = new Date(start);\n  const endDate = new Date(end);\n\n  const inRange = (timestamp: string): boolean => {\n    const date = new Date(timestamp);\n    return date >= startDate && date <= endDate;\n  };\n\n  // Check ingestion time\n  if (queryType === 'ingestion' || queryType === 'any') {\n    if (inRange(temporal.ingestion.timestamp)) {\n      return true;\n    }\n  }\n\n  // Check event time\n  if (queryType === 'event' || queryType === 'any') {\n    if (temporal.event && inRange(temporal.event.timestamp)) {\n      return true;\n    }\n  }\n\n  // Check content times\n  if (queryType === 'content' || queryType === 'any') {\n    if (temporal.content_times) {\n      for (const ct of temporal.content_times) {\n        if (inRange(ct.resolved)) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Gets the \"primary\" timestamp for a node.\n * Prefers event time if available, falls back to ingestion.\n */\nexport function getPrimaryTimestamp(temporal: TemporalModel): string {\n  return temporal.event?.timestamp ?? temporal.ingestion.timestamp;\n}\n\n/**\n * Checks if reference patterns match a query.\n */\nexport function matchesReferencePattern(\n  temporal: TemporalModel,\n  query: string\n): boolean {\n  if (!temporal.reference_patterns) {\n    return false;\n  }\n\n  const queryLower = query.toLowerCase();\n  return temporal.reference_patterns.some((pattern) => {\n    const patternLower = pattern.toLowerCase();\n    return queryLower.includes(patternLower) || patternLower.includes(queryLower);\n  });\n}\n\n// ============================================================\n// RE-EXPORTS\n// ============================================================\n\nexport type { EventTimeSource, ContentTimeType, TemporalGranularity };\n"]}