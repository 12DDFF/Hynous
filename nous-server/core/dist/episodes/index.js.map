{"version":3,"sources":["../../src/constants.ts","../../src/tps/index.ts","../../src/episodes/index.ts"],"names":["z"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * @module @nous/core/constants\n * @description All constants, enums, and configuration values\n * @version 0.1.0\n * @spec Brainstorms/Specs/storm-011/spec/constants.ts\n */\n\n// ============================================================\n// ID CONFIGURATION\n// ============================================================\n\n/** Length of nanoid for globally unique IDs */\nexport const NANOID_LENGTH = 12;\n\n/** Prefix for node IDs: \"n_\" + nanoid(12) */\nexport const NODE_ID_PREFIX = 'n_';\n\n/** Prefix for block IDs: \"b_\" + nanoid(12) */\nexport const BLOCK_ID_PREFIX = 'b_';\n\n/** Prefix for edge IDs: \"e_\" + nanoid(12) */\nexport const EDGE_ID_PREFIX = 'e_';\n\n/** Prefix for edit record IDs: \"edit_\" + nanoid(12) */\nexport const EDIT_ID_PREFIX = 'edit_';\n\n// ============================================================\n// NODE TYPES\n// ============================================================\n\nexport const NODE_TYPES = [\n  'concept',\n  'episode',\n  'document',\n  'section',\n  'chunk',\n  'note',\n  'raw',\n] as const;\n\nexport type NodeType = (typeof NODE_TYPES)[number];\n\nexport const SEMANTIC_LAYER_TYPES: NodeType[] = ['concept', 'note', 'chunk'];\nexport const EPISODE_LAYER_TYPES: NodeType[] = ['episode', 'document', 'section'];\nexport const ARCHIVE_LAYER_TYPES: NodeType[] = ['raw'];\n\n// ============================================================\n// SUBTYPES\n// ============================================================\n\nexport const CONCEPT_SUBTYPES = [\n  'fact',\n  'definition',\n  'relationship',\n  'preference',\n  'belief',\n  'procedure',\n  'entity',\n  'event',\n  'insight',\n] as const;\n\nexport type ConceptSubtype = (typeof CONCEPT_SUBTYPES)[number] | `custom:${string}`;\n\nexport const EPISODE_SUBTYPES = [\n  'lecture',\n  'meeting',\n  'conversation',\n  'note_session',\n  'document_read',\n  'thought',\n  'external_event',\n] as const;\n\nexport type EpisodeSubtype = (typeof EPISODE_SUBTYPES)[number] | `custom:${string}`;\n\nexport const RAW_SUBTYPES = [\n  'transcript',\n  'document',\n  'note',\n  'image',\n  'audio_recording',\n] as const;\n\nexport type RawSubtype = (typeof RAW_SUBTYPES)[number];\n\n// ============================================================\n// BLOCK TYPES\n// ============================================================\n\nexport const BLOCK_TYPES = [\n  'paragraph',\n  'heading',\n  'list',\n  'list_item',\n  'code',\n  'quote',\n  'callout',\n  'divider',\n  'table',\n  'image',\n] as const;\n\nexport type BlockType = (typeof BLOCK_TYPES)[number];\n\n// ============================================================\n// EDGE TYPES\n// ============================================================\n\nexport const EDGE_TYPES = [\n  'relates_to',\n  'part_of',\n  'mentioned_in',\n  'causes',\n  'precedes',\n  'contradicts',\n  'supersedes',\n  'derived_from',\n  'similar_to',\n] as const;\n\nexport type EdgeType = (typeof EDGE_TYPES)[number];\n\n// ============================================================\n// LIFECYCLE STATES\n// ============================================================\n\nexport const LIFECYCLE_STATES = [\n  'working',\n  'active',\n  'superseded',\n  'dormant',\n  'archived',\n] as const;\n\nexport type LifecycleState = (typeof LIFECYCLE_STATES)[number];\n\n// ============================================================\n// SOURCE TYPES\n// ============================================================\n\nexport const SOURCE_TYPES = [\n  'extraction',\n  'manual',\n  'inference',\n  'import',\n] as const;\n\nexport type SourceType = (typeof SOURCE_TYPES)[number];\n\n// ============================================================\n// CONTENT SOURCES\n// ============================================================\n\nexport const CONTENT_SOURCES = [\n  'import',\n  'user_note',\n  'chat_extraction',\n  'fact',\n  'document',\n  'transcript',\n] as const;\n\nexport type ContentSource = (typeof CONTENT_SOURCES)[number];\n\n// ============================================================\n// EDIT SYSTEM\n// ============================================================\n\nexport const EDIT_TARGET_METHODS = [\n  'block_id',\n  'heading',\n  'position',\n  'search',\n  'full',\n] as const;\n\nexport type EditTargetMethod = (typeof EDIT_TARGET_METHODS)[number];\n\nexport const EDIT_ACTIONS = ['replace', 'insert', 'append', 'delete'] as const;\n\nexport type EditAction = (typeof EDIT_ACTIONS)[number];\n\nexport const MODIFIERS = ['user', 'ai', 'system', 'sync'] as const;\n\nexport type Modifier = (typeof MODIFIERS)[number];\n\nexport const EDIT_HISTORY_RETENTION = {\n  maxEdits: 100,\n  maxAgeDays: 30,\n  undoWindowHours: 24,\n  pruneSchedule: 'daily',\n} as const;\n\n// ============================================================\n// TEMPORAL\n// ============================================================\n\nexport const TEMPORAL_GRANULARITIES = [\n  'minute',\n  'hour',\n  'day',\n  'week',\n  'month',\n  'year',\n] as const;\n\nexport type TemporalGranularity = (typeof TEMPORAL_GRANULARITIES)[number];\n\nexport const EVENT_TIME_SOURCES = ['explicit', 'inferred', 'user_stated'] as const;\n\nexport type EventTimeSource = (typeof EVENT_TIME_SOURCES)[number];\n\nexport const CONTENT_TIME_TYPES = ['historical', 'relative', 'approximate'] as const;\n\nexport type ContentTimeType = (typeof CONTENT_TIME_TYPES)[number];\n\n// ============================================================\n// PROCESSING PATHS\n// ============================================================\n\nexport const INPUT_TYPES = [\n  'DOCUMENT',\n  'TRANSCRIPT',\n  'CONVERSATION',\n  'NOTE',\n  'IMPORT',\n] as const;\n\nexport type InputType = (typeof INPUT_TYPES)[number];\n\nexport const INPUT_SIZES = ['tiny', 'small', 'medium', 'large', 'huge'] as const;\n\nexport type InputSize = (typeof INPUT_SIZES)[number];\n\nexport const PROCESSING_PATHS = [\n  'fast',\n  'standard',\n  'progressive',\n  'conversation',\n] as const;\n\nexport type ProcessingPath = (typeof PROCESSING_PATHS)[number];\n\nexport const SIZE_THRESHOLDS = {\n  tiny: { min: 0, max: 50 },\n  small: { min: 50, max: 500 },\n  medium: { min: 500, max: 5000 },\n  large: { min: 5000, max: 25000 },\n  huge: { min: 25000, max: Infinity },\n} as const;\n\n// ============================================================\n// BLOCK DECISION THRESHOLDS\n// ============================================================\n\nexport const BLOCK_LENGTH_THRESHOLD = 1000;\nexport const BLOCK_LIST_THRESHOLD = 3;\n\n// ============================================================\n// NEURAL DEFAULTS\n// ============================================================\n\nexport const NEURAL_DEFAULTS = {\n  stability: 0.5,\n  retrievability: 1.0,\n  accessCount: 0,\n} as const;\n\n// ============================================================\n// EXTRACTION DEPTH\n// ============================================================\n\nexport const EXTRACTION_DEPTHS = ['summary', 'section', 'full'] as const;\n\nexport type ExtractionDepth = (typeof EXTRACTION_DEPTHS)[number];\n\n// ============================================================\n// REGEX PATTERNS\n// ============================================================\n\nexport const HEADING_PATTERN = /^#{1,6}\\s/m;\nexport const LIST_ITEM_PATTERN = /^[-*]\\s/gm;\n","/**\n * @module @nous/core/tps\n * @description Temporal Parsing System (TPS) for natural language time queries\n * @version 0.1.0\n * @spec Brainstorms/Specs/storm-004/spec/temporal-parsing.ts\n *\n * Converts natural language time expressions into precise, searchable\n * constraints with confidence scores.\n *\n * Expression types:\n * - explicit_absolute: \"January 15, 2024\"\n * - explicit_relative: \"last week\", \"3 days ago\"\n * - fuzzy_period: \"around summer\", \"a while back\"\n * - duration: \"during the meeting\"\n * - none: No temporal expression found\n */\n\nimport { z } from 'zod';\nimport { type TemporalGranularity } from '../constants';\n\n// ============================================================\n// EXPRESSION TYPES\n// ============================================================\n\nexport const EXPRESSION_TYPES = [\n  'explicit_absolute',\n  'explicit_relative',\n  'fuzzy_period',\n  'duration',\n  'none',\n] as const;\n\nexport type ExpressionType = (typeof EXPRESSION_TYPES)[number];\n\n// ============================================================\n// TIME SOURCES\n// ============================================================\n\nexport const TIME_SOURCES = [\n  'user_explicit',\n  'calendar_sync',\n  'file_timestamp',\n  'content_extraction',\n  'context_inference',\n  'unknown',\n] as const;\n\nexport type TimeSource = (typeof TIME_SOURCES)[number];\n\n// ============================================================\n// CONFIDENCE VALUES\n// ============================================================\n\n/**\n * Source confidence values based on how time was obtained.\n */\nexport const SOURCE_CONFIDENCE: Record<TimeSource, number> = {\n  user_explicit: 1.0,\n  calendar_sync: 0.95,\n  file_timestamp: 0.9,\n  content_extraction: 0.7,\n  context_inference: 0.5,\n  unknown: 0.3,\n};\n\n/**\n * Granularity confidence values based on precision level.\n */\nexport const GRANULARITY_CONFIDENCE: Record<TemporalGranularity, number> = {\n  minute: 1.0,\n  hour: 0.9,\n  day: 0.8,\n  week: 0.6,\n  month: 0.4,\n  year: 0.2,\n};\n\n/**\n * Expression type interpretation confidence.\n */\nexport const INTERPRETATION_CONFIDENCE: Record<ExpressionType, number> = {\n  explicit_absolute: 1.0,\n  explicit_relative: 0.95,\n  fuzzy_period: 0.6,\n  duration: 0.8,\n  none: 1.0,\n};\n\n// ============================================================\n// CONFIDENCE FACTORS\n// ============================================================\n\n/**\n * Three-factor temporal confidence scoring.\n */\nexport interface ConfidenceFactors {\n  /** How we got this time (0-1) */\n  source: number;\n  /** How precise the time is (0-1) */\n  granularity: number;\n  /** How sure about parsing (0-1) */\n  interpretation: number;\n}\n\nexport const ConfidenceFactorsSchema = z.object({\n  source: z.number().min(0).max(1),\n  granularity: z.number().min(0).max(1),\n  interpretation: z.number().min(0).max(1),\n});\n\n/**\n * Calculates combined temporal confidence.\n * Formula: source × granularity × interpretation\n */\nexport function computeConfidenceScore(factors: ConfidenceFactors): number {\n  return factors.source * factors.granularity * factors.interpretation;\n}\n\n/**\n * Gets source confidence for a time source.\n */\nexport function getSourceConfidence(source: TimeSource): number {\n  return SOURCE_CONFIDENCE[source];\n}\n\n/**\n * Gets granularity confidence for a precision level.\n */\nexport function getGranularityConfidence(granularity: TemporalGranularity): number {\n  return GRANULARITY_CONFIDENCE[granularity];\n}\n\n/**\n * Gets interpretation confidence for an expression type.\n */\nexport function getInterpretationConfidence(type: ExpressionType): number {\n  return INTERPRETATION_CONFIDENCE[type];\n}\n\n// ============================================================\n// TPS INPUT / OUTPUT\n// ============================================================\n\n/**\n * Input to the Temporal Parsing System.\n */\nexport interface TPSInput {\n  /** Full query text */\n  query: string;\n  /** When the query was made (ISO 8601) */\n  referenceTimestamp: string;\n  /** User's timezone (IANA format) */\n  userTimezone: string;\n}\n\nexport const TPSInputSchema = z.object({\n  query: z.string().min(1),\n  referenceTimestamp: z.string().datetime(),\n  userTimezone: z.string().min(1),\n});\n\n/**\n * Temporal constraint extracted from a query.\n */\nexport interface TemporalConstraint {\n  /** Start of search range (ISO 8601 UTC) */\n  rangeStart: string;\n  /** End of search range (ISO 8601 UTC) */\n  rangeEnd: string;\n  /** Confidence in this range (0-1) */\n  rangeConfidence: number;\n  /** Type of expression parsed */\n  expressionType: ExpressionType;\n  /** Original text that was parsed */\n  originalExpression: string;\n}\n\nexport const TemporalConstraintSchema = z.object({\n  rangeStart: z.string().datetime(),\n  rangeEnd: z.string().datetime(),\n  rangeConfidence: z.number().min(0).max(1),\n  expressionType: z.enum(EXPRESSION_TYPES),\n  originalExpression: z.string(),\n});\n\n/**\n * Output from the Temporal Parsing System.\n */\nexport interface TPSOutput {\n  /** Parsed temporal constraint (null if no time in query) */\n  temporalConstraint: TemporalConstraint | null;\n  /** Non-temporal parts of the query */\n  entitiesExtracted: string[];\n  /** Overall parsing confidence (0-1) */\n  parsingConfidence: number;\n}\n\nexport const TPSOutputSchema = z.object({\n  temporalConstraint: TemporalConstraintSchema.nullable(),\n  entitiesExtracted: z.array(z.string()),\n  parsingConfidence: z.number().min(0).max(1),\n});\n\n// ============================================================\n// SEASONS\n// ============================================================\n\nexport interface SeasonRange {\n  startMonth: number; // 1-12\n  startDay: number;\n  endMonth: number;\n  endDay: number;\n}\n\n/**\n * Northern Hemisphere season definitions.\n */\nexport const SEASONS: Record<string, SeasonRange> = {\n  spring: { startMonth: 3, startDay: 1, endMonth: 5, endDay: 31 },\n  summer: { startMonth: 6, startDay: 1, endMonth: 8, endDay: 31 },\n  fall: { startMonth: 9, startDay: 1, endMonth: 11, endDay: 30 },\n  autumn: { startMonth: 9, startDay: 1, endMonth: 11, endDay: 30 },\n  winter: { startMonth: 12, startDay: 1, endMonth: 2, endDay: 28 },\n};\n\n/**\n * Detects if a query contains a season reference.\n */\nexport function detectSeason(query: string): string | null {\n  const lowerQuery = query.toLowerCase();\n  for (const season of Object.keys(SEASONS)) {\n    if (lowerQuery.includes(season)) {\n      return season;\n    }\n  }\n  return null;\n}\n\n/**\n * Gets the date range for a season in a given year.\n */\nexport function getSeasonRange(\n  season: string,\n  year: number\n): { start: Date; end: Date } | null {\n  const range = SEASONS[season.toLowerCase()];\n  if (!range) {\n    return null;\n  }\n\n  // Handle winter which spans years\n  if (season.toLowerCase() === 'winter') {\n    return {\n      start: new Date(Date.UTC(year, range.startMonth - 1, range.startDay)),\n      end: new Date(Date.UTC(year + 1, range.endMonth - 1, range.endDay)),\n    };\n  }\n\n  return {\n    start: new Date(Date.UTC(year, range.startMonth - 1, range.startDay)),\n    end: new Date(Date.UTC(year, range.endMonth - 1, range.endDay)),\n  };\n}\n\n// ============================================================\n// TEMPORAL PARSING\n// ============================================================\n\n/**\n * Relative time patterns with their calculations.\n */\nconst RELATIVE_PATTERNS: {\n  pattern: RegExp;\n  calculate: (match: RegExpMatchArray, ref: Date) => { start: Date; end: Date };\n}[] = [\n  {\n    pattern: /yesterday/i,\n    calculate: (_, ref) => {\n      const start = new Date(ref);\n      start.setDate(start.getDate() - 1);\n      start.setHours(0, 0, 0, 0);\n      const end = new Date(start);\n      end.setHours(23, 59, 59, 999);\n      return { start, end };\n    },\n  },\n  {\n    pattern: /today/i,\n    calculate: (_, ref) => {\n      const start = new Date(ref);\n      start.setHours(0, 0, 0, 0);\n      const end = new Date(start);\n      end.setHours(23, 59, 59, 999);\n      return { start, end };\n    },\n  },\n  {\n    pattern: /last\\s+week/i,\n    calculate: (_, ref) => {\n      const end = new Date(ref);\n      end.setDate(end.getDate() - 1);\n      const start = new Date(end);\n      start.setDate(start.getDate() - 6);\n      start.setHours(0, 0, 0, 0);\n      end.setHours(23, 59, 59, 999);\n      return { start, end };\n    },\n  },\n  {\n    pattern: /last\\s+month/i,\n    calculate: (_, ref) => {\n      const start = new Date(ref);\n      start.setMonth(start.getMonth() - 1, 1);\n      start.setHours(0, 0, 0, 0);\n      const end = new Date(start);\n      end.setMonth(end.getMonth() + 1, 0);\n      end.setHours(23, 59, 59, 999);\n      return { start, end };\n    },\n  },\n  {\n    pattern: /(\\d+)\\s+days?\\s+ago/i,\n    calculate: (match, ref) => {\n      const days = parseInt(match[1] ?? '1', 10);\n      const start = new Date(ref);\n      start.setDate(start.getDate() - days);\n      start.setHours(0, 0, 0, 0);\n      const end = new Date(start);\n      end.setHours(23, 59, 59, 999);\n      return { start, end };\n    },\n  },\n  {\n    pattern: /(\\d+)\\s+weeks?\\s+ago/i,\n    calculate: (match, ref) => {\n      const weeks = parseInt(match[1] ?? '1', 10);\n      const end = new Date(ref);\n      end.setDate(end.getDate() - weeks * 7);\n      const start = new Date(end);\n      start.setDate(start.getDate() - 6);\n      start.setHours(0, 0, 0, 0);\n      end.setHours(23, 59, 59, 999);\n      return { start, end };\n    },\n  },\n  {\n    pattern: /(\\d+)\\s+months?\\s+ago/i,\n    calculate: (match, ref) => {\n      const months = parseInt(match[1] ?? '1', 10);\n      const start = new Date(ref);\n      start.setMonth(start.getMonth() - months, 1);\n      start.setHours(0, 0, 0, 0);\n      const end = new Date(start);\n      end.setMonth(end.getMonth() + 1, 0);\n      end.setHours(23, 59, 59, 999);\n      return { start, end };\n    },\n  },\n];\n\n/**\n * Month names for parsing.\n */\nconst MONTHS: Record<string, number> = {\n  january: 0,\n  february: 1,\n  march: 2,\n  april: 3,\n  may: 4,\n  june: 5,\n  july: 6,\n  august: 7,\n  september: 8,\n  october: 9,\n  november: 10,\n  december: 11,\n  jan: 0,\n  feb: 1,\n  mar: 2,\n  apr: 3,\n  jun: 5,\n  jul: 6,\n  aug: 7,\n  sep: 8,\n  sept: 8,\n  oct: 9,\n  nov: 10,\n  dec: 11,\n};\n\n/**\n * Parses relative time expressions.\n */\nexport function parseRelativeTime(\n  query: string,\n  referenceDate: Date\n): { start: Date; end: Date; expression: string } | null {\n  for (const { pattern, calculate } of RELATIVE_PATTERNS) {\n    const match = query.match(pattern);\n    if (match) {\n      const { start, end } = calculate(match, referenceDate);\n      return { start, end, expression: match[0] };\n    }\n  }\n  return null;\n}\n\n/**\n * Parses absolute month references (e.g., \"September\", \"in September 2024\").\n */\nexport function parseAbsoluteMonth(\n  query: string,\n  referenceDate: Date\n): { start: Date; end: Date; expression: string } | null {\n  // Match \"in [Month]\" or just \"[Month]\" with optional year\n  const monthPattern =\n    /(?:in\\s+)?(january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|jun|jul|aug|sep|sept|oct|nov|dec)(?:\\s+(\\d{4}))?/i;\n  const match = query.match(monthPattern);\n\n  if (match && match[1]) {\n    const monthName = match[1].toLowerCase();\n    const month = MONTHS[monthName];\n\n    // If month is not recognized, return null\n    if (month === undefined) {\n      return null;\n    }\n\n    const year = match[2] ? parseInt(match[2], 10) : undefined;\n\n    let targetYear = year ?? referenceDate.getFullYear();\n\n    // If no year specified and the month is in the future, use last year\n    if (!year) {\n      const refMonth = referenceDate.getMonth();\n      if (month > refMonth) {\n        targetYear -= 1;\n      }\n    }\n\n    const start = new Date(Date.UTC(targetYear, month, 1, 0, 0, 0, 0));\n    const end = new Date(Date.UTC(targetYear, month + 1, 0, 23, 59, 59, 999));\n\n    return { start, end, expression: match[0] };\n  }\n\n  return null;\n}\n\n/**\n * Parses fuzzy time expressions.\n */\nexport function parseFuzzyTime(\n  query: string,\n  referenceDate: Date\n): { start: Date; end: Date; expression: string; confidence: number } | null {\n  const lowerQuery = query.toLowerCase();\n\n  // \"recently\" - last 7 days\n  if (lowerQuery.includes('recently')) {\n    const end = new Date(referenceDate);\n    const start = new Date(referenceDate);\n    start.setDate(start.getDate() - 7);\n    start.setHours(0, 0, 0, 0);\n    end.setHours(23, 59, 59, 999);\n    return { start, end, expression: 'recently', confidence: 0.7 };\n  }\n\n  // \"a while back\" - 1-6 months ago\n  if (lowerQuery.includes('a while back') || lowerQuery.includes('a while ago')) {\n    const end = new Date(referenceDate);\n    end.setMonth(end.getMonth() - 1);\n    const start = new Date(referenceDate);\n    start.setMonth(start.getMonth() - 6);\n    start.setHours(0, 0, 0, 0);\n    end.setHours(23, 59, 59, 999);\n    return { start, end, expression: 'a while back', confidence: 0.4 };\n  }\n\n  // \"a few months ago\" - 2-4 months ago\n  if (lowerQuery.includes('a few months ago')) {\n    const end = new Date(referenceDate);\n    end.setMonth(end.getMonth() - 2);\n    const start = new Date(referenceDate);\n    start.setMonth(start.getMonth() - 4);\n    start.setHours(0, 0, 0, 0);\n    end.setHours(23, 59, 59, 999);\n    return { start, end, expression: 'a few months ago', confidence: 0.5 };\n  }\n\n  // Season detection\n  const season = detectSeason(query);\n  if (season) {\n    let targetYear = referenceDate.getFullYear();\n    const range = getSeasonRange(season, targetYear);\n\n    if (range) {\n      // If the season end is in the future, use last year\n      if (range.end > referenceDate) {\n        const lastYearRange = getSeasonRange(season, targetYear - 1);\n        if (lastYearRange) {\n          return {\n            start: lastYearRange.start,\n            end: lastYearRange.end,\n            expression: season,\n            confidence: 0.6,\n          };\n        }\n      }\n      return { start: range.start, end: range.end, expression: season, confidence: 0.6 };\n    }\n  }\n\n  return null;\n}\n\n/**\n * Main TPS parsing function.\n * Parses a query to extract temporal constraints.\n */\nexport function parseTemporalExpression(input: TPSInput): TPSOutput {\n  const referenceDate = new Date(input.referenceTimestamp);\n  const query = input.query;\n\n  // Try relative time first\n  const relative = parseRelativeTime(query, referenceDate);\n  if (relative) {\n    return {\n      temporalConstraint: {\n        rangeStart: relative.start.toISOString(),\n        rangeEnd: relative.end.toISOString(),\n        rangeConfidence: 0.95,\n        expressionType: 'explicit_relative',\n        originalExpression: relative.expression,\n      },\n      entitiesExtracted: extractNonTemporalEntities(query, relative.expression),\n      parsingConfidence: 0.95,\n    };\n  }\n\n  // Try absolute month\n  const absolute = parseAbsoluteMonth(query, referenceDate);\n  if (absolute) {\n    return {\n      temporalConstraint: {\n        rangeStart: absolute.start.toISOString(),\n        rangeEnd: absolute.end.toISOString(),\n        rangeConfidence: 1.0,\n        expressionType: 'explicit_absolute',\n        originalExpression: absolute.expression,\n      },\n      entitiesExtracted: extractNonTemporalEntities(query, absolute.expression),\n      parsingConfidence: 1.0,\n    };\n  }\n\n  // Try fuzzy time\n  const fuzzy = parseFuzzyTime(query, referenceDate);\n  if (fuzzy) {\n    return {\n      temporalConstraint: {\n        rangeStart: fuzzy.start.toISOString(),\n        rangeEnd: fuzzy.end.toISOString(),\n        rangeConfidence: fuzzy.confidence,\n        expressionType: 'fuzzy_period',\n        originalExpression: fuzzy.expression,\n      },\n      entitiesExtracted: extractNonTemporalEntities(query, fuzzy.expression),\n      parsingConfidence: fuzzy.confidence,\n    };\n  }\n\n  // No temporal expression found\n  return {\n    temporalConstraint: null,\n    entitiesExtracted: extractNonTemporalEntities(query, ''),\n    parsingConfidence: 1.0,\n  };\n}\n\n/**\n * Extracts non-temporal entities from a query.\n * Simple word extraction - more sophisticated NER would be added later.\n */\nfunction extractNonTemporalEntities(query: string, temporalPart: string): string[] {\n  // Remove the temporal part\n  let remaining = query.replace(temporalPart, '').trim();\n\n  // Remove common query words\n  const stopWords = [\n    'what',\n    'when',\n    'where',\n    'who',\n    'how',\n    'did',\n    'do',\n    'does',\n    'the',\n    'a',\n    'an',\n    'in',\n    'on',\n    'at',\n    'to',\n    'for',\n    'of',\n    'with',\n    'about',\n    'i',\n    'me',\n    'my',\n    'we',\n    'our',\n    'learn',\n    'learned',\n    'teach',\n    'taught',\n  ];\n\n  const words = remaining\n    .toLowerCase()\n    .replace(/[^\\w\\s]/g, '')\n    .split(/\\s+/)\n    .filter((word) => word.length > 2 && !stopWords.includes(word));\n\n  // Remove duplicates\n  return [...new Set(words)];\n}\n\n// ============================================================\n// QUERY STEP BUDGETS (from spec)\n// ============================================================\n\nexport const QUERY_STEP_BUDGETS = {\n  temporalParsing: 5,\n  entityExtraction: 3,\n  episodeFilter: 10,\n  semanticFilter: 30,\n  confidenceAggregate: 2,\n  resultAssembly: 3,\n  phase2Handoff: 2,\n} as const;\n\nexport const PHASE_1_BUDGET_MS = 55;\n\n/**\n * Checks if the total latency is within Phase 1 budget.\n */\nexport function isWithinBudget(latencyMs: number): boolean {\n  return latencyMs <= PHASE_1_BUDGET_MS;\n}\n\n// ============================================================\n// VALIDATION\n// ============================================================\n\n/**\n * Validates TPS input.\n */\nexport function validateTPSInput(input: unknown): input is TPSInput {\n  return TPSInputSchema.safeParse(input).success;\n}\n\n/**\n * Validates TPS output.\n */\nexport function validateTPSOutput(output: unknown): output is TPSOutput {\n  return TPSOutputSchema.safeParse(output).success;\n}\n\n/**\n * Validates a temporal constraint.\n */\nexport function validateTemporalConstraint(\n  constraint: unknown\n): constraint is TemporalConstraint {\n  return TemporalConstraintSchema.safeParse(constraint).success;\n}\n\n// ============================================================\n// RE-EXPORTS\n// ============================================================\n\nexport type { TemporalGranularity };\n","/**\n * @module @nous/core/episodes\n * @description Episode utilities with enhanced TPS metadata\n * @version 0.1.0\n * @spec Brainstorms/Specs/storm-004/spec/episode-schema.ts\n *\n * Episodes are time-indexed event containers that link\n * semantic concepts to temporal contexts.\n */\n\nimport { z } from 'zod';\nimport { nanoid } from 'nanoid';\nimport {\n  NANOID_LENGTH,\n  EPISODE_SUBTYPES,\n  type EpisodeSubtype,\n  type TemporalGranularity,\n} from '../constants';\nimport {\n  type ConfidenceFactors,\n  type TimeSource,\n  ConfidenceFactorsSchema,\n  computeConfidenceScore,\n  getSourceConfidence,\n  getGranularityConfidence,\n  TIME_SOURCES,\n} from '../tps';\n\n// ============================================================\n// EPISODE ID\n// ============================================================\n\n/** Prefix for episode IDs */\nexport const EPISODE_ID_PREFIX = 'ep_';\n\n/**\n * Generates a globally unique episode ID.\n * Format: \"ep_\" + nanoid(12)\n */\nexport function generateEpisodeId(): string {\n  return EPISODE_ID_PREFIX + nanoid(NANOID_LENGTH);\n}\n\n// ============================================================\n// EPISODE TYPES\n// ============================================================\n\nexport const EPISODE_TYPES = EPISODE_SUBTYPES;\nexport type EpisodeType = EpisodeSubtype;\n\n// ============================================================\n// EPISODE TEMPORAL METADATA\n// ============================================================\n\n/**\n * Enhanced temporal metadata for episodes.\n * Includes three-factor confidence scoring.\n */\nexport interface EpisodeTemporalMetadata {\n  /** Primary timestamp in UTC (ISO 8601) */\n  timestampUtc: string;\n  /** Original timezone where event occurred (IANA format) */\n  timezoneOriginal: string;\n  /** Precision level of the timestamp */\n  granularity: TemporalGranularity;\n  /** Three-factor confidence scoring */\n  confidence: ConfidenceFactors;\n  /** Duration in minutes (for duration-based episodes) */\n  durationMinutes?: number;\n  /** End timestamp for duration-based episodes */\n  endTimestampUtc?: string;\n}\n\nexport const EpisodeTemporalMetadataSchema = z.object({\n  timestampUtc: z.string().datetime(),\n  timezoneOriginal: z.string().min(1),\n  granularity: z.enum(['minute', 'hour', 'day', 'week', 'month', 'year']),\n  confidence: ConfidenceFactorsSchema,\n  durationMinutes: z.number().int().positive().optional(),\n  endTimestampUtc: z.string().datetime().optional(),\n});\n\n// ============================================================\n// EPISODE INTERFACE\n// ============================================================\n\n/**\n * An episode is a time-indexed event container.\n *\n * Episodes link:\n * - Temporal context (when it happened)\n * - Semantic concepts (what was learned/discussed)\n * - Archive sources (full content if needed)\n */\nexport interface Episode {\n  /** Globally unique episode ID */\n  id: string;\n  /** Type of episode */\n  type: EpisodeType;\n  /** Brief summary of the episode */\n  summary: string;\n  /** IDs of concepts extracted from this episode */\n  conceptLinks: string[];\n  /** ID of archive node with full content (if any) */\n  archiveLink: string | null;\n  /** Enhanced temporal metadata */\n  temporal: EpisodeTemporalMetadata;\n  /** When this episode record was created */\n  createdAt: string;\n  /** When this episode record was last updated */\n  updatedAt: string;\n}\n\nexport const EpisodeSchema = z.object({\n  id: z.string().regex(new RegExp(`^${EPISODE_ID_PREFIX}[a-zA-Z0-9_-]{${NANOID_LENGTH}}$`)),\n  type: z.union([z.enum(EPISODE_TYPES), z.string().regex(/^custom:.+$/)]),\n  summary: z.string().min(1),\n  conceptLinks: z.array(z.string()),\n  archiveLink: z.string().nullable(),\n  temporal: EpisodeTemporalMetadataSchema,\n  createdAt: z.string().datetime(),\n  updatedAt: z.string().datetime(),\n});\n\n// ============================================================\n// FACTORY FUNCTIONS\n// ============================================================\n\n/**\n * Options for creating an episode.\n */\nexport interface CreateEpisodeOptions {\n  /** Timestamp of the event (defaults to now) */\n  timestamp?: Date;\n  /** Timezone where event occurred */\n  timezone?: string;\n  /** How the timestamp was obtained */\n  timeSource?: TimeSource;\n  /** Precision of the timestamp */\n  granularity?: TemporalGranularity;\n  /** Concept IDs linked to this episode */\n  conceptLinks?: string[];\n  /** Archive node ID */\n  archiveLink?: string | null;\n  /** Duration in minutes */\n  durationMinutes?: number;\n}\n\n/**\n * Creates a new episode with default values.\n *\n * @param type - Type of episode\n * @param summary - Brief description\n * @param options - Optional configuration\n * @returns New episode object\n *\n * @example\n * const episode = createEpisode('lecture', 'Fourier transforms lecture', {\n *   timestamp: new Date('2024-09-12T10:00:00Z'),\n *   timeSource: 'calendar_sync',\n *   granularity: 'hour'\n * });\n */\nexport function createEpisode(\n  type: EpisodeType,\n  summary: string,\n  options: CreateEpisodeOptions = {}\n): Episode {\n  const now = new Date();\n  const timestamp = options.timestamp ?? now;\n  const granularity = options.granularity ?? 'day';\n  const timeSource = options.timeSource ?? 'unknown';\n\n  const confidence: ConfidenceFactors = {\n    source: getSourceConfidence(timeSource),\n    granularity: getGranularityConfidence(granularity),\n    interpretation: 1.0, // Direct creation, no parsing needed\n  };\n\n  const temporal: EpisodeTemporalMetadata = {\n    timestampUtc: timestamp.toISOString(),\n    timezoneOriginal: options.timezone ?? 'UTC',\n    granularity,\n    confidence,\n    durationMinutes: options.durationMinutes,\n    endTimestampUtc: options.durationMinutes\n      ? new Date(timestamp.getTime() + options.durationMinutes * 60 * 1000).toISOString()\n      : undefined,\n  };\n\n  return {\n    id: generateEpisodeId(),\n    type,\n    summary,\n    conceptLinks: options.conceptLinks ?? [],\n    archiveLink: options.archiveLink ?? null,\n    temporal,\n    createdAt: now.toISOString(),\n    updatedAt: now.toISOString(),\n  };\n}\n\n/**\n * Creates default temporal metadata for an episode.\n */\nexport function createEpisodeTemporalMetadata(\n  timestamp: Date,\n  options: {\n    timezone?: string;\n    granularity?: TemporalGranularity;\n    timeSource?: TimeSource;\n  } = {}\n): EpisodeTemporalMetadata {\n  const granularity = options.granularity ?? 'day';\n  const timeSource = options.timeSource ?? 'unknown';\n\n  return {\n    timestampUtc: timestamp.toISOString(),\n    timezoneOriginal: options.timezone ?? 'UTC',\n    granularity,\n    confidence: {\n      source: getSourceConfidence(timeSource),\n      granularity: getGranularityConfidence(granularity),\n      interpretation: 1.0,\n    },\n  };\n}\n\n// ============================================================\n// EPISODE OPERATIONS\n// ============================================================\n\n/**\n * Adds a concept link to an episode.\n */\nexport function addConceptLink(episode: Episode, conceptId: string): Episode {\n  if (episode.conceptLinks.includes(conceptId)) {\n    return episode;\n  }\n  return {\n    ...episode,\n    conceptLinks: [...episode.conceptLinks, conceptId],\n    updatedAt: new Date().toISOString(),\n  };\n}\n\n/**\n * Removes a concept link from an episode.\n */\nexport function removeConceptLink(episode: Episode, conceptId: string): Episode {\n  if (!episode.conceptLinks.includes(conceptId)) {\n    return episode;\n  }\n  return {\n    ...episode,\n    conceptLinks: episode.conceptLinks.filter((id) => id !== conceptId),\n    updatedAt: new Date().toISOString(),\n  };\n}\n\n/**\n * Sets the archive link for an episode.\n */\nexport function setArchiveLink(episode: Episode, archiveId: string | null): Episode {\n  return {\n    ...episode,\n    archiveLink: archiveId,\n    updatedAt: new Date().toISOString(),\n  };\n}\n\n/**\n * Updates the summary of an episode.\n */\nexport function updateEpisodeSummary(episode: Episode, summary: string): Episode {\n  return {\n    ...episode,\n    summary,\n    updatedAt: new Date().toISOString(),\n  };\n}\n\n// ============================================================\n// CONFIDENCE CALCULATION\n// ============================================================\n\n/**\n * Calculates the overall confidence score for an episode's timestamp.\n */\nexport function calculateEpisodeConfidence(episode: Episode): number {\n  return computeConfidenceScore(episode.temporal.confidence);\n}\n\n/**\n * Checks if an episode has high temporal confidence.\n */\nexport function hasHighConfidence(episode: Episode, threshold: number = 0.7): boolean {\n  return calculateEpisodeConfidence(episode) >= threshold;\n}\n\n// ============================================================\n// TEMPORAL QUERIES\n// ============================================================\n\n/**\n * Checks if an episode falls within a time range.\n */\nexport function isEpisodeInRange(\n  episode: Episode,\n  rangeStart: string,\n  rangeEnd: string\n): boolean {\n  const episodeTime = new Date(episode.temporal.timestampUtc).getTime();\n  const start = new Date(rangeStart).getTime();\n  const end = new Date(rangeEnd).getTime();\n\n  return episodeTime >= start && episodeTime <= end;\n}\n\n/**\n * Filters episodes by time range.\n */\nexport function filterEpisodesByTimeRange(\n  episodes: Episode[],\n  rangeStart: string,\n  rangeEnd: string\n): Episode[] {\n  return episodes.filter((ep) => isEpisodeInRange(ep, rangeStart, rangeEnd));\n}\n\n/**\n * Filters episodes by type.\n */\nexport function filterEpisodesByType(episodes: Episode[], type: EpisodeType): Episode[] {\n  return episodes.filter((ep) => ep.type === type);\n}\n\n/**\n * Sorts episodes by timestamp (newest first).\n */\nexport function sortEpisodesByTime(episodes: Episode[]): Episode[] {\n  return [...episodes].sort((a, b) => {\n    const timeA = new Date(a.temporal.timestampUtc).getTime();\n    const timeB = new Date(b.temporal.timestampUtc).getTime();\n    return timeB - timeA;\n  });\n}\n\n/**\n * Sorts episodes by confidence (highest first).\n */\nexport function sortEpisodesByConfidence(episodes: Episode[]): Episode[] {\n  return [...episodes].sort((a, b) => {\n    return calculateEpisodeConfidence(b) - calculateEpisodeConfidence(a);\n  });\n}\n\n/**\n * Gets episodes that contain a specific concept.\n */\nexport function getEpisodesWithConcept(episodes: Episode[], conceptId: string): Episode[] {\n  return episodes.filter((ep) => ep.conceptLinks.includes(conceptId));\n}\n\n/**\n * Gets the most recent episodes.\n */\nexport function getMostRecentEpisodes(episodes: Episode[], limit: number = 10): Episode[] {\n  return sortEpisodesByTime(episodes).slice(0, limit);\n}\n\n// ============================================================\n// MATCH FACTORS (for query flow)\n// ============================================================\n\n/**\n * Factors contributing to a match score.\n */\nexport interface MatchFactors {\n  /** How well the temporal constraint matched */\n  temporalMatch: number;\n  /** Episode's own confidence */\n  episodeConfidence: number;\n  /** How well semantic entities matched */\n  semanticMatch: number;\n}\n\nexport const MatchFactorsSchema = z.object({\n  temporalMatch: z.number().min(0).max(1),\n  episodeConfidence: z.number().min(0).max(1),\n  semanticMatch: z.number().min(0).max(1),\n});\n\n/**\n * Calculates overall match score from factors.\n * Formula: temporal × episode × semantic\n */\nexport function calculateMatchScore(factors: MatchFactors): number {\n  return factors.temporalMatch * factors.episodeConfidence * factors.semanticMatch;\n}\n\n/**\n * A matched episode with its confidence score.\n */\nexport interface EpisodeMatch {\n  /** The matched episode */\n  episode: Episode;\n  /** Overall match confidence */\n  confidence: number;\n  /** Individual match factors */\n  matchFactors: MatchFactors;\n}\n\nexport const EpisodeMatchSchema = z.object({\n  episode: EpisodeSchema,\n  confidence: z.number().min(0).max(1),\n  matchFactors: MatchFactorsSchema,\n});\n\n/**\n * Builds an episode match from an episode and match factors.\n */\nexport function buildEpisodeMatch(episode: Episode, factors: MatchFactors): EpisodeMatch {\n  return {\n    episode,\n    confidence: calculateMatchScore(factors),\n    matchFactors: factors,\n  };\n}\n\n// ============================================================\n// VALIDATION\n// ============================================================\n\n/**\n * Validates an episode against the schema.\n */\nexport function validateEpisode(episode: unknown): episode is Episode {\n  return EpisodeSchema.safeParse(episode).success;\n}\n\n/**\n * Parses and validates episode data.\n */\nexport function parseEpisode(data: unknown): Episode {\n  return EpisodeSchema.parse(data) as Episode;\n}\n\n/**\n * Safely parses episode data, returning null on failure.\n */\nexport function safeParseEpisode(data: unknown): Episode | null {\n  const result = EpisodeSchema.safeParse(data);\n  return result.success ? (result.data as Episode) : null;\n}\n\n// ============================================================\n// RE-EXPORTS\n// ============================================================\n\nexport type { TimeSource, TemporalGranularity };\nexport { TIME_SOURCES };\n"]}